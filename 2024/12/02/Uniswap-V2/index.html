<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Uniswap V2核心代码简析 | 0xOne1eaF's Blog Post</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>Uniswap V2核心代码简析</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2024-12-01T16:00:00.000Z" id="date"> 2024-12-02</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-12-02T18:25:00.373Z" id="updated"> 2024-12-03</time></div></span></div></div><hr><div id="post-content"><h1 id="Uniswap-V2核心代码简析"><a href="#Uniswap-V2核心代码简析" class="headerlink" title="Uniswap V2核心代码简析"></a>Uniswap V2核心代码简析</h1><blockquote>
<p>前言：本篇文章我将对Uniswap V2相较于V1的一些升级做出总结，并且根据github上的Uniswap V2源码进行一些中文的注释，注释参考了<a target="_blank" rel="noopener" href="https://github.com/kpyaoqi/UniswapV2_Chinese/tree/master/v2-core">UniswapV2_Chinese&#x2F;v2-core at master · kpyaoqi&#x2F;UniswapV2_Chinese</a></p>
</blockquote>
<h2 id="1-Uniswap-V2-相较于V1的优势"><a href="#1-Uniswap-V2-相较于V1的优势" class="headerlink" title="(1).Uniswap V2 相较于V1的优势"></a>(1).Uniswap V2 相较于V1的优势</h2><h3 id="1-支持任意代币对"><a href="#1-支持任意代币对" class="headerlink" title="1. 支持任意代币对"></a><strong>1. 支持任意代币对</strong></h3><ul>
<li><strong>V1</strong> 仅支持以 <strong>ETH</strong> 为中介的交易对（即每个交易对必须包含 ETH），无法直接交换两种 ERC-20 代币。0</li>
<li><strong>V2</strong> 允许任何两种 ERC-20 代币直接交易，不需要通过 ETH 作为中介，这提高了灵活性并减少了交易步骤。</li>
</ul>
<h3 id="2-引入了时间加权平均价格（TWAP）"><a href="#2-引入了时间加权平均价格（TWAP）" class="headerlink" title="2. 引入了时间加权平均价格（TWAP）"></a><strong>2. 引入了时间加权平均价格（TWAP）</strong></h3><ul>
<li><strong>V1</strong> 没有内置的价格预言机制，依赖外部数据源。</li>
<li><strong>V2</strong> 引入了时间加权平均价格（TWAP），可以通过计算一定时间窗口内的价格平均值，作为价格数据的来源。这一功能不仅提供了价格保护，还能减少短期市场波动对价格的影响。</li>
</ul>
<h3 id="3-提供闪电交换（Flash-Swap）"><a href="#3-提供闪电交换（Flash-Swap）" class="headerlink" title="3. 提供闪电交换（Flash Swap）"></a><strong>3. 提供闪电交换（Flash Swap）</strong></h3><ul>
<li><strong>V1</strong> 没有提供类似功能。</li>
<li><strong>V2</strong> 引入了闪电交换功能，允许用户在交易开始时无需预先提供资金，完成交易后才结算。用户可以通过这种机制进行套利、借贷等操作。</li>
</ul>
<h3 id="4-改进的手续费机制"><a href="#4-改进的手续费机制" class="headerlink" title="4. 改进的手续费机制"></a><strong>4. 改进的手续费机制</strong></h3><ul>
<li><strong>V1</strong> 的手续费为 0.3%，且不可调节。</li>
<li><strong>V2</strong> 依旧保持 0.3% 的手续费，但协议引入了更灵活的机制，允许调整某些方面的费用结构，进一步提升了协议的可扩展性和适应性。</li>
</ul>
<h3 id="5-支持更复杂的交易逻辑"><a href="#5-支持更复杂的交易逻辑" class="headerlink" title="5. 支持更复杂的交易逻辑"></a><strong>5. 支持更复杂的交易逻辑</strong></h3><ul>
<li><strong>V2</strong> 支持通过合约执行更复杂的交易逻辑，比如支持智能合约中的多代币交换、套利等操作，这使得它可以被集成进更多的金融工具和应用。</li>
</ul>
<h3 id="6-安全性增强"><a href="#6-安全性增强" class="headerlink" title="6. 安全性增强"></a><strong>6. 安全性增强</strong></h3><ul>
<li><strong>V2</strong> 引入了更多的安全措施，尤其是防重入攻击机制。关键的合约函数（如 <code>swap</code>、<code>mint</code> 和 <code>burn</code>）都使用了锁（lock）机制，避免了可能的重入攻击。</li>
<li>还进行了 Gas 优化，减少了不必要的存储读取，提升了交易效率。</li>
</ul>
<h3 id="V2-的优势总结"><a href="#V2-的优势总结" class="headerlink" title="V2 的优势总结"></a><strong>V2 的优势总结</strong></h3><ol>
<li><strong>更高的灵活性</strong>：支持任意两种 ERC-20 代币交易，取消了 ETH 作为中介的限制。</li>
<li><strong>价格预言功能</strong>：引入了 TWAP，更加安全和稳定的价格获取方式。</li>
<li><strong>创新的闪电交换</strong>：支持用户无需预先资金即可执行复杂的交易逻辑，增加了协议的可用性。</li>
<li><strong>更强的安全性</strong>：防重入攻击和 Gas 优化使得协议在安全性和性能上都有提升。</li>
<li><strong>更高效的交易</strong>：减少了交易成本和复杂性，使交易变得更加高效和用户友好。</li>
</ol>
<hr>
<h2 id="2-Uniswap-V2的核心特点"><a href="#2-Uniswap-V2的核心特点" class="headerlink" title="(2).Uniswap V2的核心特点"></a>(2).Uniswap V2的核心特点</h2><blockquote>
<p>Uniswap V2是一种基于以太坊的去中心化交易协议，旨在提供快速、安全、无信任的代币交换服务。它是Uniswap协议的第二个版本，是对第一个版本的改进和升级。</p>
</blockquote>
<h3 id="Uniswap-V2的核心特点包括以下几个方面："><a href="#Uniswap-V2的核心特点包括以下几个方面：" class="headerlink" title="Uniswap V2的核心特点包括以下几个方面："></a>Uniswap V2的核心特点包括以下几个方面：</h3><ol>
<li><strong>去中心化交易</strong>：Uniswap V2使用智能合约来执行交易，而不需要传统的中心化交易所。这意味着用户可以直接通过他们的以太坊钱包进行交易，无需信任或依赖第三方中介。</li>
<li><strong>自动化做市商模型</strong>：Uniswap V2采用自动化做市商模型，其中流动性提供者可以将资金存入流动性池中，并通过提供资金来帮助形成交易对的市场价格。这种模型使得任何人都可以成为流动性提供者，并从交易手续费中获得奖励。</li>
<li><strong>常量乘积函数</strong>：Uniswap V2使用常量乘积函数作为交易价格计算模型。根据这个函数，交易所需的两种代币的数量乘积在交易前后保持不变，从而决定了交易价格。这种机制可以在没有订单簿的情况下进行交易，并保持相对简单和高效。</li>
<li><strong>ERC-20代币支持</strong>：Uniswap V2支持以太坊上的ERC-20代币进行交易。用户可以通过选择不同的代币对进行交易，并且任何人都可以创建新的代币对，只需提供相应的流动性即可。</li>
<li><strong>流动性挖矿</strong>：Uniswap V2引入了流动性挖矿机制，通过奖励流动性提供者来吸引更多的资金注入流动性池。流动性提供者可以获得代币奖励作为对其提供流动性的补偿，如果市场价格剧烈波动，您存入的资金可能面临损失。</li>
</ol>
<hr>
<h2 id="3-Uniswap-V2源码注解–UniswapV2Factory"><a href="#3-Uniswap-V2源码注解–UniswapV2Factory" class="headerlink" title="(3).Uniswap V2源码注解–UniswapV2Factory"></a>(3).Uniswap V2源码注解–UniswapV2Factory</h2><ul>
<li>先贴一下源码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity =0.5.16;</span><br><span class="line"></span><br><span class="line">import &#x27;./interfaces/IUniswapV2Factory.sol&#x27;;</span><br><span class="line">import &#x27;./UniswapV2Pair.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract UniswapV2Factory is IUniswapV2Factory &#123;</span><br><span class="line">    address public feeTo;</span><br><span class="line">    //function feeTo() external view returns (address)：返回收取手续费地址</span><br><span class="line">    </span><br><span class="line">    address public feeToSetter;</span><br><span class="line">    //function feeToSetter() external view returns (address)：设置手续费收取地址的权限地址</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; address)) public getPair;</span><br><span class="line">     //function getPair(address tokenA, address tokenB) external view returns (address pair)：获取两个token的交易对地址</span><br><span class="line">     </span><br><span class="line">    address[] public allPairs;</span><br><span class="line">     //function allPairs(uint) external view returns (address pair)：返回指定位置的交易对地址</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    event PairCreated(address indexed token0, address indexed token1, address pair, uint);</span><br><span class="line"></span><br><span class="line">    constructor(address _feeToSetter) public &#123;</span><br><span class="line">        feeToSetter = _feeToSetter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allPairsLength() external view returns (uint) &#123;</span><br><span class="line">        return allPairs.length;</span><br><span class="line">        //function allPairsLength() external view returns (uint)：返回所有交易对的长度</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createPair(address tokenA, address tokenB) external returns (address pair) &#123;</span><br><span class="line">    //function createPair(address tokenA, address tokenB) external returns (address pair)：创建两个token的交易对地址</span><br><span class="line">        require(tokenA != tokenB, &#x27;UniswapV2: IDENTICAL_ADDRESSES&#x27;);</span><br><span class="line">        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span><br><span class="line">        require(token0 != address(0), &#x27;UniswapV2: ZERO_ADDRESS&#x27;);</span><br><span class="line">        require(getPair[token0][token1] == address(0), &#x27;UniswapV2: PAIR_EXISTS&#x27;); // single check is sufficient</span><br><span class="line">        bytes memory bytecode = type(UniswapV2Pair).creationCode;</span><br><span class="line">        bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">        assembly &#123;</span><br><span class="line">        	//add(bytecode, 32)：opcode操作码的add方法,将bytecode偏移后32位字节处,因为前32位字节存的是bytecode长度</span><br><span class="line">			//mload(bytecode)：opcode操作码的方法,获得bytecode长度</span><br><span class="line">            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)</span><br><span class="line">        &#125;</span><br><span class="line">        IUniswapV2Pair(pair).initialize(token0, token1);</span><br><span class="line">        getPair[token0][token1] = pair;</span><br><span class="line">        getPair[token1][token0] = pair; // populate mapping in the reverse direction</span><br><span class="line">        allPairs.push(pair);</span><br><span class="line">        emit PairCreated(token0, token1, pair, allPairs.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setFeeTo(address _feeTo) external &#123;</span><br><span class="line">        require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;);</span><br><span class="line">        feeTo = _feeTo;</span><br><span class="line">        //function setFeeTo(address) external：更改收取手续费地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setFeeToSetter(address _feeToSetter) external &#123;</span><br><span class="line">        require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;);</span><br><span class="line">        feeToSetter = _feeToSetter;</span><br><span class="line">        //function setFeeToSetter(address) external：更改设置手续费收取地址的权限地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>上述合约中的每个方法后面都跟上了方法的目的，现在让我们单独来看这段代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bytes32 salt = keccak256(abi.encodePacked(token0, token1));//-1</span><br><span class="line"></span><br><span class="line">bytes memory bytecode = type(UniswapV2Pair).creationCode;//-2</span><br><span class="line"></span><br><span class="line">assembly &#123;</span><br><span class="line">	//add(bytecode, 32)：opcode操作码的add方法,将bytecode偏移后32位字节处,因为前32位字节存的是bytecode长度</span><br><span class="line">	//mload(bytecode)：opcode操作码的方法,获得bytecode长度</span><br><span class="line">	pair := create2(0, add(bytecode, 32), mload(bytecode), salt)</span><br><span class="line">&#125;//-3</span><br></pre></td></tr></table></figure>

<ol>
<li><p>这段代码使用了 Solidity 的 <strong><code>create2</code></strong> 操作来部署一个智能合约(UniswapV2Pair-交易对合约)，并且采用了 <strong><code>keccak256</code></strong> 哈希函数来生成一个唯一的 <strong>salt</strong>。<strong>salt</strong> 是基于 <code>token0</code> 和 <code>token1</code> 这两个代币地址组合生成的。<code>keccak256</code> 是一种常用的加密哈希算法，生成的 32 字节值（<code>bytes32</code> 类型）将作为 <code>create2</code> 操作的盐值。</p>
</li>
<li><p>这一行获取 <code>UniswapV2Pair</code> 合约的 <strong>字节码</strong>，也就是合约的创建代码。<code>type(UniswapV2Pair).creationCode</code> 获取 <code>UniswapV2Pair</code> 合约的字节码，<code>UniswapV2Pair</code> 是 Uniswap 中定义交易对（pair）的合约。</p>
<p><code>bytecode</code> 变量将包含该合约的构造代码（即部署时的合约代码），它将被用来部署新的 <code>UniswapV2Pair</code> 合约。</p>
</li>
<li><p>这一部分使用了 Solidity 中的 <strong>低级 <code>assembly</code></strong> 来执行合约的部署。</p>
<ul>
<li><p><code>add(bytecode, 32)</code>：由于字节码的前 32 字节存储的是字节码的长度，所以 <code>add(bytecode, 32)</code> 将字节码的位置偏移 32 字节，确保我们获得的是字节码本身，而不是字节码长度。</p>
</li>
<li><p><code>mload(bytecode)</code>：该操作会返回存储在 <code>bytecode</code> 地址中的第一个 32 字节（即字节码的长度）。</p>
</li>
<li><p><code>create2 </code>是一个低级操作码，用来根据 <code>salt</code> 和字节码部署一个新的合约。</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>它的参数如下：<ul>
<li><code>0</code>：这是部署合约时传递的以太坊余额。这里是 0，意味着不向新合约发送以太坊。</li>
<li><code>add(bytecode, 32)</code>：字节码的地址（偏移了 32 字节）。<ul>
<li><code>mload(bytecode)</code>：字节码的长度。</li>
<li><code>salt</code>：前面生成的盐值，这里是基于 <code>token0</code> 和 <code>token1</code> 地址计算得到的哈希值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><code>create2</code> 的作用是根据提供的字节码和盐值来确定合约地址，从而在部署合约时保证合约地址的唯一性</strong>。即通过盐值与字节码计算生成合约地址，并在相同的输入条件下，每次都能部署到相同的地址。</p>
<p><code>create2</code> 可以避免在多个合约部署过程中产生冲突，特别是在合约地址已知的情况下，可以确保合约地址的可预测性。这在一些 DeFi 协议中非常有用，比如 Uniswap 使用 <code>create2</code> 部署交易对合约（<code>UniswapV2Pair</code>），这样每对代币的交易对合约地址都是唯一且可预测的。</p>
<blockquote>
<p>assembly-内联汇编：在 Solidity 源程序中嵌入汇编代码，对 EVM 有更细粒度的控制</p>
</blockquote>
<hr>
<h2 id="4-Uniswap-V2源码注解–UniswapV2Pair"><a href="#4-Uniswap-V2源码注解–UniswapV2Pair" class="headerlink" title="(4).Uniswap V2源码注解–UniswapV2Pair"></a>(4).Uniswap V2源码注解–UniswapV2Pair</h2><blockquote>
<p>还是先在这里贴一下源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity =0.5.16;</span><br><span class="line"></span><br><span class="line">import &#x27;./interfaces/IUniswapV2Pair.sol&#x27;;</span><br><span class="line">import &#x27;./UniswapV2ERC20.sol&#x27;;</span><br><span class="line">import &#x27;./libraries/Math.sol&#x27;;</span><br><span class="line">import &#x27;./libraries/UQ112x112.sol&#x27;;</span><br><span class="line">import &#x27;./interfaces/IERC20.sol&#x27;;</span><br><span class="line">import &#x27;./interfaces/IUniswapV2Factory.sol&#x27;;</span><br><span class="line">import &#x27;./interfaces/IUniswapV2Callee.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 &#123;</span><br><span class="line">    using SafeMath  for uint;</span><br><span class="line">    using UQ112x112 for uint224;</span><br><span class="line"></span><br><span class="line">    uint public constant MINIMUM_LIQUIDITY = 10**3;</span><br><span class="line">    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(&#x27;transfer(address,uint256)&#x27;)));</span><br><span class="line"></span><br><span class="line">    address public factory;</span><br><span class="line">    address public token0;</span><br><span class="line">    address public token1;</span><br><span class="line"></span><br><span class="line">    uint112 private reserve0;           // uses single storage slot, accessible via getReserves</span><br><span class="line">    uint112 private reserve1;           // uses single storage slot, accessible via getReserves</span><br><span class="line">    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves</span><br><span class="line"></span><br><span class="line">    uint public price0CumulativeLast;</span><br><span class="line">    uint public price1CumulativeLast;</span><br><span class="line">    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event</span><br><span class="line"></span><br><span class="line">    uint private unlocked = 1;</span><br><span class="line">    modifier lock() &#123;</span><br><span class="line">        require(unlocked == 1, &#x27;UniswapV2: LOCKED&#x27;);</span><br><span class="line">        unlocked = 0;</span><br><span class="line">        _;</span><br><span class="line">        unlocked = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) &#123;</span><br><span class="line">        _reserve0 = reserve0;</span><br><span class="line">        _reserve1 = reserve1;</span><br><span class="line">        _blockTimestampLast = blockTimestampLast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _safeTransfer(address token, address to, uint value) private &#123;</span><br><span class="line">        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));</span><br><span class="line">        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#x27;UniswapV2: TRANSFER_FAILED&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Mint(address indexed sender, uint amount0, uint amount1);</span><br><span class="line">    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);</span><br><span class="line">    event Swap(</span><br><span class="line">        address indexed sender,</span><br><span class="line">        uint amount0In,</span><br><span class="line">        uint amount1In,</span><br><span class="line">        uint amount0Out,</span><br><span class="line">        uint amount1Out,</span><br><span class="line">        address indexed to</span><br><span class="line">    );</span><br><span class="line">    event Sync(uint112 reserve0, uint112 reserve1);</span><br><span class="line"></span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        factory = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // called once by the factory at time of deployment</span><br><span class="line">    function initialize(address _token0, address _token1) external &#123;</span><br><span class="line">        require(msg.sender == factory, &#x27;UniswapV2: FORBIDDEN&#x27;); // sufficient check</span><br><span class="line">        token0 = _token0;</span><br><span class="line">        token1 = _token1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // update reserves and, on the first call per block, price accumulators</span><br><span class="line">    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private &#123;</span><br><span class="line">        require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#x27;UniswapV2: OVERFLOW&#x27;);</span><br><span class="line">        uint32 blockTimestamp = uint32(block.timestamp % 2**32);</span><br><span class="line">        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired</span><br><span class="line">        if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123;</span><br><span class="line">            // * never overflows, and + overflow is desired</span><br><span class="line">            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;</span><br><span class="line">            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;</span><br><span class="line">        &#125;</span><br><span class="line">        reserve0 = uint112(balance0);</span><br><span class="line">        reserve1 = uint112(balance1);</span><br><span class="line">        blockTimestampLast = blockTimestamp;</span><br><span class="line">        emit Sync(reserve0, reserve1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)</span><br><span class="line">    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) &#123;</span><br><span class="line">        address feeTo = IUniswapV2Factory(factory).feeTo();</span><br><span class="line">        feeOn = feeTo != address(0);</span><br><span class="line">        uint _kLast = kLast; // gas savings</span><br><span class="line">        if (feeOn) &#123;</span><br><span class="line">            if (_kLast != 0) &#123;</span><br><span class="line">                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));</span><br><span class="line">                uint rootKLast = Math.sqrt(_kLast);</span><br><span class="line">                if (rootK &gt; rootKLast) &#123;</span><br><span class="line">                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));</span><br><span class="line">                    uint denominator = rootK.mul(5).add(rootKLast);</span><br><span class="line">                    uint liquidity = numerator / denominator;</span><br><span class="line">                    if (liquidity &gt; 0) _mint(feeTo, liquidity);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (_kLast != 0) &#123;</span><br><span class="line">            kLast = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // this low-level function should be called from a contract which performs important safety checks</span><br><span class="line">    function mint(address to) external lock returns (uint liquidity) &#123;</span><br><span class="line">        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings</span><br><span class="line">        uint balance0 = IERC20(token0).balanceOf(address(this));</span><br><span class="line">        uint balance1 = IERC20(token1).balanceOf(address(this));</span><br><span class="line">        uint amount0 = balance0.sub(_reserve0);</span><br><span class="line">        uint amount1 = balance1.sub(_reserve1);</span><br><span class="line"></span><br><span class="line">        bool feeOn = _mintFee(_reserve0, _reserve1);</span><br><span class="line">        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee</span><br><span class="line">        if (_totalSupply == 0) &#123;</span><br><span class="line">            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);</span><br><span class="line">           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);</span><br><span class="line">        &#125;</span><br><span class="line">        require(liquidity &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED&#x27;);</span><br><span class="line">        _mint(to, liquidity);</span><br><span class="line"></span><br><span class="line">        _update(balance0, balance1, _reserve0, _reserve1);</span><br><span class="line">        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date</span><br><span class="line">        emit Mint(msg.sender, amount0, amount1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // this low-level function should be called from a contract which performs important safety checks</span><br><span class="line">    function burn(address to) external lock returns (uint amount0, uint amount1) &#123;</span><br><span class="line">        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings</span><br><span class="line">        address _token0 = token0;                                // gas savings</span><br><span class="line">        address _token1 = token1;                                // gas savings</span><br><span class="line">        uint balance0 = IERC20(_token0).balanceOf(address(this));</span><br><span class="line">        uint balance1 = IERC20(_token1).balanceOf(address(this));</span><br><span class="line">        uint liquidity = balanceOf[address(this)];</span><br><span class="line"></span><br><span class="line">        bool feeOn = _mintFee(_reserve0, _reserve1);</span><br><span class="line">        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee</span><br><span class="line">        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution</span><br><span class="line">        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution</span><br><span class="line">        require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED&#x27;);</span><br><span class="line">        _burn(address(this), liquidity);</span><br><span class="line">        _safeTransfer(_token0, to, amount0);</span><br><span class="line">        _safeTransfer(_token1, to, amount1);</span><br><span class="line">        balance0 = IERC20(_token0).balanceOf(address(this));</span><br><span class="line">        balance1 = IERC20(_token1).balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">        _update(balance0, balance1, _reserve0, _reserve1);</span><br><span class="line">        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date</span><br><span class="line">        emit Burn(msg.sender, amount0, amount1, to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // this low-level function should be called from a contract which performs important safety checks</span><br><span class="line">    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock &#123;</span><br><span class="line">        require(amount0Out &gt; 0 || amount1Out &gt; 0, &#x27;UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT&#x27;);</span><br><span class="line">        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings</span><br><span class="line">        require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY&#x27;);</span><br><span class="line"></span><br><span class="line">        uint balance0;</span><br><span class="line">        uint balance1;</span><br><span class="line">        &#123; // scope for _token&#123;0,1&#125;, avoids stack too deep errors</span><br><span class="line">        address _token0 = token0;</span><br><span class="line">        address _token1 = token1;</span><br><span class="line">        require(to != _token0 &amp;&amp; to != _token1, &#x27;UniswapV2: INVALID_TO&#x27;);</span><br><span class="line">        if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens</span><br><span class="line">        if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens</span><br><span class="line">        if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);</span><br><span class="line">        balance0 = IERC20(_token0).balanceOf(address(this));</span><br><span class="line">        balance1 = IERC20(_token1).balanceOf(address(this));</span><br><span class="line">        &#125;</span><br><span class="line">        uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;</span><br><span class="line">        uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;</span><br><span class="line">        require(amount0In &gt; 0 || amount1In &gt; 0, &#x27;UniswapV2: INSUFFICIENT_INPUT_AMOUNT&#x27;);</span><br><span class="line">        &#123; // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors</span><br><span class="line">        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));</span><br><span class="line">        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));</span><br><span class="line">        require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), &#x27;UniswapV2: K&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _update(balance0, balance1, _reserve0, _reserve1);</span><br><span class="line">        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // force balances to match reserves</span><br><span class="line">    function skim(address to) external lock &#123;</span><br><span class="line">        address _token0 = token0; // gas savings</span><br><span class="line">        address _token1 = token1; // gas savings</span><br><span class="line">        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));</span><br><span class="line">        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // force reserves to match balances</span><br><span class="line">    function sync() external lock &#123;</span><br><span class="line">        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于源码太长，注释我就单独拆开写了</p>
</blockquote>
<h3 id="合约当中比较重要的方法有-lptoken即UniswapV2ERC20"><a href="#合约当中比较重要的方法有-lptoken即UniswapV2ERC20" class="headerlink" title="合约当中比较重要的方法有(lptoken即UniswapV2ERC20):"></a>合约当中比较重要的方法有(lptoken即UniswapV2ERC20):</h3><ul>
<li><p>function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external：判断签名的有效性</p>
</li>
<li><p>function mint(address to) external returns (uint liquidity)：铸造lptoken</p>
</li>
<li><p>function burn(address to) external returns (uint amount0, uint amount1)：销毁lptoken退出流动性</p>
</li>
<li><p>function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external：根据tokenA的数量在交易池中进行兑换tokenB</p>
</li>
<li><p>function skim(address to) external：使两个token的余额与储备相等</p>
</li>
<li><p>function sync() external：使两个token的储备与余额相匹配</p>
</li>
<li><p>function initialize(address, address) external：设置pair地址交易对的两种token</p>
</li>
</ul>
<h4 id="1-permit-address-owner-address-spender-uint-value-uint-deadline-uint8-v-bytes32-r-bytes32-s-–用于代币授权"><a href="#1-permit-address-owner-address-spender-uint-value-uint-deadline-uint8-v-bytes32-r-bytes32-s-–用于代币授权" class="headerlink" title="[1].permit:(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s)–用于代币授权"></a>[1].permit:(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s)–用于代币授权</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ecrecover 函数可以返回与签名者对应的公钥地址</span><br><span class="line">address recoveredAddress = ecrecover(digest, v, r, s);</span><br><span class="line">// 判断签名者对应的公钥地址与授权地址是否一致</span><br><span class="line">require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &#x27;UniswapV2: INVALID_SIGNATURE&#x27;);</span><br><span class="line">_approve(owner, spender, value);</span><br></pre></td></tr></table></figure>

<p>判断数字签名的有效性，如果通过判断即给予授权</p>
<p>允许用户在不直接调用 <code>approve</code> 方法的情况下，使用签名授权另一个地址 <code>spender</code> 执行代币转移操作。这个方法利用 <strong>EIP-2612</strong> 标准，允许用户通过签名来批准代币的转移，减少了用户需要在链上交易的次数。</p>
<h4 id="2-mint：-address-to-lock-returns-uint-liquidity-–也就是铸造流动性代币"><a href="#2-mint：-address-to-lock-returns-uint-liquidity-–也就是铸造流动性代币" class="headerlink" title="[2].mint：(address to) lock returns (uint liquidity)–也就是铸造流动性代币"></a>[2].mint：(address to) lock returns (uint liquidity)–也就是铸造流动性代币</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取储备量：通过 getReserves() 获取当前交易对的两种代币的储备量（_reserve0 和 _reserve1）</span><br><span class="line">(uint112 _reserve0, uint112 _reserve1, ) = getReserves();</span><br><span class="line">uint balance0 = IERC20(token0).balanceOf(address(this));</span><br><span class="line">uint balance1 = IERC20(token1).balanceOf(address(this));</span><br><span class="line">uint amount0 = balance0.sub(_reserve0);</span><br><span class="line">uint amount1 = balance1.sub(_reserve1);</span><br><span class="line">// 2.调用_mintFee方法</span><br><span class="line">// 3.添加流动性所获得的lptoken数量(进行添加流动性的两种token的数量*目前lptoken的数量/当前token的储备量--&gt;取较小值)</span><br><span class="line">liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);</span><br><span class="line">// 4.铸造lptoken函数和更新储备函数</span><br><span class="line">_mint(to, liquidity); //调用 _mint() 方法将 LP Token 分配给 to 地址。</span><br><span class="line">_update(balance0, balance1, _reserve0, _reserve1);//通过 _update() 更新储备，确保合约内部的代币余额与储备一致</span><br></pre></td></tr></table></figure>

<p>根据两个token在交易对的增量计算出应该铸造lptoken的数量，然后将lptoken铸造给to地址，具有防重入锁lock</p>
<h4 id="3-burn：-address-to-lock-returns-uint-amount0-uint-amount1-–销毁流动性代币并提取代币"><a href="#3-burn：-address-to-lock-returns-uint-amount0-uint-amount1-–销毁流动性代币并提取代币" class="headerlink" title="[3].burn：(address to) lock returns (uint amount0, uint amount1)–销毁流动性代币并提取代币"></a>[3].burn：(address to) lock returns (uint amount0, uint amount1)–销毁流动性代币并提取代币</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 1.为什么用addres(this)?--&gt;因为获取退出lptoken数量时，是在Route合约中先将lptoken转到当前合约，然后直接获得当前合约lptoken的数量</span><br><span class="line">uint liquidity = balanceOf[address(this)];</span><br><span class="line">// 2.调用_mintFee方法</span><br><span class="line">// 3.使用余额确保按比例分配--&gt;(持有lptoken/总lptoken)*合约中持有token的数量</span><br><span class="line">amount0 = liquidity.mul(balance0) / _totalSupply; </span><br><span class="line">amount1 = liquidity.mul(balance1) / _totalSupply; </span><br><span class="line">// 4.转账两种token并更新储备量</span><br><span class="line">_safeTransfer(_token0, to, amount0);</span><br><span class="line">_safeTransfer(_token1, to, amount1);</span><br><span class="line">balance0 = IERC20(_token0).balanceOf(address(this));</span><br><span class="line">balance1 = IERC20(_token1).balanceOf(address(this));</span><br><span class="line">_update(balance0, balance1, _reserve0, _reserve1);</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>：</p>
<ol>
<li><p>用户销毁 LP Token 后，从流动性池中提取相应数量的两种代币。它是 <code>mint</code> 方法的反操作。</p>
</li>
<li><p>根据lptokne的比例计算出两种token的各自的数量，然后销毁lptoken并将转账两种token给to地址</p>
</li>
</ol>
<h4 id="4-swap：-uint-amount0Out-uint-amount1Out-address-to-bytes-calldata-data-–进行代币交换"><a href="#4-swap：-uint-amount0Out-uint-amount1Out-address-to-bytes-calldata-data-–进行代币交换" class="headerlink" title="[4].swap：(uint amount0Out, uint amount1Out, address to, bytes calldata data)–进行代币交换"></a>[4].swap：(uint amount0Out, uint amount1Out, address to, bytes calldata data)–进行代币交换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1.转移代币</span><br><span class="line">if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); </span><br><span class="line">if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); </span><br><span class="line">// 2.用于回调合约来实现一些特定的业务逻辑或其他自定义功能(例如：闪电贷....)</span><br><span class="line">if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);</span><br><span class="line">// 3.确保在交易完成后，资金池的储备量满足 Uniswap V2 中的 K 恒定公式，即 K = _reserve0 * _reserve1</span><br><span class="line">// 4.更新储备</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>：进行代币交换，在两个代币之间进行兑换，更新流动性池的储备，并确保符合 <strong>恒定积</strong> K（<code>K = reserve0 * reserve1</code>）公式。</p>
<ol>
<li><p>在Route合约用户已经将需要兑换的tokenA转入pair合约中，在Route合约中传入需要输出的tokenB的数量和一个data，转移tokenB后判断data长度是否大于零去进行回调合约</p>
</li>
<li><p>直接调用swap方法进行回调合约获得套利，只要套利后满足后续条件即可</p>
</li>
</ol>
<h2 id="合约内部调用的方法："><a href="#合约内部调用的方法：" class="headerlink" title="合约内部调用的方法："></a>合约内部调用的方法：</h2><ul>
<li><h4 id="update：-uint-balance0-uint-balance1-uint112-reserve0-uint112-reserve1-private"><a href="#update：-uint-balance0-uint-balance1-uint112-reserve0-uint112-reserve1-private" class="headerlink" title="_update：(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private"></a>_update：(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private</h4></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1.更新priceCumulativeLast，永远不会溢出，+ overflow是理想的</span><br><span class="line">price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;</span><br><span class="line">price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;</span><br><span class="line">// 2.更新储备量</span><br><span class="line">reserve0 = uint112(balance0);</span><br><span class="line">reserve1 = uint112(balance1);</span><br></pre></td></tr></table></figure>

<p>更新储备方法：四个参数前两个为更新后两个token的储备量，后两个为更新前两个token的储备量</p>
<ul>
<li><h4 id="mintFee：-uint112-reserve0-uint112-reserve1-private-returns-bool-feeOn"><a href="#mintFee：-uint112-reserve0-uint112-reserve1-private-returns-bool-feeOn" class="headerlink" title="_mintFee：(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn)"></a>_mintFee：(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn)</h4></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取收取手续费的地址如果不是零地址并且kLast!=0则继续下面部分</span><br><span class="line">// 2.获取上一次交易后和目前交易对中的K值</span><br><span class="line">uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));</span><br><span class="line">uint rootKLast = Math.sqrt(_kLast);</span><br><span class="line">// 3.如果rootK&gt;rootKLast</span><br><span class="line">uint numerator = totalSupply.mul(rootK.sub(rootKLast));</span><br><span class="line">uint denominator = rootK.mul(5).add(rootKLast);</span><br><span class="line">uint liquidity = numerator / denominator;</span><br><span class="line">// 4.如果liquidity大于零为收取手续费地址铸造lptoken </span><br><span class="line">if (liquidity &gt; 0) _mint(feeTo, liquidity);</span><br></pre></td></tr></table></figure>

<p>收取手续费方法，参数为当前两个token的储备量</p>
<blockquote>
<p>感觉仅仅是简析源码就已经写了这么多了，所以对V2的这两个core合约的关系和总结我就留到下篇文章再写了</p>
</blockquote>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/news/">← Next 就像冬天下雪，不算多特别</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2024/11/29/uniswap-v1-ill-deep/">Uniswap V1--深度探索 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/1.png" alt="Logo"></a><h1 id="Dr"><a>0xOne1eaF</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Uniswap-V2%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E7%AE%80%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">Uniswap V2核心代码简析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Uniswap-V2-%E7%9B%B8%E8%BE%83%E4%BA%8EV1%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.1.</span> <span class="toc-text">(1).Uniswap V2 相较于V1的优势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%94%AF%E6%8C%81%E4%BB%BB%E6%84%8F%E4%BB%A3%E5%B8%81%E5%AF%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 支持任意代币对</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E5%85%A5%E4%BA%86%E6%97%B6%E9%97%B4%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87%E4%BB%B7%E6%A0%BC%EF%BC%88TWAP%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 引入了时间加权平均价格（TWAP）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8F%90%E4%BE%9B%E9%97%AA%E7%94%B5%E4%BA%A4%E6%8D%A2%EF%BC%88Flash-Swap%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. 提供闪电交换（Flash Swap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%94%B9%E8%BF%9B%E7%9A%84%E6%89%8B%E7%BB%AD%E8%B4%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. 改进的手续费机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%94%AF%E6%8C%81%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E4%BA%A4%E6%98%93%E9%80%BB%E8%BE%91"><span class="toc-number">1.1.5.</span> <span class="toc-text">5. 支持更复杂的交易逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AE%89%E5%85%A8%E6%80%A7%E5%A2%9E%E5%BC%BA"><span class="toc-number">1.1.6.</span> <span class="toc-text">6. 安全性增强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V2-%E7%9A%84%E4%BC%98%E5%8A%BF%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.7.</span> <span class="toc-text">V2 的优势总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Uniswap-V2%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">(2).Uniswap V2的核心特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniswap-V2%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9%E5%8C%85%E6%8B%AC%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">Uniswap V2的核心特点包括以下几个方面：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Uniswap-V2%E6%BA%90%E7%A0%81%E6%B3%A8%E8%A7%A3%E2%80%93UniswapV2Factory"><span class="toc-number">1.3.</span> <span class="toc-text">(3).Uniswap V2源码注解–UniswapV2Factory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Uniswap-V2%E6%BA%90%E7%A0%81%E6%B3%A8%E8%A7%A3%E2%80%93UniswapV2Pair"><span class="toc-number">1.4.</span> <span class="toc-text">(4).Uniswap V2源码注解–UniswapV2Pair</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%BD%93%E4%B8%AD%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89-lptoken%E5%8D%B3UniswapV2ERC20"><span class="toc-number">1.4.1.</span> <span class="toc-text">合约当中比较重要的方法有(lptoken即UniswapV2ERC20):</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-permit-address-owner-address-spender-uint-value-uint-deadline-uint8-v-bytes32-r-bytes32-s-%E2%80%93%E7%94%A8%E4%BA%8E%E4%BB%A3%E5%B8%81%E6%8E%88%E6%9D%83"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">[1].permit:(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s)–用于代币授权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-mint%EF%BC%9A-address-to-lock-returns-uint-liquidity-%E2%80%93%E4%B9%9F%E5%B0%B1%E6%98%AF%E9%93%B8%E9%80%A0%E6%B5%81%E5%8A%A8%E6%80%A7%E4%BB%A3%E5%B8%81"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">[2].mint：(address to) lock returns (uint liquidity)–也就是铸造流动性代币</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-burn%EF%BC%9A-address-to-lock-returns-uint-amount0-uint-amount1-%E2%80%93%E9%94%80%E6%AF%81%E6%B5%81%E5%8A%A8%E6%80%A7%E4%BB%A3%E5%B8%81%E5%B9%B6%E6%8F%90%E5%8F%96%E4%BB%A3%E5%B8%81"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">[3].burn：(address to) lock returns (uint amount0, uint amount1)–销毁流动性代币并提取代币</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-swap%EF%BC%9A-uint-amount0Out-uint-amount1Out-address-to-bytes-calldata-data-%E2%80%93%E8%BF%9B%E8%A1%8C%E4%BB%A3%E5%B8%81%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">[4].swap：(uint amount0Out, uint amount1Out, address to, bytes calldata data)–进行代币交换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.5.</span> <span class="toc-text">合约内部调用的方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#update%EF%BC%9A-uint-balance0-uint-balance1-uint112-reserve0-uint112-reserve1-private"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">_update：(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mintFee%EF%BC%9A-uint112-reserve0-uint112-reserve1-private-returns-bool-feeOn"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">_mintFee：(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn)</span></a></li></ol></li></ol></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>